{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack-shared/src/utils/globals.tsx"],"sourcesContent":["const globalVar: any =\n  typeof globalThis !== 'undefined' ? globalThis :\n    typeof global !== 'undefined' ? global :\n      typeof window !== 'undefined' ? window :\n        typeof self !== 'undefined' ? self :\n          {};\nexport {\n  globalVar\n};\n\nif (typeof globalThis === 'undefined') {\n  (globalVar as any).globalThis = globalVar;\n}\n\nconst stackGlobalsSymbol = Symbol.for('__stack-globals');\nglobalVar[stackGlobalsSymbol] ??= {};\n\nexport function createGlobal<T>(key: string, init: () => T) {\n  if (!globalVar[stackGlobalsSymbol][key]) {\n    globalVar[stackGlobalsSymbol][key] = init();\n  }\n  return globalVar[stackGlobalsSymbol][key] as T;\n}\n\nexport function getGlobal(key: string): any {\n  return globalVar[stackGlobalsSymbol][key];\n}\n\nexport function setGlobal(key: string, value: any) {\n  globalVar[stackGlobalsSymbol][key] = value;\n}\n"],"names":[],"mappings":";;;;;;;;;;;AAAA,IAAM,YACJ,OAAO,eAAe,cAAc,aAClC,OAAO,WAAW,cAAc,kEAC9B,OAAO,WAAW,cAAc,SAC9B,OAAO,SAAS,cAAc,OAC5B,CAAC;AAKX,IAAI,OAAO,eAAe,aAAa;IACpC,UAAkB,UAAA,GAAa;AAClC;AAEA,IAAM,qBAAqB,OAAO,GAAA,CAAI,iBAAiB;AACvD,SAAA,CAAU,kBAAkB,CAAA,KAAM,CAAC;AAE5B,SAAS,aAAgB,GAAA,EAAa,IAAA,EAAe;IAC1D,IAAI,CAAC,SAAA,CAAU,kBAAkB,CAAA,CAAE,GAAG,CAAA,EAAG;QACvC,SAAA,CAAU,kBAAkB,CAAA,CAAE,GAAG,CAAA,GAAI,KAAK;IAC5C;IACA,OAAO,SAAA,CAAU,kBAAkB,CAAA,CAAE,GAAG,CAAA;AAC1C;AAEO,SAAS,UAAU,GAAA,EAAkB;IAC1C,OAAO,SAAA,CAAU,kBAAkB,CAAA,CAAE,GAAG,CAAA;AAC1C;AAEO,SAAS,UAAU,GAAA,EAAa,KAAA,EAAY;IACjD,SAAA,CAAU,kBAAkB,CAAA,CAAE,GAAG,CAAA,GAAI;AACvC"}},
    {"offset": {"line": 39, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack-shared/src/utils/compile-time.tsx"],"sourcesContent":["/**\n * Returns the first argument passed to it, but compilers won't be able to optimize it out. This is useful in some\n * cases where compiler warnings go awry; for example, when importing things that may not exist (but are guaranteed\n * to exist at runtime).\n */\nexport function scrambleDuringCompileTime<T>(t: T): T {\n  if (Math.random() < 0.00001 && Math.random() > 0.99999 && Math.random() < 0.00001 && Math.random() > 0.99999) {\n    return \"this will never happen\" as any;\n  }\n  return t;\n}\n"],"names":[],"mappings":";;;;;AAKO,SAAS,0BAA6B,CAAA,EAAS;IACpD,IAAI,KAAK,MAAA,CAAO,IAAI,QAAW,KAAK,MAAA,CAAO,IAAI,WAAW,KAAK,MAAA,CAAO,IAAI,QAAW,KAAK,MAAA,CAAO,IAAI,SAAS;QAC5G,OAAO;IACT;IACA,OAAO;AACT"}},
    {"offset": {"line": 56, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack-shared/src/utils/functions.tsx"],"sourcesContent":["export function identity<T>(t: T): T {\n  return t;\n}\nundefined?.test(\"identity\", ({ expect }) => {\n  expect(identity(1)).toBe(1);\n  expect(identity(\"test\")).toBe(\"test\");\n  expect(identity(null)).toBe(null);\n  expect(identity(undefined)).toBe(undefined);\n  const obj = { a: 1 };\n  expect(identity(obj)).toBe(obj);\n});\n\nexport function identityArgs<T extends any[]>(...args: T): T {\n  return args;\n}\nundefined?.test(\"identityArgs\", ({ expect }) => {\n  expect(identityArgs()).toEqual([]);\n  expect(identityArgs(1)).toEqual([1]);\n  expect(identityArgs(1, 2, 3)).toEqual([1, 2, 3]);\n  expect(identityArgs(\"a\", \"b\", \"c\")).toEqual([\"a\", \"b\", \"c\"]);\n  expect(identityArgs(null, undefined)).toEqual([null, undefined]);\n});\n"],"names":[],"mappings":";;;;;;;AAAO,SAAS,SAAY,CAAA,EAAS;IACnC,OAAO;AACT;AAUO,SAAS,aAAA,GAAiC,IAAA,EAAY;IAC3D,OAAO;AACT"}},
    {"offset": {"line": 75, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack-shared/src/utils/math.tsx"],"sourcesContent":["/**\n * Similar to the modulo operator, but always returns a positive number (even when the input is negative).\n */\nexport function remainder(n: number, d: number): number {\n  return ((n % d) + Math.abs(d)) % d;\n}\nundefined?.test(\"remainder\", ({ expect }) => {\n  expect(remainder(10, 3)).toBe(1);\n  expect(remainder(10, 5)).toBe(0);\n  expect(remainder(10, 7)).toBe(3);\n  // Test with negative numbers\n  expect(remainder(-10, 3)).toBe(2);\n  expect(remainder(-5, 2)).toBe(1);\n  expect(remainder(-7, 4)).toBe(1);\n  // Test with decimal numbers\n  expect(remainder(10.5, 3)).toBeCloseTo(1.5);\n  expect(remainder(-10.5, 3)).toBeCloseTo(1.5);\n});\n"],"names":[],"mappings":";;;;;AAGO,SAAS,UAAU,CAAA,EAAW,CAAA,EAAmB;IACtD,OAAA,CAAS,IAAI,IAAK,KAAK,GAAA,CAAI,CAAC,CAAA,IAAK;AACnC"}},
    {"offset": {"line": 89, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack-shared/src/utils/arrays.tsx"],"sourcesContent":["import { remainder } from \"./math\";\n\nexport function typedIncludes<T extends readonly any[]>(arr: T, item: unknown): item is T[number] {\n  return arr.includes(item);\n}\nundefined?.test(\"typedIncludes\", ({ expect }) => {\n  const arr = [1, 2, 3] as const;\n  expect(typedIncludes(arr, 1)).toBe(true);\n  expect(typedIncludes(arr, 4)).toBe(false);\n  expect(typedIncludes(arr, \"1\")).toBe(false);\n\n  const strArr = [\"a\", \"b\", \"c\"] as const;\n  expect(typedIncludes(strArr, \"a\")).toBe(true);\n  expect(typedIncludes(strArr, \"d\")).toBe(false);\n});\n\nexport function enumerate<T extends readonly any[]>(arr: T): [number, T[number]][] {\n  return arr.map((item, index) => [index, item]);\n}\nundefined?.test(\"enumerate\", ({ expect }) => {\n  expect(enumerate([])).toEqual([]);\n  expect(enumerate([1, 2, 3])).toEqual([[0, 1], [1, 2], [2, 3]]);\n  expect(enumerate([\"a\", \"b\", \"c\"])).toEqual([[0, \"a\"], [1, \"b\"], [2, \"c\"]]);\n});\n\nexport function isShallowEqual(a: readonly any[], b: readonly any[]): boolean {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\nundefined?.test(\"isShallowEqual\", ({ expect }) => {\n  expect(isShallowEqual([], [])).toBe(true);\n  expect(isShallowEqual([1, 2, 3], [1, 2, 3])).toBe(true);\n  expect(isShallowEqual([1, 2, 3], [1, 2, 4])).toBe(false);\n  expect(isShallowEqual([1, 2, 3], [1, 2])).toBe(false);\n  expect(isShallowEqual([1, 2], [1, 2, 3])).toBe(false);\n  // Test with objects (reference equality)\n  const obj1 = { a: 1 };\n  const obj2 = { a: 1 };\n  expect(isShallowEqual([obj1], [obj1])).toBe(true);\n  expect(isShallowEqual([obj1], [obj2])).toBe(false);\n});\n\n/**\n * Ponyfill for ES2023's findLastIndex.\n */\nexport function findLastIndex<T>(arr: readonly T[], predicate: (item: T) => boolean): number {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (predicate(arr[i])) return i;\n  }\n  return -1;\n}\nundefined?.test(\"findLastIndex\", ({ expect }) => {\n  expect(findLastIndex([], () => true)).toBe(-1);\n  expect(findLastIndex([1, 2, 3, 4, 5], x => x % 2 === 0)).toBe(3); // 4 is at index 3\n  expect(findLastIndex([1, 2, 3, 4, 5], x => x > 10)).toBe(-1);\n  expect(findLastIndex([1, 2, 3, 2, 1], x => x === 2)).toBe(3);\n  expect(findLastIndex([1, 2, 3], x => x === 1)).toBe(0);\n});\n\nexport function groupBy<T extends any, K>(\n  arr: Iterable<T>,\n  key: (item: T) => K,\n): Map<K, T[]> {\n  const result = new Map<K, T[]>;\n  for (const item of arr) {\n    const k = key(item);\n    if (result.get(k) === undefined) result.set(k, []);\n    result.get(k)!.push(item);\n  }\n  return result;\n}\nundefined?.test(\"groupBy\", ({ expect }) => {\n  expect(groupBy([], (x) => x)).toEqual(new Map());\n\n  const numbers = [1, 2, 3, 4, 5, 6];\n  const grouped = groupBy(numbers, (n) => n % 2 === 0 ? \"even\" : \"odd\");\n  expect(grouped.get(\"even\")).toEqual([2, 4, 6]);\n  expect(grouped.get(\"odd\")).toEqual([1, 3, 5]);\n\n  // Check the actual lengths of the words to ensure our test is correct\n  const words = [\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"];\n\n  const byLength = groupBy(words, (w) => w.length);\n  // Adjust expectations based on actual word lengths\n  expect(byLength.get(5)).toEqual([\"apple\"]);\n  expect(byLength.get(6)).toEqual([\"banana\", \"cherry\"]);\n  expect(byLength.get(4)).toEqual([\"date\"]);\n  expect(byLength.get(10)).toEqual([\"elderberry\"]);\n});\n\nexport function range(endExclusive: number): number[];\nexport function range(startInclusive: number, endExclusive: number): number[];\nexport function range(startInclusive: number, endExclusive: number, step: number): number[];\nexport function range(startInclusive: number, endExclusive?: number, step?: number): number[] {\n  if (endExclusive === undefined) {\n    endExclusive = startInclusive;\n    startInclusive = 0;\n  }\n  if (step === undefined) step = 1;\n\n  const result = [];\n  for (let i = startInclusive; step > 0 ? (i < endExclusive) : (i > endExclusive); i += step) {\n    result.push(i);\n  }\n  return result;\n}\nundefined?.test(\"range\", ({ expect }) => {\n  expect(range(5)).toEqual([0, 1, 2, 3, 4]);\n  expect(range(2, 5)).toEqual([2, 3, 4]);\n  expect(range(1, 10, 2)).toEqual([1, 3, 5, 7, 9]);\n  expect(range(5, 0, -1)).toEqual([5, 4, 3, 2, 1]);\n  expect(range(0, 0)).toEqual([]);\n  expect(range(0, 10, 3)).toEqual([0, 3, 6, 9]);\n});\n\n\nexport function rotateLeft(arr: readonly any[], n: number): any[] {\n  if (arr.length === 0) return [];\n  const index = remainder(n, arr.length);\n  return [...arr.slice(index), ...arr.slice(0, index)];\n}\nundefined?.test(\"rotateLeft\", ({ expect }) => {\n  expect(rotateLeft([], 1)).toEqual([]);\n  expect(rotateLeft([1, 2, 3, 4, 5], 0)).toEqual([1, 2, 3, 4, 5]);\n  expect(rotateLeft([1, 2, 3, 4, 5], 1)).toEqual([2, 3, 4, 5, 1]);\n  expect(rotateLeft([1, 2, 3, 4, 5], 3)).toEqual([4, 5, 1, 2, 3]);\n  expect(rotateLeft([1, 2, 3, 4, 5], 5)).toEqual([1, 2, 3, 4, 5]);\n  expect(rotateLeft([1, 2, 3, 4, 5], 6)).toEqual([2, 3, 4, 5, 1]);\n});\n\nexport function rotateRight(arr: readonly any[], n: number): any[] {\n  return rotateLeft(arr, -n);\n}\nundefined?.test(\"rotateRight\", ({ expect }) => {\n  expect(rotateRight([], 1)).toEqual([]);\n  expect(rotateRight([1, 2, 3, 4, 5], 0)).toEqual([1, 2, 3, 4, 5]);\n  expect(rotateRight([1, 2, 3, 4, 5], 1)).toEqual([5, 1, 2, 3, 4]);\n  expect(rotateRight([1, 2, 3, 4, 5], 3)).toEqual([3, 4, 5, 1, 2]);\n  expect(rotateRight([1, 2, 3, 4, 5], 5)).toEqual([1, 2, 3, 4, 5]);\n  expect(rotateRight([1, 2, 3, 4, 5], 6)).toEqual([5, 1, 2, 3, 4]);\n});\n\n\nexport function shuffle<T>(arr: readonly T[]): T[] {\n  const result = [...arr];\n  for (let i = result.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [result[i], result[j]] = [result[j], result[i]];\n  }\n  return result;\n}\nundefined?.test(\"shuffle\", ({ expect }) => {\n  // Test empty array\n  expect(shuffle([])).toEqual([]);\n\n  // Test single element array\n  expect(shuffle([1])).toEqual([1]);\n\n  // Test that shuffle returns a new array\n  const original = [1, 2, 3, 4, 5];\n  const shuffled = shuffle(original);\n  expect(shuffled).not.toBe(original);\n\n  // Test that all elements are preserved\n  expect(shuffled.sort((a, b) => a - b)).toEqual(original);\n\n  // Test with a larger array to ensure randomness\n  // This is a probabilistic test, but it's very unlikely to fail\n  const large = Array.from({ length: 100 }, (_, i) => i);\n  const shuffledLarge = shuffle(large);\n  expect(shuffledLarge).not.toEqual(large);\n  expect(shuffledLarge.sort((a, b) => a - b)).toEqual(large);\n});\n\n\nexport function outerProduct<T, U>(arr1: readonly T[], arr2: readonly U[]): [T, U][] {\n  return arr1.flatMap((item1) => arr2.map((item2) => [item1, item2] as [T, U]));\n}\nundefined?.test(\"outerProduct\", ({ expect }) => {\n  expect(outerProduct([], [])).toEqual([]);\n  expect(outerProduct([1], [])).toEqual([]);\n  expect(outerProduct([], [1])).toEqual([]);\n  expect(outerProduct([1], [2])).toEqual([[1, 2]]);\n  expect(outerProduct([1, 2], [3, 4])).toEqual([[1, 3], [1, 4], [2, 3], [2, 4]]);\n  expect(outerProduct([\"a\", \"b\"], [1, 2])).toEqual([[\"a\", 1], [\"a\", 2], [\"b\", 1], [\"b\", 2]]);\n});\n\nexport function unique<T>(arr: readonly T[]): T[] {\n  return [...new Set(arr)];\n}\nundefined?.test(\"unique\", ({ expect }) => {\n  expect(unique([])).toEqual([]);\n  expect(unique([1, 2, 3])).toEqual([1, 2, 3]);\n  expect(unique([1, 2, 2, 3, 1, 3])).toEqual([1, 2, 3]);\n  // Test with objects (reference equality)\n  const obj = { a: 1 };\n  expect(unique([obj, obj])).toEqual([obj]);\n  // Test with different types\n  expect(unique([1, \"1\", true, 1, \"1\", true])).toEqual([1, \"1\", true]);\n});\n\n\nexport function getChunks<T>(arr: readonly T[], size: number): T[][] {\n  const result: T[][] = [];\n  if (size <= 0) return result;\n  for (let i = 0; i < arr.length; i += size) {\n    result.push(arr.slice(i, i + size));\n  }\n  return result;\n}\nundefined?.test(\"getChunks\", ({ expect }) => {\n  expect(getChunks([], 2)).toEqual([]);\n  expect(getChunks([1], 2)).toEqual([[1]]);\n  expect(getChunks([1, 2], 2)).toEqual([[1, 2]]);\n  expect(getChunks([1, 2, 3], 2)).toEqual([[1, 2], [3]]);\n  expect(getChunks([1, 2, 3, 4, 5], 2)).toEqual([[1, 2], [3, 4], [5]]);\n  expect(getChunks([1, 2, 3, 4], 3)).toEqual([[1, 2, 3], [4]]);\n  expect(getChunks([1, 2, 3], 0)).toEqual([]);\n  expect(getChunks([1, 2, 3], -1)).toEqual([]);\n});\n\nexport function isStringArray(arr: unknown): arr is string[] {\n  return Array.isArray(arr) && arr.every((item) => typeof item === \"string\");\n}\nexport function isNumberArray(arr: unknown): arr is number[] {\n  return Array.isArray(arr) && arr.every((item) => typeof item === \"number\");\n}\nexport function isBooleanArray(arr: unknown): arr is boolean[] {\n  return Array.isArray(arr) && arr.every((item) => typeof item === \"boolean\");\n}\nexport function isObjectArray(arr: unknown): arr is object[] {\n  return Array.isArray(arr) && arr.every((item) => typeof item === \"object\" && item !== null);\n}\nundefined?.test(\"is<Type>Array\", ({ expect }) => {\n  expect(isStringArray([])).toBe(true);\n  expect(isNumberArray([1, 2, 3])).toBe(true);\n  expect(isBooleanArray([true, false, true])).toBe(true);\n  expect(isObjectArray([{ a: 1 }, { b: 2 }, { c: 3 }])).toBe(true);\n  expect(isStringArray([1, 2, 3])).toBe(false);\n  expect(isNumberArray([\"a\", \"b\", \"c\"])).toBe(false);\n  expect(isBooleanArray([1, 2, 3])).toBe(false);\n  expect(isObjectArray([1, 2, 3])).toBe(false);\n  expect(isObjectArray([{ a: 1 }, null, { b: 2 }])).toBe(false);\n  expect(isObjectArray([{ a: 1 }, undefined, { b: 2 }])).toBe(false);\n});\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 230, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack-shared/src/utils/strings.tsx"],"sourcesContent":["import { findLastIndex, unique } from \"./arrays\";\nimport { StackAssertionError } from \"./errors\";\nimport { filterUndefined } from \"./objects\";\n\nexport type Join<T extends string[], Separator extends string> =\n  T extends [] ? \"\"\n    : T extends [infer U extends string, ...infer Rest extends string[]]\n      ? `${U}${Rest extends [any, ...any[]] ? `${Separator}${Join<Rest, Separator>}` : \"\"}`\n      : \"<error-joining-strings>\";\n\nexport function typedJoin<T extends string[], Separator extends string>(strings: T, separator: Separator): Join<T, Separator> {\n  return strings.join(separator) as Join<T, Separator>;\n}\n\nexport function typedToLowercase<S extends string>(s: S): Lowercase<S> {\n  if (typeof s !== \"string\") throw new StackAssertionError(\"Expected a string for typedToLowercase\", { s });\n  return s.toLowerCase() as Lowercase<S>;\n}\nundefined?.test(\"typedToLowercase\", ({ expect }) => {\n  expect(typedToLowercase(\"\")).toBe(\"\");\n  expect(typedToLowercase(\"HELLO\")).toBe(\"hello\");\n  expect(typedToLowercase(\"Hello World\")).toBe(\"hello world\");\n  expect(typedToLowercase(\"hello\")).toBe(\"hello\");\n  expect(typedToLowercase(\"123\")).toBe(\"123\");\n  expect(typedToLowercase(\"MIXED123case\")).toBe(\"mixed123case\");\n  expect(typedToLowercase(\"Special@Chars!\")).toBe(\"special@chars!\");\n  expect(() => typedToLowercase(123 as any)).toThrow(\"Expected a string for typedToLowercase\");\n});\n\nexport function typedToUppercase<S extends string>(s: S): Uppercase<S> {\n  if (typeof s !== \"string\") throw new StackAssertionError(\"Expected a string for typedToUppercase\", { s });\n  return s.toUpperCase() as Uppercase<S>;\n}\nundefined?.test(\"typedToUppercase\", ({ expect }) => {\n  expect(typedToUppercase(\"\")).toBe(\"\");\n  expect(typedToUppercase(\"hello\")).toBe(\"HELLO\");\n  expect(typedToUppercase(\"Hello World\")).toBe(\"HELLO WORLD\");\n  expect(typedToUppercase(\"HELLO\")).toBe(\"HELLO\");\n  expect(typedToUppercase(\"123\")).toBe(\"123\");\n  expect(typedToUppercase(\"mixed123Case\")).toBe(\"MIXED123CASE\");\n  expect(typedToUppercase(\"special@chars!\")).toBe(\"SPECIAL@CHARS!\");\n  expect(() => typedToUppercase(123 as any)).toThrow(\"Expected a string for typedToUppercase\");\n});\n\nexport function typedCapitalize<S extends string>(s: S): Capitalize<S> {\n  return s.charAt(0).toUpperCase() + s.slice(1) as Capitalize<S>;\n}\nundefined?.test(\"typedCapitalize\", ({ expect }) => {\n  expect(typedCapitalize(\"\")).toBe(\"\");\n  expect(typedCapitalize(\"hello\")).toBe(\"Hello\");\n  expect(typedCapitalize(\"hello world\")).toBe(\"Hello world\");\n  expect(typedCapitalize(\"HELLO\")).toBe(\"HELLO\");\n  expect(typedCapitalize(\"123test\")).toBe(\"123test\");\n  expect(typedCapitalize(\"already Capitalized\")).toBe(\"Already Capitalized\");\n  expect(typedCapitalize(\"h\")).toBe(\"H\");\n});\n\n/**\n * Compares two strings in a way that is not dependent on the current locale.\n */\nexport function stringCompare(a: string, b: string): number {\n  if (typeof a !== \"string\" || typeof b !== \"string\") throw new StackAssertionError(`Expected two strings for stringCompare, found ${typeof a} and ${typeof b}`, { a, b });\n  const cmp = (a: string, b: string) => a < b ? -1 : a > b ? 1 : 0;\n  return cmp(a.toUpperCase(), b.toUpperCase()) || cmp(b, a);\n}\nundefined?.test(\"stringCompare\", ({ expect }) => {\n  // Equal strings\n  expect(stringCompare(\"a\", \"a\")).toBe(0);\n  expect(stringCompare(\"\", \"\")).toBe(0);\n\n  // Case comparison - note that this function is NOT case-insensitive\n  // It compares uppercase versions first, then original strings\n  expect(stringCompare(\"a\", \"A\")).toBe(-1); // lowercase comes after uppercase\n  expect(stringCompare(\"A\", \"a\")).toBe(1);  // uppercase comes before lowercase\n  expect(stringCompare(\"abc\", \"ABC\")).toBe(-1);\n  expect(stringCompare(\"ABC\", \"abc\")).toBe(1);\n\n  // Different strings\n  expect(stringCompare(\"a\", \"b\")).toBe(-1);\n  expect(stringCompare(\"b\", \"a\")).toBe(1);\n\n  // Strings with different lengths\n  expect(stringCompare(\"abc\", \"abcd\")).toBe(-1);\n  expect(stringCompare(\"abcd\", \"abc\")).toBe(1);\n\n  // Strings with numbers\n  expect(stringCompare(\"a1\", \"a2\")).toBe(-1);\n  expect(stringCompare(\"a10\", \"a2\")).toBe(-1);\n\n  // Strings with special characters\n  expect(stringCompare(\"a\", \"a!\")).toBe(-1);\n  expect(stringCompare(\"a!\", \"a\")).toBe(1);\n});\n\n/**\n * Returns all whitespace character at the start of the string.\n *\n * Uses the same definition for whitespace as `String.prototype.trim()`.\n */\nexport function getWhitespacePrefix(s: string): string {\n  return s.substring(0, s.length - s.trimStart().length);\n}\nundefined?.test(\"getWhitespacePrefix\", ({ expect }) => {\n  expect(getWhitespacePrefix(\"\")).toBe(\"\");\n  expect(getWhitespacePrefix(\"hello\")).toBe(\"\");\n  expect(getWhitespacePrefix(\" hello\")).toBe(\" \");\n  expect(getWhitespacePrefix(\"  hello\")).toBe(\"  \");\n  expect(getWhitespacePrefix(\"\\thello\")).toBe(\"\\t\");\n  expect(getWhitespacePrefix(\"\\n hello\")).toBe(\"\\n \");\n  expect(getWhitespacePrefix(\"   \")).toBe(\"   \");\n  expect(getWhitespacePrefix(\" \\t\\n\\r\")).toBe(\" \\t\\n\\r\");\n});\n\n/**\n * Returns all whitespace character at the end of the string.\n *\n * Uses the same definition for whitespace as `String.prototype.trim()`.\n */\nexport function getWhitespaceSuffix(s: string): string {\n  return s.substring(s.trimEnd().length);\n}\nundefined?.test(\"getWhitespaceSuffix\", ({ expect }) => {\n  expect(getWhitespaceSuffix(\"\")).toBe(\"\");\n  expect(getWhitespaceSuffix(\"hello\")).toBe(\"\");\n  expect(getWhitespaceSuffix(\"hello \")).toBe(\" \");\n  expect(getWhitespaceSuffix(\"hello  \")).toBe(\"  \");\n  expect(getWhitespaceSuffix(\"hello\\t\")).toBe(\"\\t\");\n  expect(getWhitespaceSuffix(\"hello \\n\")).toBe(\" \\n\");\n  expect(getWhitespaceSuffix(\"   \")).toBe(\"   \");\n  expect(getWhitespaceSuffix(\" \\t\\n\\r\")).toBe(\" \\t\\n\\r\");\n});\n\n/**\n * Returns a string with all empty or whitespace-only lines at the start removed.\n *\n * Uses the same definition for whitespace as `String.prototype.trim()`.\n */\nexport function trimEmptyLinesStart(s: string): string {\n  const lines = s.split(\"\\n\");\n  const firstNonEmptyLineIndex = lines.findIndex((line) => line.trim() !== \"\");\n  // If all lines are empty or whitespace-only, return an empty string\n  if (firstNonEmptyLineIndex === -1) return \"\";\n  return lines.slice(firstNonEmptyLineIndex).join(\"\\n\");\n}\nundefined?.test(\"trimEmptyLinesStart\", ({ expect }) => {\n  expect(trimEmptyLinesStart(\"\")).toBe(\"\");\n  expect(trimEmptyLinesStart(\"hello\")).toBe(\"hello\");\n  expect(trimEmptyLinesStart(\"\\nhello\")).toBe(\"hello\");\n  expect(trimEmptyLinesStart(\"\\n\\nhello\")).toBe(\"hello\");\n  expect(trimEmptyLinesStart(\"  \\n\\t\\nhello\")).toBe(\"hello\");\n  expect(trimEmptyLinesStart(\"\\n\\nhello\\nworld\")).toBe(\"hello\\nworld\");\n  expect(trimEmptyLinesStart(\"hello\\n\\nworld\")).toBe(\"hello\\n\\nworld\");\n  expect(trimEmptyLinesStart(\"hello\\nworld\\n\")).toBe(\"hello\\nworld\\n\");\n  expect(trimEmptyLinesStart(\"\\n  \\n\\nhello\\n  \\nworld\")).toBe(\"hello\\n  \\nworld\");\n  // Edge case: all lines are empty\n  expect(trimEmptyLinesStart(\"\\n\\n  \\n\\t\")).toBe(\"\");\n});\n\n/**\n * Returns a string with all empty or whitespace-only lines at the end removed.\n *\n * Uses the same definition for whitespace as `String.prototype.trim()`.\n */\nexport function trimEmptyLinesEnd(s: string): string {\n  const lines = s.split(\"\\n\");\n  const lastNonEmptyLineIndex = findLastIndex(lines, (line) => line.trim() !== \"\");\n  return lines.slice(0, lastNonEmptyLineIndex + 1).join(\"\\n\");\n}\nundefined?.test(\"trimEmptyLinesEnd\", ({ expect }) => {\n  expect(trimEmptyLinesEnd(\"\")).toBe(\"\");\n  expect(trimEmptyLinesEnd(\"hello\")).toBe(\"hello\");\n  expect(trimEmptyLinesEnd(\"hello\\n\")).toBe(\"hello\");\n  expect(trimEmptyLinesEnd(\"hello\\n\\n\")).toBe(\"hello\");\n  expect(trimEmptyLinesEnd(\"hello\\n  \\n\\t\")).toBe(\"hello\");\n  expect(trimEmptyLinesEnd(\"hello\\nworld\\n\\n\")).toBe(\"hello\\nworld\");\n  expect(trimEmptyLinesEnd(\"hello\\n\\nworld\")).toBe(\"hello\\n\\nworld\");\n  expect(trimEmptyLinesEnd(\"\\nhello\\nworld\")).toBe(\"\\nhello\\nworld\");\n  expect(trimEmptyLinesEnd(\"hello\\n  \\nworld\\n\\n  \")).toBe(\"hello\\n  \\nworld\");\n  // Edge case: all lines are empty\n  expect(trimEmptyLinesEnd(\"\\n\\n  \\n\\t\")).toBe(\"\");\n});\n\n/**\n * Returns a string with all empty or whitespace-only lines trimmed at the start and end.\n *\n * Uses the same definition for whitespace as `String.prototype.trim()`.\n */\nexport function trimLines(s: string): string {\n  return trimEmptyLinesEnd(trimEmptyLinesStart(s));\n}\nundefined?.test(\"trimLines\", ({ expect }) => {\n  expect(trimLines(\"\")).toBe(\"\");\n  expect(trimLines(\" \")).toBe(\"\");\n  expect(trimLines(\" \\n \")).toBe(\"\");\n  expect(trimLines(\" abc \")).toBe(\" abc \");\n  expect(trimLines(\"\\n  \\nLine1\\nLine2\\n \\n\")).toBe(\"Line1\\nLine2\");\n  expect(trimLines(\"Line1\\n   \\nLine2\")).toBe(\"Line1\\n   \\nLine2\");\n  expect(trimLines(\" \\n    \\n\\t\")).toBe(\"\");\n  expect(trimLines(\"   Hello World\")).toBe(\"   Hello World\");\n  expect(trimLines(\"\\n\")).toBe(\"\");\n  expect(trimLines(\"\\t \\n\\t\\tLine1 \\n \\nLine2\\t\\t\\n\\t  \")).toBe(\"\\t\\tLine1 \\n \\nLine2\\t\\t\");\n});\n\n\n/**\n * A template literal tag that returns the same string as the template literal without a tag.\n *\n * Useful for implementing your own template literal tags.\n */\nexport function templateIdentity(strings: TemplateStringsArray | readonly string[], ...values: string[]): string {\n  if (values.length !== strings.length - 1) throw new StackAssertionError(\"Invalid number of values; must be one less than strings\", { strings, values });\n\n  return strings.reduce((result, str, i) => result + str + (values[i] ?? ''), '');\n}\nundefined?.test(\"templateIdentity\", ({ expect }) => {\n  expect(templateIdentity`Hello World`).toBe(\"Hello World\");\n  expect(templateIdentity`${\"Hello\"}`).toBe(\"Hello\");\n  const greeting = \"Hello\";\n  const subject = \"World\";\n  expect(templateIdentity`${greeting}, ${subject}!`).toBe(\"Hello, World!\");\n  expect(templateIdentity`${\"A\"}${\"B\"}${\"C\"}`).toBe(\"ABC\");\n  expect(templateIdentity`Start${\"\"}Middle${\"\"}End`).toBe(\"StartMiddleEnd\");\n  expect(templateIdentity``).toBe(\"\");\n  expect(templateIdentity`Line1\nLine2`).toBe(\"Line1\\nLine2\");\n  expect(templateIdentity([\"a \", \" scientific \", \"gun\"], \"certain\", \"rail\")).toBe(\"a certain scientific railgun\");\n  expect(templateIdentity([\"only one part\"])).toBe(\"only one part\");\n  expect(() => templateIdentity([\"a \", \"b\", \"c\"], \"only one\")).toThrow(\"Invalid number of values\");\n  expect(() => templateIdentity([\"a\", \"b\"], \"x\", \"y\")).toThrow(\"Invalid number of values\");\n});\n\n\nexport function deindent(code: string): string;\nexport function deindent(strings: TemplateStringsArray | readonly string[], ...values: any[]): string;\nexport function deindent(strings: string | readonly string[], ...values: any[]): string {\n  if (typeof strings === \"string\") return deindent([strings]);\n  return templateIdentity(...deindentTemplate(strings, ...values));\n}\n\nexport function deindentTemplate(strings: TemplateStringsArray | readonly string[], ...values: any[]): [string[], ...string[]] {\n  if (values.length !== strings.length - 1) throw new StackAssertionError(\"Invalid number of values; must be one less than strings\", { strings, values });\n\n  const trimmedStrings = [...strings];\n  trimmedStrings[0] = trimEmptyLinesStart(trimmedStrings[0] + \"+\").slice(0, -1);\n  trimmedStrings[trimmedStrings.length - 1] = trimEmptyLinesEnd(\"+\" + trimmedStrings[trimmedStrings.length - 1]).slice(1);\n\n  const indentation = trimmedStrings\n    .join(\"${SOME_VALUE}\")\n    .split(\"\\n\")\n    .filter((line) => line.trim() !== \"\")\n    .map((line) => getWhitespacePrefix(line).length)\n    .reduce((min, current) => Math.min(min, current), Infinity);\n\n  const deindentedStrings = trimmedStrings\n    .map((string, stringIndex) => {\n      return string\n        .split(\"\\n\")\n        .map((line, lineIndex) => stringIndex !== 0 && lineIndex === 0 ? line : line.substring(indentation))\n        .join(\"\\n\");\n    });\n\n  const indentedValues = values.map((value, i) => {\n    const firstLineIndentation = getWhitespacePrefix(deindentedStrings[i].split(\"\\n\").at(-1)!);\n    return `${value}`.replaceAll(\"\\n\", `\\n${firstLineIndentation}`);\n  });\n\n  return [deindentedStrings, ...indentedValues];\n}\nundefined?.test(\"deindent\", ({ expect }) => {\n  // Test with string input\n  expect(deindent(\"  hello\")).toBe(\"hello\");\n  expect(deindent(\"  hello\\n  world\")).toBe(\"hello\\nworld\");\n  expect(deindent(\"  hello\\n    world\")).toBe(\"hello\\n  world\");\n  expect(deindent(\"\\n  hello\\n  world\\n\")).toBe(\"hello\\nworld\");\n\n  // Test with empty input\n  expect(deindent(\"\")).toBe(\"\");\n\n  // Test with template literal\n  expect(deindent`\n    hello\n    world\n  `).toBe(\"hello\\nworld\");\n\n  expect(deindent`\n    hello\n      world\n  `).toBe(\"hello\\n  world\");\n\n  // Test with values\n  const value = \"test\";\n  expect(deindent`\n    hello ${value}\n    world\n  `).toBe(`hello ${value}\\nworld`);\n\n  // Test with multiline values\n  expect(deindent`\n    hello\n      to ${\"line1\\n  line2\"}\n    world\n  `).toBe(`hello\\n  to line1\\n    line2\\nworld`);\n\n  // Leading whitespace values\n  expect(deindent`\n    ${\"  \"}A\n    ${\"  \"}B\n    ${\"  \"}C\n  `).toBe(`  A\\n  B\\n  C`);\n\n  // Trailing whitespaces (note: there are two whitespaces each after A and after C)\n  expect(deindent`\n    A  \n    B  ${\"  \"}\n    C  \n  `).toBe(`A  \\nB    \\nC  `);\n\n  // Test with mixed indentation\n  expect(deindent`\n    hello\n      world\n        !\n  `).toBe(\"hello\\n  world\\n    !\");\n\n  // Test error cases\n  expect(() => deindent([\"a\", \"b\", \"c\"], \"too\", \"many\", \"values\")).toThrow(\"Invalid number of values\");\n});\n\nexport function extractScopes(scope: string, removeDuplicates=true): string[] {\n  // TODO what is this for? can we move this into the OAuth code in the backend?\n  const trimmedString = scope.trim();\n  const scopesArray = trimmedString.split(/\\s+/);\n  const filtered = scopesArray.filter(scope => scope.length > 0);\n  return removeDuplicates ? [...new Set(filtered)] : filtered;\n}\nundefined?.test(\"extractScopes\", ({ expect }) => {\n  // Test with empty string\n  expect(extractScopes(\"\")).toEqual([]);\n\n  // Test with single scope\n  expect(extractScopes(\"read\")).toEqual([\"read\"]);\n\n  // Test with multiple scopes\n  expect(extractScopes(\"read write\")).toEqual([\"read\", \"write\"]);\n\n  // Test with extra whitespace\n  expect(extractScopes(\"  read  write  \")).toEqual([\"read\", \"write\"]);\n\n  // Test with newlines and tabs\n  expect(extractScopes(\"read\\nwrite\\tdelete\")).toEqual([\"read\", \"write\", \"delete\"]);\n\n  // Test with duplicates (default behavior)\n  expect(extractScopes(\"read write read\")).toEqual([\"read\", \"write\"]);\n\n  // Test with duplicates (explicitly set to remove)\n  expect(extractScopes(\"read write read\", true)).toEqual([\"read\", \"write\"]);\n\n  // Test with duplicates (explicitly set to keep)\n  expect(extractScopes(\"read write read\", false)).toEqual([\"read\", \"write\", \"read\"]);\n});\n\nexport function mergeScopeStrings(...scopes: string[]): string {\n  // TODO what is this for? can we move this into the OAuth code in the backend?\n  const allScope = scopes.map((s) => extractScopes(s)).flat().join(\" \");\n  return extractScopes(allScope).join(\" \");\n}\nundefined?.test(\"mergeScopeStrings\", ({ expect }) => {\n  // Test with empty input\n  expect(mergeScopeStrings()).toBe(\"\");\n\n  // Test with single scope string\n  expect(mergeScopeStrings(\"read write\")).toBe(\"read write\");\n\n  // Test with multiple scope strings\n  expect(mergeScopeStrings(\"read\", \"write\")).toBe(\"read write\");\n\n  // Test with overlapping scopes\n  expect(mergeScopeStrings(\"read write\", \"write delete\")).toBe(\"read write delete\");\n\n  // Test with extra whitespace\n  expect(mergeScopeStrings(\"  read  write  \", \"  delete  \")).toBe(\"read write delete\");\n\n  // Test with duplicates across strings\n  expect(mergeScopeStrings(\"read write\", \"write delete\", \"read\")).toBe(\"read write delete\");\n\n  // Test with empty strings\n  expect(mergeScopeStrings(\"read write\", \"\", \"delete\")).toBe(\"read write delete\");\n});\n\nexport function escapeTemplateLiteral(s: string): string {\n  return s.replaceAll(\"\\\\\", \"\\\\\\\\\").replaceAll(\"`\", \"\\\\`\").replaceAll(\"${\", \"\\\\${\");\n}\nundefined?.test(\"escapeTemplateLiteral\", ({ expect }) => {\n  // Test with empty string\n  expect(escapeTemplateLiteral(\"\")).toBe(\"\");\n\n  // Test with normal string (no special characters)\n  expect(escapeTemplateLiteral(\"hello world\")).toBe(\"hello world\");\n\n  // Test with backtick\n  const input1 = \"hello `world`\";\n  const output1 = escapeTemplateLiteral(input1);\n  // Verify backticks are escaped\n  expect(output1).toBe(\"hello \\\\`world\\\\`\");\n\n  // Test with backslash\n  const input2 = \"hello \\\\world\";\n  const output2 = escapeTemplateLiteral(input2);\n  // Verify backslashes are escaped\n  expect(output2).toBe(\"hello \\\\\\\\world\");\n\n  // Test with dollar sign\n  const input3 = \"hello $world\";\n  const output3 = escapeTemplateLiteral(input3);\n  // Verify dollar signs are escaped\n  expect(output3).toBe(\"hello $world\");\n\n  // Test with dollar sign in interpolation\n  const input4 = \"hello ${$world\";\n  const output4 = escapeTemplateLiteral(input4);\n  // Verify dollar signs are escaped\n  expect(output4).toBe(\"hello \\\\${$world\");\n\n  // Test with multiple special characters\n  const input5 = \"`hello` ${world\\\\\";\n  const output5 = escapeTemplateLiteral(input5);\n  // Verify all special characters are escaped\n  expect(output5).toBe(\"\\\\`hello\\\\` \\\\${world\\\\\\\\\");\n\n  // Test with already escaped characters\n  const input6 = \"\\\\`hello\\\\`\";\n  const output6 = escapeTemplateLiteral(input6);\n  expect(output6).toBe(\"\\\\\\\\\\\\`hello\\\\\\\\\\\\`\");\n});\n\n/**\n * Some classes have different constructor names in different environments (eg. `Headers` is sometimes called `_Headers`,\n * so we create an object of overrides to handle these cases.\n */\nconst nicifiableClassNameOverrides = new Map(Object.entries({\n  Headers,\n} as Record<string, unknown>).map(([k, v]) => [v, k]));\nexport type Nicifiable = {\n  getNicifiableKeys?(): PropertyKey[],\n  getNicifiedObjectExtraLines?(): string[],\n};\nexport type NicifyOptions = {\n  maxDepth: number,\n  currentIndent: string,\n  lineIndent: string,\n  multiline: boolean,\n  refs: Map<unknown, string>,\n  path: string,\n  parent: null | {\n    options: NicifyOptions,\n    value: unknown,\n  },\n  keyInParent: PropertyKey | null,\n  hideFields: PropertyKey[],\n  overrides: (...args: Parameters<typeof nicify>) => string | null,\n};\nexport function nicify(\n  value: unknown,\n  options: Partial<NicifyOptions> = {},\n): string {\n  const fullOptions: NicifyOptions = {\n    maxDepth: 5,\n    currentIndent: \"\",\n    lineIndent: \"  \",\n    multiline: true,\n    refs: new Map(),\n    path: \"value\",\n    parent: null,\n    overrides: () => null,\n    keyInParent: null,\n    hideFields: [],\n    ...filterUndefined(options),\n  };\n  const {\n    maxDepth,\n    currentIndent,\n    lineIndent,\n    multiline,\n    refs,\n    path,\n    overrides,\n    hideFields,\n  } = fullOptions;\n  const nl = `\\n${currentIndent}`;\n\n  const overrideResult = overrides(value, options);\n  if (overrideResult !== null) return overrideResult;\n\n  if ([\"function\", \"object\", \"symbol\"].includes(typeof value) && value !== null) {\n    if (refs.has(value)) {\n      return `Ref<${refs.get(value)}>`;\n    }\n    refs.set(value, path);\n  }\n\n  const newOptions: NicifyOptions = {\n    maxDepth: maxDepth - 1,\n    currentIndent,\n    lineIndent,\n    multiline,\n    refs,\n    path: path + \"->[unknown property]\",\n    overrides,\n    parent: { value, options: fullOptions },\n    keyInParent: null,\n    hideFields: [],\n  };\n  const nestedNicify = (newValue: unknown, newPath: string, keyInParent: PropertyKey | null, options: Partial<NicifyOptions> = {}) => {\n    return nicify(newValue, {\n      ...newOptions,\n      path: newPath,\n      currentIndent: currentIndent + lineIndent,\n      keyInParent,\n      ...options,\n    });\n  };\n\n  switch (typeof value) {\n    case \"boolean\": case \"number\": {\n      return JSON.stringify(value);\n    }\n    case \"string\": {\n      const isDeindentable = (v: string) => deindent(v) === v && v.includes(\"\\n\");\n      const wrapInDeindent = (v: string) => deindent`\n        deindent\\`\n        ${currentIndent + lineIndent}${escapeTemplateLiteral(v).replaceAll(\"\\n\", nl + lineIndent)}\n        ${currentIndent}\\`\n      `;\n      if (isDeindentable(value)) {\n        return wrapInDeindent(value);\n      } else if (value.endsWith(\"\\n\") && isDeindentable(value.slice(0, -1))) {\n        return wrapInDeindent(value.slice(0, -1)) + ' + \"\\\\n\"';\n      } else {\n        return JSON.stringify(value);\n      }\n    }\n    case \"undefined\": {\n      return \"undefined\";\n    }\n    case \"symbol\": {\n      return value.toString();\n    }\n    case \"bigint\": {\n      return `${value}n`;\n    }\n    case \"function\": {\n      if (value.name) return `function ${value.name}(...) { ... }`;\n      return `(...) => { ... }`;\n    }\n    case \"object\": {\n      if (value === null) return \"null\";\n      if (Array.isArray(value)) {\n        const extraLines = getNicifiedObjectExtraLines(value);\n        const resValueLength = value.length + extraLines.length;\n        if (resValueLength === 0) return \"[]\";  // early return in case maxDepth <= 0\n        if (maxDepth <= 0) return `[...]`;\n        const resValues = value.map((v, i) => nestedNicify(v, `${path}[${i}]`, i));\n        resValues.push(...extraLines);\n        if (resValues.length !== resValueLength) throw new StackAssertionError(\"nicify of object: resValues.length !== resValueLength\", { value, resValues, resValueLength });\n        const shouldIndent = resValues.length > 4 || resValues.some(x => (resValues.length > 1 && x.length > 4) || x.includes(\"\\n\"));\n        if (shouldIndent) {\n          return `[${nl}${resValues.map(x => `${lineIndent}${x},${nl}`).join(\"\")}]`;\n        } else {\n          return `[${resValues.join(\", \")}]`;\n        }\n      }\n      if (value instanceof Date) {\n        return `Date(${nestedNicify(value.toISOString(), `${path}.toISOString()`, null)})`;\n      }\n      if (value instanceof URL) {\n        return `URL(${nestedNicify(value.toString(), `${path}.toString()`, null)})`;\n      }\n      if (ArrayBuffer.isView(value)) {\n        return `${value.constructor.name}([${value.toString()}])`;\n      }\n      if (value instanceof ArrayBuffer) {\n        return `ArrayBuffer [${new Uint8Array(value).toString()}]`;\n      }\n      if (value instanceof Error) {\n        let stack = value.stack ?? \"\";\n        const toString = value.toString();\n        if (!stack.startsWith(toString)) stack = `${toString}\\n${stack}`;  // some browsers don't include the error message in the stack, some do\n        stack = stack.trimEnd();\n        stack = stack.replace(/\\n\\s+/g, `\\n${lineIndent}${lineIndent}`);\n        stack = stack.replace(\"\\n\", `\\n${lineIndent}Stack:\\n`);\n        if (Object.keys(value).length > 0) {\n          stack += `\\n${lineIndent}Extra properties: ${nestedNicify(Object.fromEntries(Object.entries(value)), path, null)}`;\n        }\n        if (value.cause) {\n          stack += `\\n${lineIndent}Cause:\\n${lineIndent}${lineIndent}${nestedNicify(value.cause, path, null, { currentIndent: currentIndent + lineIndent + lineIndent })}`;\n        }\n        stack = stack.replaceAll(\"\\n\", `\\n${currentIndent}`);\n        return stack;\n      }\n\n      const constructorName = [null, Object.prototype].includes(Object.getPrototypeOf(value)) ? null : (nicifiableClassNameOverrides.get(value.constructor) ?? value.constructor.name);\n      const constructorString = constructorName ? `${constructorName} ` : \"\";\n\n      const entries = getNicifiableEntries(value).filter(([k]) => !hideFields.includes(k));\n      const extraLines = [\n        ...getNicifiedObjectExtraLines(value),\n        ...hideFields.length > 0 ? [`<some fields may have been hidden>`] : [],\n      ];\n      const resValueLength = entries.length + extraLines.length;\n      if (resValueLength === 0) return `${constructorString}{}`;\n      if (maxDepth <= 0) return `${constructorString}{ ... }`;\n      const resValues = entries.map(([k, v], keyIndex) => {\n        const keyNicified = nestedNicify(k, `Object.keys(${path})[${keyIndex}]`, null);\n        const keyInObjectLiteral = typeof k === \"string\" ? nicifyPropertyString(k) : `[${keyNicified}]`;\n        if (typeof v === \"function\" && v.name === k) {\n          return `${keyInObjectLiteral}(...): { ... }`;\n        } else {\n          return `${keyInObjectLiteral}: ${nestedNicify(v, `${path}[${keyNicified}]`, k)}`;\n        }\n      });\n      resValues.push(...extraLines);\n      if (resValues.length !== resValueLength) throw new StackAssertionError(\"nicify of object: resValues.length !== resValueLength\", { value, resValues, resValueLength });\n      const shouldIndent = resValues.length > 1 || resValues.some(x => x.includes(\"\\n\"));\n\n      if (resValues.length === 0) return `${constructorString}{}`;\n      if (shouldIndent) {\n        return `${constructorString}{${nl}${resValues.map(x => `${lineIndent}${x},${nl}`).join(\"\")}}`;\n      } else {\n        return `${constructorString}{ ${resValues.join(\", \")} }`;\n      }\n    }\n    default: {\n      return `${typeof value}<${value}>`;\n    }\n  }\n}\n\nexport function replaceAll(input: string, searchValue: string, replaceValue: string): string {\n  if (searchValue === \"\") throw new StackAssertionError(\"replaceAll: searchValue is empty\");\n  return input.split(searchValue).join(replaceValue);\n}\nundefined?.test(\"replaceAll\", ({ expect }) => {\n  expect(replaceAll(\"hello world\", \"o\", \"x\")).toBe(\"hellx wxrld\");\n  expect(replaceAll(\"aaa\", \"a\", \"b\")).toBe(\"bbb\");\n  expect(replaceAll(\"\", \"a\", \"b\")).toBe(\"\");\n  expect(replaceAll(\"abc\", \"b\", \"\")).toBe(\"ac\");\n  expect(replaceAll(\"test.test.test\", \".\", \"_\")).toBe(\"test_test_test\");\n  expect(replaceAll(\"a.b*c\", \".\", \"x\")).toBe(\"axb*c\");\n  expect(replaceAll(\"a*b*c\", \"*\", \"x\")).toBe(\"axbxc\");\n  expect(replaceAll(\"hello hello\", \"hello\", \"hi\")).toBe(\"hi hi\");\n});\n\nfunction nicifyPropertyString(str: string) {\n  return JSON.stringify(str);\n}\nundefined?.test(\"nicifyPropertyString\", ({ expect }) => {\n  // Test valid identifiers\n  expect(nicifyPropertyString(\"validName\")).toBe('\"validName\"');\n  expect(nicifyPropertyString(\"_validName\")).toBe('\"_validName\"');\n  expect(nicifyPropertyString(\"valid123Name\")).toBe('\"valid123Name\"');\n\n  // Test invalid identifiers\n  expect(nicifyPropertyString(\"123invalid\")).toBe('\"123invalid\"');\n  expect(nicifyPropertyString(\"invalid-name\")).toBe('\"invalid-name\"');\n  expect(nicifyPropertyString(\"invalid space\")).toBe('\"invalid space\"');\n  expect(nicifyPropertyString(\"$invalid\")).toBe('\"$invalid\"');\n  expect(nicifyPropertyString(\"\")).toBe('\"\"');\n\n  // Test with special characters\n  expect(nicifyPropertyString(\"property!\")).toBe('\"property!\"');\n  expect(nicifyPropertyString(\"property.name\")).toBe('\"property.name\"');\n\n  // Test with escaped characters\n  expect(nicifyPropertyString(\"\\\\\")).toBe('\"\\\\\\\\\"');\n  expect(nicifyPropertyString('\"')).toBe('\"\\\\\"\"');\n});\n\nfunction getNicifiableKeys(value: Nicifiable | object) {\n  const overridden = (\"getNicifiableKeys\" in value ? value.getNicifiableKeys?.bind(value) : null)?.();\n  if (overridden != null) return overridden;\n  if (value instanceof Response) {\n    return ['status', 'headers'];\n  }\n  const keys = Object.keys(value).sort();\n  return unique(keys);\n}\nundefined?.test(\"getNicifiableKeys\", ({ expect }) => {\n  // Test regular object\n  expect(getNicifiableKeys({ b: 1, a: 2, c: 3 })).toEqual([\"a\", \"b\", \"c\"]);\n\n  // Test empty object\n  expect(getNicifiableKeys({})).toEqual([]);\n\n\n  expect(getNicifiableKeys(new Response())).toEqual([\"status\", \"headers\"]);\n\n  // Test object with custom getNicifiableKeys\n  const customObject = {\n    a: 1,\n    b: 2,\n    getNicifiableKeys() {\n      return [\"customKey1\", \"customKey2\"];\n    }\n  };\n  expect(getNicifiableKeys(customObject)).toEqual([\"customKey1\", \"customKey2\"]);\n});\n\nfunction getNicifiableEntries(value: Nicifiable | object): [PropertyKey, unknown][] {\n  const recordLikes = [Headers];\n  function isRecordLike(value: unknown): value is InstanceType<typeof recordLikes[number]> {\n    return recordLikes.some(x => value instanceof x);\n  }\n\n  if (isRecordLike(value)) {\n    return [...value.entries()].sort(([a], [b]) => stringCompare(`${a}`, `${b}`));\n  }\n  const keys = getNicifiableKeys(value);\n  return keys.map((k) => [k, value[k as never]] as [PropertyKey, unknown]);\n}\n\nfunction getNicifiedObjectExtraLines(value: Nicifiable | object) {\n  return (\"getNicifiedObjectExtraLines\" in value ? value.getNicifiedObjectExtraLines : null)?.() ?? [];\n}\n"],"names":["a","b","scope","options","extraLines","resValueLength","resValues","shouldIndent","value"],"mappings":"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"}},
    {"offset": {"line": 621, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack-shared/src/utils/types.tsx"],"sourcesContent":["import { DeepPartial } from \"./objects\";\nimport { Join } from \"./strings\";\n\nexport type IsAny<T> = 0 extends (1 & T) ? true : false;\nexport type IsNever<T> = [T] extends [never] ? true : false;\nexport type IsNullish<T> = [T] extends [null | undefined] ? true : false;\nexport type IsUnion<T, U = T> =\n  IsNever<T> extends true ? false\n  : IsAny<T> extends true ? false\n    : T extends U // distributive conditional https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types\n        ? /* if the *whole* original type (`U`) still fits inside the current variant, then `T` wasnt a union */ ([U] extends [T] ? false : true)\n        : never;\n\nexport type NullishCoalesce<T, U> = T extends null | undefined ? U : T;\n\nexport type LastUnionElement<U> = UnionToIntersection<U extends any ? (x: U) => 0 : never> extends (x: infer L) => 0 ? L & U : never;\n\ntype primitive = string | number | boolean | bigint | symbol | null | undefined;\n\n/**\n * Makes a type prettier by recursively expanding all object types. For example, `Omit<{ a: 1 }, \"a\">` becomes just `{}`.\n */\nexport type Expand<T> = T extends (...args: infer A) => infer R\n  ? ((...args: A) => R) extends T\n    ? (...args: Expand<A>) => Expand<R>\n    : ((...args: Expand<A>) => Expand<R>) & { [K in keyof T]: Expand<T[K]> }\n  : T extends object\n    ? T extends primitive\n      ? T\n      : T extends infer O\n        ? { [K in keyof O]: Expand<O[K]> }\n        : never\n    : T;\n\n\n/**\n * Removes all optional undefined/never keys from an object.\n */\nexport type DeepRemoveOptionalUndefined<T> = T extends object ? { [K in keyof T]: DeepRemoveOptionalUndefined<T[K]> } : T;\n\n// why this works: https://stackoverflow.com/a/50375286\nexport type UnionToIntersection<U> =\n  (U extends any ? (x: U) => void : never) extends ((x: infer I) => void) ? I : never\n\ntype _UnionToTupleInner<U, R extends any[], Last> = UnionToTuple<Exclude<U, Last>, [...R, Last]>\nexport type UnionToTuple<U, R extends any[] = []> = [U] extends [never] ? R : _UnionToTupleInner<U, R, LastUnionElement<U>>;\n\nexport type CollapseObjectUnion<T extends object> = {\n  [K in AllUnionKeys<T>]?: T extends Record<K, infer V> ? V : never;\n};\ntypeAssertIs<CollapseObjectUnion<{ a: string } | { b: number }>, { a?: string, b?: number }>()();\ntypeAssertIs<CollapseObjectUnion<{ a: string } | { a: number }>, { a?: string | number }>()();\n\nexport type IntersectAll<T extends any[]> = UnionToIntersection<T[number]>;\n\nexport type OptionalKeys<T> = {\n  [K in keyof T]: {} extends Pick<T, K> ? K : never;\n}[keyof T];\nexport type RequiredKeys<T> = {\n  [K in keyof T]: {} extends Pick<T, K> ? never : K;\n}[keyof T];\n\n/**\n * Returns a type whose keys are the intersection of the keys of T and U, deeply.\n */\nexport type KeyIntersect<T, U> =\n  | { [K in keyof T & keyof U]?: T[K] & U[K] }\n  | { [K in RequiredKeys<T> & keyof U]: T[K] & U[K] }\n  | { [K in RequiredKeys<U> & keyof T]: U[K] & T[K] }\n\n/**\n * Returns ALL keys of all union elements.\n */\nexport type AllUnionKeys<T extends object> = T extends T ? keyof T : never;\ntypeAssertIs<AllUnionKeys<{ a: string } | { b: number }>, \"a\" | \"b\">()();\n\nexport type SubtractType<T, U> = T extends object ? { [K in keyof T]: K extends keyof U ? SubtractType<T[K], U[K]> : T[K] } : (T extends U ? never : T); // note: this only works due to the distributive property of conditional types https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types\n\nexport type XOR<T extends readonly any[]> = T extends readonly [infer A, infer B, ...infer Rest]\n  ? Rest extends []\n  ? (A & { [K in keyof B]?: never }) | (B & { [K in keyof A]?: never })\n  : XOR<[(A & { [K in keyof B]?: never }) | (B & { [K in keyof A]?: never }), ...Rest]>\n  : T[0];\n\n\ntype _AntiIntersectInner<T, U> = T extends object ? (\n  & Omit<U, keyof T>\n  & { [K in keyof Pick<U, { [K in keyof T & keyof U]: U[K] extends T[K] ? (T[K] extends U[K] ? never : K) : never }[keyof T & keyof U]>]: PseudoAntiIntersect<T[K], U[K]> }\n  & { [K in keyof Pick<U, keyof T & keyof U>]?: PseudoAntiIntersect<T[K], U[K]> }\n) : U;\n/**\n * Returns a type R such that T & R = U.\n */\nexport type AntiIntersect<T, U> = U extends T ? _AntiIntersectInner<T, U> : \"Cannot anti-intersect a type with a type that is not a subtype of it\"; // NOTE: This type is mostly untested  not sure how well it works on the edge cases\nexport type PseudoAntiIntersect<T, U> = _AntiIntersectInner<T, T & U>;\n\n/**\n * A variation of TypeScript's conditionals with slightly different semantics. It is the perfect type for cases where:\n *\n * - If all possible values are contained in `Extends`, then it will be mapped to `Then`.\n * - If all possible values are not contained in `Extends`, then it will be mapped to `Otherwise`.\n * - If some possible values are contained in `Extends` and some are not, then it will be mapped to `Then | Otherwise`.\n *\n * This is different from TypeScript's built-in conditional types (`Value extends Extends ? Then : Otherwise`), which\n * returns `Otherwise` for the third case (causing unsoundness in many real-world cases).\n */\nexport type IfAndOnlyIf<Value, Extends, Then, Otherwise> =\n  | (Value extends Extends ? never : Otherwise)\n  | (Value & Extends extends never ? never : Then);\n\n\n/**\n * Can be used to prettify a type in the IDE; for example, some complicated intersected types can be flattened into a single type.\n */\nexport type PrettifyType<T> = T extends object ? { [K in keyof T]: T[K] } & {} : T;\n\ntype _ToStringAndJoin<T extends any[], Separator extends string> =\n  T extends [infer U, ...infer Rest extends any[]]\n    ? `${TypeToString<U>}${Rest extends [any, ...any[]] ? `${Separator}${_ToStringAndJoin<Rest, Separator>}` : \"\"}`\n    : \"<error-joining-tuple-elements>\";\ntype _TypeToStringInner<T> =\n  IsAny<T> extends true ? \"any\"\n  : IsNever<T> extends true ? \"never\"\n  : IsUnion<T> extends true ? _ToStringAndJoin<UnionToTuple<T>, \" | \">\n  : [T] extends [number] ? (number extends T ? \"number\" : `${T}`)\n  : [T] extends [boolean] ? `${T}`\n  : [T] extends [undefined] ? \"undefined\"\n  : [T] extends [null] ? \"null\"\n  : [T] extends [string] ? (string extends T ? \"string\" : `'${T}'`)\n  : [T] extends [[]] ? \"[]\"\n  : [T] extends [[any, ...any[]]] ? `[${_ToStringAndJoin<T, \", \">}]`\n  : [T] extends [(infer E)[]] ? `${TypeToString<E>}[]`\n  : [T] extends [Function] ? \"function\"\n  : [T] extends [symbol] ? `symbol(${T['description']})`\n  : [T] extends [object] ? `{ ${Join<UnionToTuple<{ [K in keyof T]: `${TypeToString<K>}: ${TypeToString<T[K]>}` }[keyof T]>, \", \">} }`\n  : \"<unknown-type>\"\nexport type TypeToString<T> = _TypeToStringInner<T> extends `${infer S}` ? S : never;\n\n/**\n * Can be used to create assertions on types. For example, if passed any T other than `true`, the following will\n * show a type error:\n *\n * ```ts\n * typeAssert<T>()();  // the second pair of braces is important!\n * ```\n */\nexport function typeAssert<T>(): (\n  IsAny<T> extends true ? TypeAssertionError<`Type assertion failed. Expected true, but got any.`>\n    : IsNever<T> extends true ? TypeAssertionError<`Type assertion failed. Expected true, but got never.`>\n    : T extends true ? (() => undefined)\n    : TypeAssertionError<`Type assertion failed. Expected true, but got: ${TypeToString<T>}`>\n) {\n  return (() => undefined) as any;\n}\ntype TypeAssertionError<T> =\n  & [T]\n  & /* this promise makes sure that if we accidentally forget the second pair of braces, eslint will complain (if we have no-floating-promises enabled) */ Promise<any>;\n\n\ntypeAssertExtends<ReturnType<typeof typeAssert<true>>, () => undefined>()();\ntypeAssertExtends<ReturnType<typeof typeAssert<false>>, TypeAssertionError<`Type assertion failed. Expected true, but got: false`>>()();\ntypeAssertExtends<ReturnType<typeof typeAssert<never>>, TypeAssertionError<`Type assertion failed. Expected true, but got never.`>>()();\ntypeAssertExtends<ReturnType<typeof typeAssert<any>>, TypeAssertionError<`Type assertion failed. Expected true, but got any.`>>()();\n\n/**\n * Functionally equivalent to `typeAssert<T extends S ? true : false>()()`, but with better error messages.\n */\nexport function typeAssertExtends<T, S>(): (\n  [T] extends [S] ? (() => undefined) : TypeAssertionError<`Type assertion failed. Expected ${TypeToString<T>} to extend ${TypeToString<S>}`>\n) {\n  return (() => undefined) as any;\n}\n\ntypeAssertExtends<ReturnType<typeof typeAssertExtends<never, true>>, () => undefined>()();\ntypeAssertExtends<ReturnType<typeof typeAssertExtends<any, true>>, () => undefined>()();\ntypeAssertExtends<ReturnType<typeof typeAssertExtends<false, false>>, () => undefined>()();\ntypeAssertExtends<ReturnType<typeof typeAssertExtends<\"abc\", string>>, () => undefined>()();\ntypeAssertExtends<ReturnType<typeof typeAssertExtends<{a: 1, b: 123}, {a: number}>>, () => undefined>()();\ntypeAssertExtends<ReturnType<typeof typeAssertExtends<never, never>>, () => undefined>()();\ntypeAssertExtends<ReturnType<typeof typeAssertExtends<true, any>>, () => undefined>()();\n\ntypeAssertExtends<ReturnType<typeof typeAssertExtends<{a: number}, {a: 1}>>, [\"Type assertion failed. Expected { 'a': number } to extend { 'a': 1 }\"]>()();\ntypeAssertExtends<ReturnType<typeof typeAssertExtends<any, never>>, [\"Type assertion failed. Expected any to extend never\"]>()();\ntypeAssertExtends<ReturnType<typeof typeAssertExtends<false, true>>, [\"Type assertion failed. Expected false to extend true\"]>()();\ntypeAssertExtends<ReturnType<typeof typeAssertExtends<false, never>>, [\"Type assertion failed. Expected false to extend never\"]>()();\n\n\nexport function typeAssertIs<T, U>(): (\n  IsAny<T> extends true ? (IsAny<U> extends true ? (() => undefined) : TypeAssertionError<`Type assertion failed. Expected ${TypeToString<T>} to be ${TypeToString<U>}`>)\n    : IsAny<U> extends true ? TypeAssertionError<`Type assertion failed. Expected ${TypeToString<T>} to be ${TypeToString<U>}`>\n    : [T] extends [U] ? ([U] extends [T] ? (() => undefined) : TypeAssertionError<`Type assertion failed. Expected ${TypeToString<T>} to be ${TypeToString<U>}`>)\n    : TypeAssertionError<`Type assertion failed. Expected ${TypeToString<T>} to be ${TypeToString<U>}`>\n) {\n  return (() => undefined) as any;\n}\n\ntypeAssertExtends<ReturnType<typeof typeAssertIs<\"123\", \"123\">>, () => undefined>()();\ntypeAssertExtends<ReturnType<typeof typeAssertIs<{a: 1}, {a: 1}>>, () => undefined>()();\ntypeAssertExtends<ReturnType<typeof typeAssertIs<DeepPartial<{a: 1}>, {a?: 1}>>, () => undefined>()();\ntypeAssertExtends<ReturnType<typeof typeAssertIs<any, any>>, () => undefined>()();\ntypeAssertExtends<ReturnType<typeof typeAssertIs<never, never>>, () => undefined>()();\ntypeAssertExtends<ReturnType<typeof typeAssertIs<1, any>>, [\"Type assertion failed. Expected 1 to be any\"]>()();\ntypeAssertExtends<ReturnType<typeof typeAssertIs<any, 1>>, [\"Type assertion failed. Expected any to be 1\"]>()();\ntypeAssertExtends<ReturnType<typeof typeAssertIs<false, true>>, [\"Type assertion failed. Expected false to be true\"]>()();\ntypeAssertExtends<ReturnType<typeof typeAssertIs<{a: number}, {a: 1}>>, [\"Type assertion failed. Expected { 'a': number } to be { 'a': 1 }\"]>()();\ntypeAssertExtends<ReturnType<typeof typeAssertIs<any, never>>, [\"Type assertion failed. Expected any to be never\"]>()();\ntypeAssertExtends<ReturnType<typeof typeAssertIs<false, true>>, [\"Type assertion failed. Expected false to be true\"]>()();\ntypeAssertExtends<ReturnType<typeof typeAssertIs<false, never>>, [\"Type assertion failed. Expected false to be never\"]>()();\n"],"names":[],"mappings":";;;;;;;;;AAkDA,aAA6F,EAAE;AAC/F,aAA0F,EAAE;AAuB5F,aAAqE,EAAE;AAwEhE,SAAS,aAKd;IACA,OAAQ,IAAM,KAAA;AAChB;AAMA,kBAAwE,EAAE;AAC1E,kBAAoI,EAAE;AACtI,kBAAoI,EAAE;AACtI,kBAAgI,EAAE;AAK3H,SAAS,oBAEd;IACA,OAAQ,IAAM,KAAA;AAChB;AAEA,kBAAsF,EAAE;AACxF,kBAAoF,EAAE;AACtF,kBAAuF,EAAE;AACzF,kBAAwF,EAAE;AAC1F,kBAAsG,EAAE;AACxG,kBAAuF,EAAE;AACzF,kBAAoF,EAAE;AAEtF,kBAAuJ,EAAE;AACzJ,kBAA6H,EAAE;AAC/H,kBAA+H,EAAE;AACjI,kBAAiI,EAAE;AAG5H,SAAS,eAKd;IACA,OAAQ,IAAM,KAAA;AAChB;AAEA,kBAAkF,EAAE;AACpF,kBAAoF,EAAE;AACtF,kBAAkG,EAAE;AACpG,kBAA8E,EAAE;AAChF,kBAAkF,EAAE;AACpF,kBAA4G,EAAE;AAC9G,kBAA4G,EAAE;AAC9G,kBAAsH,EAAE;AACxH,kBAA8I,EAAE;AAChJ,kBAAoH,EAAE;AACtH,kBAAsH,EAAE;AACxH,kBAAwH,EAAE"}},
    {"offset": {"line": 675, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack-shared/src/utils/objects.tsx"],"sourcesContent":["import { StackAssertionError } from \"./errors\";\nimport { identity } from \"./functions\";\nimport { stringCompare } from \"./strings\";\nimport { typeAssertIs } from \"./types\";\n\nexport function isNotNull<T>(value: T): value is NonNullable<T> {\n  return value !== null && value !== undefined;\n}\nundefined?.test(\"isNotNull\", ({ expect }) => {\n  expect(isNotNull(null)).toBe(false);\n  expect(isNotNull(undefined)).toBe(false);\n  expect(isNotNull(0)).toBe(true);\n  expect(isNotNull(\"\")).toBe(true);\n  expect(isNotNull(false)).toBe(true);\n  expect(isNotNull({})).toBe(true);\n  expect(isNotNull([])).toBe(true);\n});\n\nexport type DeepPartial<T> = T extends object ? (T extends any[] ? { [P in keyof T]: DeepPartial<T[P]> } : { [P in keyof T]?: DeepPartial<T[P]> }) : T;\nexport type DeepRequired<T> = T extends object ? { [P in keyof T]-?: DeepRequired<T[P]> } : T;\nexport type DeepRequiredOrUndefined<T> = T extends object ? { [P in keyof { [K in keyof T]-?: K}]: DeepRequiredOrUndefined<T[P]> } : T;\n\n\n/**\n * Assumes both objects are primitives, arrays, or non-function plain objects, and compares them deeply.\n *\n * Note that since they are assumed to be plain objects, this function does not compare prototypes.\n */\nexport function deepPlainEquals<T>(obj1: T, obj2: unknown, options: { ignoreUndefinedValues?: boolean } = {}): obj2 is T {\n  if (typeof obj1 !== typeof obj2) return false;\n  if (obj1 === obj2) return true;\n\n  switch (typeof obj1) {\n    case 'object': {\n      if (!obj1 || !obj2) return false;\n\n      if (Array.isArray(obj1) || Array.isArray(obj2)) {\n        if (!Array.isArray(obj1) || !Array.isArray(obj2)) return false;\n        if (obj1.length !== obj2.length) return false;\n        return obj1.every((v, i) => deepPlainEquals(v, obj2[i], options));\n      }\n\n      const entries1 = Object.entries(obj1).filter(([k, v]) => !options.ignoreUndefinedValues || v !== undefined);\n      const entries2 = Object.entries(obj2).filter(([k, v]) => !options.ignoreUndefinedValues || v !== undefined);\n      if (entries1.length !== entries2.length) return false;\n      return entries1.every(([k, v1]) => {\n        const e2 = entries2.find(([k2]) => k === k2);\n        if (!e2) return false;\n        return deepPlainEquals(v1, e2[1], options);\n      });\n    }\n    case 'undefined':\n    case 'string':\n    case 'number':\n    case 'boolean':\n    case 'bigint':\n    case 'symbol':\n    case 'function':{\n      return false;\n    }\n    default: {\n      throw new Error(\"Unexpected typeof \" + typeof obj1);\n    }\n  }\n}\nundefined?.test(\"deepPlainEquals\", ({ expect }) => {\n  // Simple values\n  expect(deepPlainEquals(1, 1)).toBe(true);\n  expect(deepPlainEquals(\"test\", \"test\")).toBe(true);\n  expect(deepPlainEquals(1, 2)).toBe(false);\n  expect(deepPlainEquals(\"test\", \"other\")).toBe(false);\n\n  // Arrays\n  expect(deepPlainEquals([1, 2, 3], [1, 2, 3])).toBe(true);\n  expect(deepPlainEquals([1, 2, 3], [1, 2, 4])).toBe(false);\n  expect(deepPlainEquals([1, 2, 3], [1, 2])).toBe(false);\n\n  // Objects\n  expect(deepPlainEquals({ a: 1, b: 2 }, { a: 1, b: 2 })).toBe(true);\n  expect(deepPlainEquals({ a: 1, b: 2 }, { a: 1, b: 3 })).toBe(false);\n  expect(deepPlainEquals({ a: 1, b: 2 }, { a: 1 })).toBe(false);\n\n  // Nested structures\n  expect(deepPlainEquals({ a: 1, b: [1, 2, { c: 3 }] }, { a: 1, b: [1, 2, { c: 3 }] })).toBe(true);\n  expect(deepPlainEquals({ a: 1, b: [1, 2, { c: 3 }] }, { a: 1, b: [1, 2, { c: 4 }] })).toBe(false);\n\n  // With options\n  expect(deepPlainEquals({ a: 1, b: undefined }, { a: 1 }, { ignoreUndefinedValues: true })).toBe(true);\n  expect(deepPlainEquals({ a: 1, b: undefined }, { a: 1 })).toBe(false);\n});\n\nexport function isCloneable<T>(obj: T): obj is Exclude<T, symbol | Function> {\n  return typeof obj !== 'symbol' && typeof obj !== 'function';\n}\n\nexport function shallowClone<T extends object>(obj: T): T {\n  if (!isCloneable(obj)) throw new StackAssertionError(\"shallowClone does not support symbols or functions\", { obj });\n\n  if (Array.isArray(obj)) return obj.map(identity) as T;\n  return { ...obj };\n}\nundefined?.test(\"shallowClone\", ({ expect }) => {\n  expect(shallowClone({ a: 1, b: 2 })).toEqual({ a: 1, b: 2 });\n  expect(shallowClone([1, 2, 3])).toEqual([1, 2, 3]);\n  expect(() => shallowClone(() => {})).toThrow();\n});\n\nexport function deepPlainClone<T>(obj: T): T {\n  if (typeof obj === 'function') throw new StackAssertionError(\"deepPlainClone does not support functions\");\n  if (typeof obj === 'symbol') throw new StackAssertionError(\"deepPlainClone does not support symbols\");\n  if (typeof obj !== 'object' || !obj) return obj;\n  if (Array.isArray(obj)) return obj.map(deepPlainClone) as any;\n  return Object.fromEntries(Object.entries(obj).map(([k, v]) => [k, deepPlainClone(v)])) as any;\n}\nundefined?.test(\"deepPlainClone\", ({ expect }) => {\n  // Primitive values\n  expect(deepPlainClone(1)).toBe(1);\n  expect(deepPlainClone(\"test\")).toBe(\"test\");\n  expect(deepPlainClone(null)).toBe(null);\n  expect(deepPlainClone(undefined)).toBe(undefined);\n\n  // Arrays\n  const arr = [1, 2, 3];\n  const clonedArr = deepPlainClone(arr);\n  expect(clonedArr).toEqual(arr);\n  expect(clonedArr).not.toBe(arr); // Different reference\n\n  // Objects\n  const obj = { a: 1, b: 2 };\n  const clonedObj = deepPlainClone(obj);\n  expect(clonedObj).toEqual(obj);\n  expect(clonedObj).not.toBe(obj); // Different reference\n\n  // Nested structures\n  const nested = { a: 1, b: [1, 2, { c: 3 }] };\n  const clonedNested = deepPlainClone(nested);\n  expect(clonedNested).toEqual(nested);\n  expect(clonedNested).not.toBe(nested); // Different reference\n  expect(clonedNested.b).not.toBe(nested.b); // Different reference for nested array\n  expect(clonedNested.b[2]).not.toBe(nested.b[2]); // Different reference for nested object\n\n  // Error cases\n  expect(() => deepPlainClone(() => {})).toThrow();\n  expect(() => deepPlainClone(Symbol())).toThrow();\n});\n\nexport type DeepMerge<T, U> = U extends any ? DeepMergeNonDistributive<T, U> : never;  // distributive conditional type https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types\ntype DeepMergeNonDistributive<T, U> = Omit<T, keyof U> & Omit<U, keyof T> & DeepMergeInner<Pick<T, keyof U & keyof T>, Pick<U, keyof U & keyof T>>;\ntype DeepMergeInner<T, U> = {\n  [K in { [Ki in keyof U]-?: Ki }[keyof U]]:  // we use this weird construct instead of just `keyof U` because TypeScript automatically removes the `undefined` key when using `-?` as a modifier; this is a workaround to make TypeScript not recognize the -? and for us to get the `undefined` key back\n    undefined extends U[K]\n      ? K extends keyof T\n          ? T[K] extends object\n              ? Exclude<U[K], undefined> extends object\n                  ? DeepMerge<T[K], Exclude<U[K], undefined>>\n                  : T[K] | Exclude<U[K], undefined>\n              : T[K] | Exclude<U[K], undefined>\n          : Exclude<U[K], undefined>\n      : K extends keyof T\n          ? T[K] extends object\n              ? U[K] extends object\n                  ? DeepMerge<T[K], U[K]>\n                  : U[K]\n              : U[K]\n          : U[K];\n};\nexport function deepMerge<T extends {}, U extends {}>(baseObj: T, mergeObj: U): DeepMerge<T, U> {\n  if ([baseObj, mergeObj, ...Object.values(baseObj), ...Object.values(mergeObj)].some(o => !isCloneable(o))) throw new StackAssertionError(\"deepMerge does not support functions or symbols\", { baseObj, mergeObj });\n\n  const res: any = shallowClone(baseObj);\n  for (const [key, mergeValue] of Object.entries(mergeObj)) {\n    if (has(res, key as any)) {\n      const baseValue = get(res, key as any);\n      if (isObjectLike(baseValue) && isObjectLike(mergeValue)) {\n        set(res, key, deepMerge(baseValue, mergeValue));\n        continue;\n      }\n    }\n    set(res, key, mergeValue);\n  }\n  return res as any;\n}\nundefined?.test(\"deepMerge\", ({ expect }) => {\n  // Test merging flat objects\n  expect(deepMerge({ a: 1 }, { b: 2 })).toEqual({ a: 1, b: 2 });\n  expect(deepMerge({ a: 1 }, { a: 2 })).toEqual({ a: 2 });\n  expect(deepMerge({ a: 1, b: 2 }, { b: 3, c: 4 })).toEqual({ a: 1, b: 3, c: 4 });\n\n  // Test with nested objects\n  expect(deepMerge(\n    { a: { x: 1, y: 2 }, b: 3 },\n    { a: { y: 3, z: 4 }, c: 5 }\n  )).toEqual({ a: { x: 1, y: 3, z: 4 }, b: 3, c: 5 });\n\n  // Test with arrays\n  expect(deepMerge(\n    { a: [1, 2], b: 3 },\n    { a: [3, 4], c: 5 }\n  )).toEqual({ a: [3, 4], b: 3, c: 5 });\n\n  // Test with null values\n  expect(deepMerge(\n    { a: { x: 1 }, b: null },\n    { a: { y: 2 }, b: { z: 3 } }\n  )).toEqual({ a: { x: 1, y: 2 }, b: { z: 3 } });\n\n  // Test with undefined values\n  expect(deepMerge(\n    { a: 1, b: undefined },\n    { b: 2, c: 3 }\n  )).toEqual({ a: 1, b: 2, c: 3 });\n\n  // Test deeply nested structures\n  expect(deepMerge(\n    {\n      a: {\n        x: { deep: 1 },\n        y: [1, 2]\n      },\n      b: 2\n    },\n    {\n      a: {\n        x: { deeper: 3 },\n        y: [3, 4]\n      },\n      c: 3\n    }\n  )).toEqual({\n    a: {\n      x: { deep: 1, deeper: 3 },\n      y: [3, 4]\n    },\n    b: 2,\n    c: 3\n  });\n\n  // Test with empty objects\n  expect(deepMerge({}, { a: 1 })).toEqual({ a: 1 });\n  expect(deepMerge({ a: 1 }, {})).toEqual({ a: 1 });\n  expect(deepMerge({}, {})).toEqual({});\n\n  // Test that original objects are not modified\n  const base = { a: { x: 1 }, b: 2 };\n  const merge = { a: { y: 2 }, c: 3 };\n  const baseClone = deepPlainClone(base);\n  const mergeClone = deepPlainClone(merge);\n\n  const result = deepMerge(base, merge);\n  expect(base).toEqual(baseClone);\n  expect(merge).toEqual(mergeClone);\n  expect(result).toEqual({ a: { x: 1, y: 2 }, b: 2, c: 3 });\n\n  // Test error cases\n  expect(() => deepMerge({ a: () => {} }, { b: 2 })).toThrow();\n  expect(() => deepMerge({ a: 1 }, { b: () => {} })).toThrow();\n  expect(() => deepMerge({ a: Symbol() }, { b: 2 })).toThrow();\n  expect(() => deepMerge({ a: 1 }, { b: Symbol() })).toThrow();\n});\n\nexport type DeepOmit<T, U> = T extends object ? { [K in keyof T]: K extends keyof U ? (T[K] extends U[K] ? undefined : T[K]) : T[K] } : (T extends U ? undefined : T);\n\nexport function typedEntries<T extends {}>(obj: T): [Exclude<keyof T, number>, T[keyof T]][] {\n  return Object.entries(obj) as any;\n}\nundefined?.test(\"typedEntries\", ({ expect }) => {\n  expect(typedEntries({})).toEqual([]);\n  expect(typedEntries({ a: 1, b: 2 })).toEqual([[\"a\", 1], [\"b\", 2]]);\n  expect(typedEntries({ a: \"hello\", b: true, c: null })).toEqual([[\"a\", \"hello\"], [\"b\", true], [\"c\", null]]);\n\n  // Test with object containing methods\n  const objWithMethod = { a: 1, b: () => \"test\" };\n  const entries = typedEntries(objWithMethod);\n  expect(entries.length).toBe(2);\n  expect(entries[0][0]).toBe(\"a\");\n  expect(entries[0][1]).toBe(1);\n  expect(entries[1][0]).toBe(\"b\");\n  expect(typeof entries[1][1]).toBe(\"function\");\n});\n\nexport function typedFromEntries<K extends PropertyKey, V>(entries: (readonly [K, V])[]): Record<K, V> {\n  return Object.fromEntries(entries) as any;\n}\nundefined?.test(\"typedFromEntries\", ({ expect }) => {\n  expect(typedFromEntries([])).toEqual({});\n  expect(typedFromEntries([[\"a\", 1], [\"b\", 2]])).toEqual({ a: 1, b: 2 });\n\n  // Test with mixed types (using type assertion)\n  const mixedEntries = [[\"a\", \"hello\"], [\"b\", true], [\"c\", null]] as [string, string | boolean | null][];\n  const mixedObj = typedFromEntries(mixedEntries);\n  expect(mixedObj).toEqual({ a: \"hello\", b: true, c: null });\n\n  // Test with function values\n  const fn = () => \"test\";\n  type MixedValue = number | (() => string);\n  const fnEntries: [string, MixedValue][] = [[\"a\", 1], [\"b\", fn]];\n  const obj = typedFromEntries(fnEntries);\n  expect(obj.a).toBe(1);\n  expect(typeof obj.b).toBe(\"function\");\n  // Type assertion needed for the function call\n  expect((obj.b as () => string)()).toBe(\"test\");\n});\n\nexport function typedKeys<T extends {}>(obj: T): (Exclude<keyof T, number>)[] {\n  return Object.keys(obj) as any;\n}\nundefined?.test(\"typedKeys\", ({ expect }) => {\n  expect(typedKeys({})).toEqual([]);\n  expect(typedKeys({ a: 1, b: 2 })).toEqual([\"a\", \"b\"]);\n  expect(typedKeys({ a: \"hello\", b: true, c: null })).toEqual([\"a\", \"b\", \"c\"]);\n\n  // Test with object containing methods\n  const objWithMethod = { a: 1, b: () => \"test\" };\n  expect(typedKeys(objWithMethod)).toEqual([\"a\", \"b\"]);\n});\n\nexport function typedValues<T extends {}>(obj: T): T[keyof T][] {\n  return Object.values(obj) as any;\n}\nundefined?.test(\"typedValues\", ({ expect }) => {\n  expect(typedValues({})).toEqual([]);\n  expect(typedValues({ a: 1, b: 2 })).toEqual([1, 2]);\n\n  // Test with mixed types\n  type MixedObj = { a: string, b: boolean, c: null };\n  const mixedObj: MixedObj = { a: \"hello\", b: true, c: null };\n  expect(typedValues(mixedObj)).toEqual([\"hello\", true, null]);\n\n  // Test with object containing methods\n  type ObjWithFn = { a: number, b: () => string };\n  const fn = () => \"test\";\n  const objWithMethod: ObjWithFn = { a: 1, b: fn };\n  const values = typedValues(objWithMethod);\n  expect(values.length).toBe(2);\n  expect(values[0]).toBe(1);\n  expect(typeof values[1]).toBe(\"function\");\n  // Need to cast to the correct type\n  const fnValue = values[1] as () => string;\n  expect(fnValue()).toBe(\"test\");\n});\n\nexport function typedAssign<T extends {}, U extends {}>(target: T, source: U): T & U {\n  return Object.assign(target, source);\n}\nundefined?.test(\"typedAssign\", ({ expect }) => {\n  // Test with empty objects\n  const emptyTarget = {};\n  const emptyResult = typedAssign(emptyTarget, { a: 1 });\n  expect(emptyResult).toEqual({ a: 1 });\n  expect(emptyResult).toBe(emptyTarget); // Same reference\n\n  // Test with non-empty target\n  const target = { a: 1, b: 2 };\n  const result = typedAssign(target, { c: 3, d: 4 });\n  expect(result).toEqual({ a: 1, b: 2, c: 3, d: 4 });\n  expect(result).toBe(target); // Same reference\n\n  // Test with overlapping properties\n  const targetWithOverlap = { a: 1, b: 2 };\n  const resultWithOverlap = typedAssign(targetWithOverlap, { b: 3, c: 4 });\n  expect(resultWithOverlap).toEqual({ a: 1, b: 3, c: 4 });\n  expect(resultWithOverlap).toBe(targetWithOverlap); // Same reference\n});\n\nexport type FilterUndefined<T> =\n  & { [k in keyof T as (undefined extends T[k] ? (T[k] extends undefined | void ? never : k) : never)]+?: T[k] & ({} | null) }\n  & { [k in keyof T as (undefined extends T[k] ? never : k)]: T[k] & ({} | null) }\n\n/**\n * Returns a new object with all undefined values removed. Useful when spreading optional parameters on an object, as\n * TypeScript's `Partial<XYZ>` type allows `undefined` values.\n */\nexport function filterUndefined<T extends object>(obj: T): FilterUndefined<T> {\n  return Object.fromEntries(Object.entries(obj).filter(([, v]) => v !== undefined)) as any;\n}\nundefined?.test(\"filterUndefined\", ({ expect }) => {\n  expect(filterUndefined({})).toEqual({});\n  expect(filterUndefined({ a: 1, b: 2 })).toEqual({ a: 1, b: 2 });\n  expect(filterUndefined({ a: 1, b: undefined })).toEqual({ a: 1 });\n  expect(filterUndefined({ a: undefined, b: undefined })).toEqual({});\n  expect(filterUndefined({ a: null, b: undefined })).toEqual({ a: null });\n  expect(filterUndefined({ a: 0, b: \"\", c: false, d: undefined })).toEqual({ a: 0, b: \"\", c: false });\n});\n\nexport type FilterUndefinedOrNull<T> = FilterUndefined<{ [k in keyof T]: null extends T[k] ? NonNullable<T[k]> | undefined : T[k] }>;\n\n/**\n * Returns a new object with all undefined and null values removed. Useful when spreading optional parameters on an object, as\n * TypeScript's `Partial<XYZ>` type allows `undefined` values.\n */\nexport function filterUndefinedOrNull<T extends object>(obj: T): FilterUndefinedOrNull<T> {\n  return Object.fromEntries(Object.entries(obj).filter(([, v]) => v !== undefined && v !== null)) as any;\n}\nundefined?.test(\"filterUndefinedOrNull\", ({ expect }) => {\n  expect(filterUndefinedOrNull({})).toEqual({});\n  expect(filterUndefinedOrNull({ a: 1, b: 2 })).toEqual({ a: 1, b: 2 });\n});\n\nexport type DeepFilterUndefined<T> = T extends object ? FilterUndefined<{ [K in keyof T]: DeepFilterUndefined<T[K]> }> : T;\ntypeAssertIs<DeepFilterUndefined<{ a: { b: { c?: undefined, d?: 123 } } }>, { a: { b: { d?: 123 } } }>()();\n\nexport function deepFilterUndefined<T extends object>(obj: T): DeepFilterUndefined<T> {\n  return Object.fromEntries(Object.entries(obj).filter(([, v]) => v !== undefined).map(([k, v]) => [k, isObjectLike(v) ? deepFilterUndefined(v) : v])) as any;\n}\nundefined?.test(\"deepFilterUndefined\", ({ expect }) => {\n  expect(deepFilterUndefined({ a: 1, b: undefined })).toEqual({ a: 1 });\n});\n\nexport function pick<T extends {}, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {\n  return Object.fromEntries(Object.entries(obj).filter(([k]) => keys.includes(k as K))) as any;\n}\nundefined?.test(\"pick\", ({ expect }) => {\n  const obj = { a: 1, b: 2, c: 3, d: 4 };\n  expect(pick(obj, [\"a\", \"c\"])).toEqual({ a: 1, c: 3 });\n  expect(pick(obj, [])).toEqual({});\n  expect(pick(obj, [\"a\", \"e\" as keyof typeof obj])).toEqual({ a: 1 });\n  // Use type assertion for empty object to avoid TypeScript error\n  expect(pick({} as Record<string, unknown>, [\"a\"])).toEqual({});\n});\n\nexport function omit<T extends {}, K extends keyof T>(obj: T, keys: K[]): Omit<T, K> {\n  if (!Array.isArray(keys)) throw new StackAssertionError(\"omit: keys must be an array\", { obj, keys });\n  return Object.fromEntries(Object.entries(obj).filter(([k]) => !keys.includes(k as K))) as any;\n}\nundefined?.test(\"omit\", ({ expect }) => {\n  const obj = { a: 1, b: 2, c: 3, d: 4 };\n  expect(omit(obj, [\"a\", \"c\"])).toEqual({ b: 2, d: 4 });\n  expect(omit(obj, [])).toEqual(obj);\n  expect(omit(obj, [\"a\", \"e\" as keyof typeof obj])).toEqual({ b: 2, c: 3, d: 4 });\n  // Use type assertion for empty object to avoid TypeScript error\n  expect(omit({} as Record<string, unknown>, [\"a\"])).toEqual({});\n});\n\nexport function split<T extends {}, K extends keyof T>(obj: T, keys: K[]): [Pick<T, K>, Omit<T, K>] {\n  return [pick(obj, keys), omit(obj, keys)];\n}\nundefined?.test(\"split\", ({ expect }) => {\n  const obj = { a: 1, b: 2, c: 3, d: 4 };\n  expect(split(obj, [\"a\", \"c\"])).toEqual([{ a: 1, c: 3 }, { b: 2, d: 4 }]);\n  expect(split(obj, [])).toEqual([{}, obj]);\n  expect(split(obj, [\"a\", \"e\" as keyof typeof obj])).toEqual([{ a: 1 }, { b: 2, c: 3, d: 4 }]);\n  // Use type assertion for empty object to avoid TypeScript error\n  expect(split({} as Record<string, unknown>, [\"a\"])).toEqual([{}, {}]);\n});\n\nexport function mapValues<T extends object, U>(obj: T, fn: (value: T extends (infer E)[] ? E : T[keyof T]) => U): Record<keyof T, U> {\n  if (Array.isArray(obj)) {\n    return obj.map(v => fn(v)) as any;\n  }\n  return Object.fromEntries(Object.entries(obj).map(([k, v]) => [k, fn(v)])) as any;\n}\nundefined?.test(\"mapValues\", ({ expect }) => {\n  expect(mapValues({ a: 1, b: 2 }, v => v * 2)).toEqual({ a: 2, b: 4 });\n  expect(mapValues([1, 2, 3], v => v * 2)).toEqual([2, 4, 6]);\n});\n\nexport function sortKeys<T extends object>(obj: T): T {\n  if (Array.isArray(obj)) {\n    return [...obj] as any;\n  }\n  return Object.fromEntries(Object.entries(obj).sort(([a], [b]) => stringCompare(a, b))) as any;\n}\nundefined?.test(\"sortKeys\", ({ expect }) => {\n  const obj = {\n    \"1\": 0,\n    \"10\": 1,\n    b: 2,\n    \"2\": 3,\n    a: 4,\n    \"-3.33\": 5,\n    \"-4\": 6,\n    \"-3\": 7,\n    abc: 8,\n    \"a-b\": 9,\n    ab: 10,\n    ac: 11,\n    aa: 12,\n    aab: 13,\n  };\n  expect(Object.entries(sortKeys(obj))).toEqual([\n    [\"1\", 0],\n    [\"2\", 3],\n    [\"10\", 1],\n    [\"-3\", 7],\n    [\"-3.33\", 5],\n    [\"-4\", 6],\n    [\"a\", 4],\n    [\"a-b\", 9],\n    [\"aa\", 12],\n    [\"aab\", 13],\n    [\"ab\", 10],\n    [\"abc\", 8],\n    [\"ac\", 11],\n    [\"b\", 2],\n  ]);\n});\n\nexport function deepSortKeys<T extends object>(obj: T): T {\n  return sortKeys(mapValues(obj, v => isObjectLike(v) ? deepSortKeys(v) : v)) as any;\n}\nundefined?.test(\"deepSortKeys\", ({ expect }) => {\n  const obj = {\n    h: { i: { k: 9, j: 8 }, l: 10 },\n    b: { d: 3, c: 2 },\n    a: 1,\n    e: [4, 5, { g: 7, f: 6 }],\n  };\n  const sorted = deepSortKeys(obj);\n  expect(Object.entries(sorted)).toEqual([\n    [\"a\", 1],\n    [\"b\", { c: 2, d: 3 }],\n    [\"e\", [4, 5, { f: 6, g: 7 }]],\n    [\"h\", { i: { j: 8, k: 9 }, l: 10 }],\n  ]);\n  expect(Object.entries(sorted.b)).toEqual([\n    [\"c\", 2],\n    [\"d\", 3],\n  ]);\n  expect(Object.entries(sorted.e[2])).toEqual([\n    [\"f\", 6],\n    [\"g\", 7],\n  ]);\n  expect(Object.entries(sorted.h)).toEqual([\n    [\"i\", { j: 8, k: 9 }],\n    [\"l\", 10],\n  ]);\n  expect(Object.entries(sorted.h.i)).toEqual([\n    [\"j\", 8],\n    [\"k\", 9],\n  ]);\n});\n\nexport function set<T extends object, K extends keyof T>(obj: T, key: K, value: T[K]) {\n  if (!isObjectLike(obj)) throw new StackAssertionError(`set: obj is not an object (found: ${(obj as any) === null ? \"null\" : typeof obj})`, { obj, key, value });\n  Object.defineProperty(obj, key, { value, writable: true, configurable: true, enumerable: true });\n}\n\nexport function get<T extends object, K extends keyof T>(obj: T, key: K): T[K] {\n  if ((obj as any) == null) throw new StackAssertionError(\"get: obj is null or undefined\", { obj, key });\n  const descriptor = Object.getOwnPropertyDescriptor(obj, key);\n  if (!descriptor) throw new StackAssertionError(`get: key ${String(key)} does not exist`, { obj, key });\n  return descriptor.value;\n}\n\nexport function getOrUndefined<T extends object, K extends keyof T>(obj: T, key: K): T[K] | undefined {\n  if ((obj as any) == null) throw new StackAssertionError(\"getOrUndefined: obj is null or undefined\", { obj, key });\n  return has(obj, key) ? get(obj, key) : undefined;\n}\n\nexport function has<T extends object, K extends keyof T>(obj: T, key: K): obj is T & { [k in K]: unknown } {\n  if ((obj as any) == null) throw new StackAssertionError(\"has: obj is null or undefined\", { obj, key });\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nundefined?.test(\"has\", ({ expect }) => {\n  const obj = { a: 1, b: undefined, c: null };\n  expect(has(obj, \"a\")).toBe(true);\n  expect(has(obj, \"b\")).toBe(true);\n  expect(has(obj, \"c\")).toBe(true);\n  expect(has(obj, \"d\" as keyof typeof obj)).toBe(false);\n});\n\n\nexport function hasAndNotUndefined<T extends object, K extends keyof T>(obj: T, key: K): obj is T & { [k in K]: Exclude<T[K], undefined> } {\n  return has(obj, key) && get(obj, key) !== undefined;\n}\n\nexport function deleteKey<T extends object, K extends keyof T>(obj: T, key: K) {\n  if (has(obj, key)) {\n    Reflect.deleteProperty(obj, key);\n  } else {\n    throw new StackAssertionError(`deleteKey: key ${String(key)} does not exist`, { obj, key });\n  }\n}\n\n/**\n * Returns true iff the value is an object or a function, but not null.\n */\nexport function isObjectLike(value: unknown): value is object | Function {\n  return (typeof value === 'object' || typeof value === 'function') && value !== null;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 950, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack-shared/src/utils/errors.tsx"],"sourcesContent":["import { globalVar } from \"./globals\";\nimport { Json } from \"./json\";\nimport { pick } from \"./objects\";\nimport { nicify } from \"./strings\";\n\n\nexport function throwErr(errorMessage: string, extraData?: any): never;\nexport function throwErr(error: Error): never;\nexport function throwErr(...args: StatusErrorConstructorParameters): never;\nexport function throwErr(...args: any[]): never {\n  if (typeof args[0] === \"string\") {\n    throw new StackAssertionError(args[0], args[1]);\n  } else if (args[0] instanceof Error) {\n    throw args[0];\n  } else {\n    // @ts-expect-error\n    throw new StatusError(...args);\n  }\n}\n\nfunction removeStacktraceNameLine(stack: string): string {\n  // some browsers (eg. Chrome) prepend the stack with an extra line with the error name\n  const addsNameLine = new Error().stack?.startsWith(\"Error\\n\");\n  return stack.split(\"\\n\").slice(addsNameLine ? 1 : 0).join(\"\\n\");\n}\n\n\n/**\n * Concatenates the (original) stacktraces of the given errors onto the first.\n *\n * Note: Very often, the concatStacktracesIfRejected function in promises.tsx is an easier way to use this function.\n *\n * Useful when you invoke an async function to receive a promise without awaiting it immediately. Browsers are smart\n * enough to keep track of the call stack in async function calls when you invoke `.then` within the same async tick,\n * but if you don't, the stacktrace will be lost.\n *\n * Here's an example of the unwanted behavior:\n *\n * ```tsx\n * async function log() {\n *   await wait(0);  // put the task on the event loop\n *   console.log(new Error().stack);\n * }\n *\n * async function main() {\n *   await log();  // good; prints both \"log\" and \"main\" on the stacktrace\n *   log();  // bad; prints only \"log\" on the stacktrace\n * }\n * ```\n */\nexport function concatStacktraces(first: Error, ...errors: Error[]): void {\n  // some browsers (eg. Firefox) add an extra empty line at the end\n  const addsEmptyLineAtEnd = first.stack?.endsWith(\"\\n\");\n\n\n  // Add a reference to this function itself so that we know that stacktraces were concatenated\n  // If you are coming here from a stacktrace, please know that the two parts before and after this line are different\n  // stacktraces that were concatenated with concatStacktraces\n  const separator = removeStacktraceNameLine(new Error().stack ?? \"\").split(\"\\n\")[0];\n\n\n  for (const error of errors) {\n    const toAppend = removeStacktraceNameLine(error.stack ?? \"\");\n    first.stack += (addsEmptyLineAtEnd ? \"\" : \"\\n\") + separator + \"\\n\" + toAppend;\n  }\n}\n\n\nexport class StackAssertionError extends Error {\n  constructor(message: string, public readonly extraData?: Record<string, any> & ErrorOptions) {\n    const disclaimer = `\\n\\nThis is likely an error in Stack. Please make sure you are running the newest version and report it.`;\n    super(`${message}${message.endsWith(disclaimer) ? \"\" : disclaimer}`, pick(extraData ?? {}, [\"cause\"]));\n\n    Object.defineProperty(this, \"customCaptureExtraArgs\", {\n      get() {\n        return [this.extraData];\n      },\n      enumerable: false,\n    });\n\n    if (process.env.NEXT_PUBLIC_STACK_DEBUGGER_ON_ASSERTION_ERROR === \"true\") {\n      debugger;\n    }\n  }\n}\nStackAssertionError.prototype.name = \"StackAssertionError\";\n\n\nexport function errorToNiceString(error: unknown): string {\n  if (!(error instanceof Error)) return `${typeof error}<${nicify(error)}>`;\n  return nicify(error, { maxDepth: 8 });\n}\n\n\nconst errorSinks = new Set<(location: string, error: unknown, ...extraArgs: unknown[]) => void>();\nexport function registerErrorSink(sink: (location: string, error: unknown) => void): void {\n  if (errorSinks.has(sink)) {\n    return;\n  }\n  errorSinks.add(sink);\n}\nregisterErrorSink((location, error, ...extraArgs) => {\n  console.error(\n    `\\x1b[41mCaptured error in ${location}:`,\n    // HACK: Log a nicified version of the error to get around buggy Next.js pretty-printing\n    // https://www.reddit.com/r/nextjs/comments/1gkxdqe/comment/m19kxgn/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button\n    errorToNiceString(error),\n    ...extraArgs,\n    \"\\x1b[0m\",\n  );\n});\nregisterErrorSink((location, error, ...extraArgs) => {\n  globalVar.stackCapturedErrors = globalVar.stackCapturedErrors ?? [];\n  globalVar.stackCapturedErrors.push({ location, error, extraArgs });\n});\n\n/**\n * Captures an error and sends it to the error sinks (most notably, Sentry). Errors caught with captureError are\n * supposed to be seen by an engineer, so they should be actionable and important.\n *\n * The location string is a machine-readable ID, and should hence not contain spaces or anything like that. Good\n * examples are: \"api-route-handler\", \"renderPart()\", etc.\n *\n * Errors that bubble up to the top of runAsynchronously or a route handler are already captured with captureError.\n */\nexport function captureError(location: string, error: unknown): void {\n  for (const sink of errorSinks) {\n    sink(\n      location,\n      error,\n      ...error && (typeof error === 'object' || typeof error === 'function') && \"customCaptureExtraArgs\" in error && Array.isArray(error.customCaptureExtraArgs) ? (error.customCaptureExtraArgs as any[]) : [],\n    );\n  }\n}\n\n\ntype Status = {\n  statusCode: number,\n  message: string,\n};\n\ntype StatusErrorConstructorParameters =\n| [\n  status: Status,\n  message?: string\n]\n| [\n  statusCode: number | Status,\n  message: string,\n];\n\nexport class StatusError extends Error {\n  private readonly __stackStatusErrorBrand = \"stack-status-error-brand-sentinel\" as const;\n  public name = \"StatusError\";\n  public readonly statusCode: number;\n\n  public static BadRequest = { statusCode: 400, message: \"Bad Request\" };\n  public static Unauthorized = { statusCode: 401, message: \"Unauthorized\" };\n  public static PaymentRequired = { statusCode: 402, message: \"Payment Required\" };\n  public static Forbidden = { statusCode: 403, message: \"Forbidden\" };\n  public static NotFound = { statusCode: 404, message: \"Not Found\" };\n  public static MethodNotAllowed = { statusCode: 405, message: \"Method Not Allowed\" };\n  public static NotAcceptable = { statusCode: 406, message: \"Not Acceptable\" };\n  public static ProxyAuthenticationRequired = { statusCode: 407, message: \"Proxy Authentication Required\" };\n  public static RequestTimeout = { statusCode: 408, message: \"Request Timeout\" };\n  public static Conflict = { statusCode: 409, message: \"Conflict\" };\n  public static Gone = { statusCode: 410, message: \"Gone\" };\n  public static LengthRequired = { statusCode: 411, message: \"Length Required\" };\n  public static PreconditionFailed = { statusCode: 412, message: \"Precondition Failed\" };\n  public static PayloadTooLarge = { statusCode: 413, message: \"Payload Too Large\" };\n  public static URITooLong = { statusCode: 414, message: \"URI Too Long\" };\n  public static UnsupportedMediaType = { statusCode: 415, message: \"Unsupported Media Type\" };\n  public static RangeNotSatisfiable = { statusCode: 416, message: \"Range Not Satisfiable\" };\n  public static ExpectationFailed = { statusCode: 417, message: \"Expectation Failed\" };\n  public static ImATeapot = { statusCode: 418, message: \"I'm a teapot\" };\n  public static MisdirectedRequest = { statusCode: 421, message: \"Misdirected Request\" };\n  public static UnprocessableEntity = { statusCode: 422, message: \"Unprocessable Entity\" };\n  public static Locked = { statusCode: 423, message: \"Locked\" };\n  public static FailedDependency = { statusCode: 424, message: \"Failed Dependency\" };\n  public static TooEarly = { statusCode: 425, message: \"Too Early\" };\n  public static UpgradeRequired = { statusCode: 426, message: \"Upgrade Required\" };\n  public static PreconditionRequired = { statusCode: 428, message: \"Precondition Required\" };\n  public static TooManyRequests = { statusCode: 429, message: \"Too Many Requests\" };\n  public static RequestHeaderFieldsTooLarge = { statusCode: 431, message: \"Request Header Fields Too Large\" };\n  public static UnavailableForLegalReasons = { statusCode: 451, message: \"Unavailable For Legal Reasons\" };\n\n  public static InternalServerError = { statusCode: 500, message: \"Internal Server Error\" };\n  public static NotImplemented = { statusCode: 501, message: \"Not Implemented\" };\n  public static BadGateway = { statusCode: 502, message: \"Bad Gateway\" };\n  public static ServiceUnavailable = { statusCode: 503, message: \"Service Unavailable\" };\n  public static GatewayTimeout = { statusCode: 504, message: \"Gateway Timeout\" };\n  public static HTTPVersionNotSupported = { statusCode: 505, message: \"HTTP Version Not Supported\" };\n  public static VariantAlsoNegotiates = { statusCode: 506, message: \"Variant Also Negotiates\" };\n  public static InsufficientStorage = { statusCode: 507, message: \"Insufficient Storage\" };\n  public static LoopDetected = { statusCode: 508, message: \"Loop Detected\" };\n  public static NotExtended = { statusCode: 510, message: \"Not Extended\" };\n  public static NetworkAuthenticationRequired = { statusCode: 511, message: \"Network Authentication Required\" };\n\n\n  constructor(...args: StatusErrorConstructorParameters);\n  constructor(\n    status: number | Status,\n    message?: string,\n  ) {\n    if (typeof status === \"object\") {\n      message ??= status.message;\n      status = status.statusCode;\n    }\n    super(message);\n    this.statusCode = status;\n    if (!message) {\n      throw new StackAssertionError(\"StatusError always requires a message unless a Status object is passed\", { cause: this });\n    }\n  }\n\n  public static isStatusError(error: unknown): error is StatusError {\n    // like instanceof, but also works for errors thrown in other realms or by different versions of the same package\n    return typeof error === \"object\" && error !== null && \"__stackStatusErrorBrand\" in error && error.__stackStatusErrorBrand === \"stack-status-error-brand-sentinel\";\n  }\n\n  public isClientError() {\n    return this.statusCode >= 400 && this.statusCode < 500;\n  }\n\n  public isServerError() {\n    return !this.isClientError();\n  }\n\n  public getStatusCode(): number {\n    return this.statusCode;\n  }\n\n  public getBody(): Uint8Array {\n    return new TextEncoder().encode(this.message);\n  }\n\n  public getHeaders(): Record<string, string[]> {\n    return {\n      \"Content-Type\": [\"text/plain; charset=utf-8\"],\n    };\n  }\n\n  public toDescriptiveJson(): Json {\n    return {\n      status_code: this.getStatusCode(),\n      message: this.message,\n      headers: this.getHeaders(),\n    };\n  }\n\n  /**\n   * @deprecated this is not a good way to make status errors human-readable, use toDescriptiveJson instead\n   */\n  public toHttpJson(): Json {\n    return {\n      status_code: this.statusCode,\n      body: this.message,\n      headers: this.getHeaders(),\n    };\n  }\n}\nStatusError.prototype.name = \"StatusError\";\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAgFQ;AAhFR,SAAS,iBAAiB;AAE1B,SAAS,YAAY;AACrB,SAAS,cAAc;;;;AAMhB,SAAS,SAAA,GAAY,IAAA,EAAoB;IAC9C,IAAI,OAAO,IAAA,CAAK,CAAC,CAAA,KAAM,UAAU;QAC/B,MAAM,IAAI,oBAAoB,IAAA,CAAK,CAAC,CAAA,EAAG,IAAA,CAAK,CAAC,CAAC;IAChD,OAAA,IAAW,IAAA,CAAK,CAAC,CAAA,YAAa,OAAO;QACnC,MAAM,IAAA,CAAK,CAAC,CAAA;IACd,OAAO;QAEL,MAAM,IAAI,YAAY,GAAG,IAAI;IAC/B;AACF;AAEA,SAAS,yBAAyB,KAAA,EAAuB;IAEvD,MAAM,eAAe,IAAI,MAAM,EAAE,KAAA,EAAO,WAAW,SAAS;IAC5D,OAAO,MAAM,KAAA,CAAM,IAAI,EAAE,KAAA,CAAM,eAAe,IAAI,CAAC,EAAE,IAAA,CAAK,IAAI;AAChE;AA0BO,SAAS,kBAAkB,KAAA,EAAA,GAAiB,MAAA,EAAuB;IAExE,MAAM,qBAAqB,MAAM,KAAA,EAAO,SAAS,IAAI;IAMrD,MAAM,YAAY,yBAAyB,IAAI,MAAM,EAAE,KAAA,IAAS,EAAE,EAAE,KAAA,CAAM,IAAI,CAAA,CAAE,CAAC,CAAA;IAGjF,KAAA,MAAW,SAAS,OAAQ;QAC1B,MAAM,WAAW,yBAAyB,MAAM,KAAA,IAAS,EAAE;QAC3D,MAAM,KAAA,IAAA,CAAU,qBAAqB,KAAK,IAAA,IAAQ,YAAY,OAAO;IACvE;AACF;AAGO,IAAM,sBAAN,cAAkC,MAAM;IAC7C,YAAY,OAAA,EAAiC,SAAA,CAAgD;QAC3F,MAAM,aAAa,CAAA;;oGAAA,CAAA;QACnB,KAAA,CAAM,GAAG,OAAO,GAAG,QAAQ,QAAA,CAAS,UAAU,IAAI,KAAK,UAAU,EAAA,EAAI,qOAAA,EAAK,aAAa,CAAC,GAAG;YAAC,OAAO;SAAC,CAAC;QAF1D,IAAA,CAAA,SAAA,GAAA;QAI3C,OAAO,cAAA,CAAe,IAAA,EAAM,0BAA0B;YACpD,MAAM;gBACJ,OAAO;oBAAC,IAAA,CAAK,SAAS;iBAAA;YACxB;YACA,YAAY;QACd,CAAC;QAED,mNAAI,CAAQ,GAAA,CAAI,6CAAA,KAAkD,QAAQ;YACxE,QAAA;QACF;IACF;AACF;AACA,oBAAoB,SAAA,CAAU,IAAA,GAAO;AAG9B,SAAS,kBAAkB,KAAA,EAAwB;IACxD,IAAI,CAAA,CAAE,iBAAiB,KAAA,EAAQ,CAAA,OAAO,GAAG,OAAO,KAAK,CAAA,CAAA,EAAI,uOAAA,EAAO,KAAK,CAAC,CAAA,CAAA,CAAA;IACtE,WAAO,mOAAA,EAAO,OAAO;QAAE,UAAU;IAAE,CAAC;AACtC;AAGA,IAAM,aAAa,aAAA,GAAA,IAAI,IAAyE;AACzF,SAAS,kBAAkB,IAAA,EAAwD;IACxF,IAAI,WAAW,GAAA,CAAI,IAAI,GAAG;QACxB;IACF;IACA,WAAW,GAAA,CAAI,IAAI;AACrB;AACA,kBAAkB,CAAC,UAAU,OAAA,GAAU,cAAc;IACnD,QAAQ,KAAA,CACN,CAAA,0BAAA,EAA6B,QAAQ,CAAA,CAAA,CAAA,EAAA,wFAAA;IAAA,4JAAA;IAGrC,kBAAkB,KAAK,MACpB,WACH;AAEJ,CAAC;AACD,kBAAkB,CAAC,UAAU,OAAA,GAAU,cAAc;IACnD,sOAAA,CAAU,mBAAA,GAAsB,sOAAA,CAAU,mBAAA,IAAuB,CAAC,CAAA;IAClE,sOAAA,CAAU,mBAAA,CAAoB,IAAA,CAAK;QAAE;QAAU;QAAO;IAAU,CAAC;AACnE,CAAC;AAWM,SAAS,aAAa,QAAA,EAAkB,KAAA,EAAsB;IACnE,KAAA,MAAW,QAAQ,WAAY;QAC7B,KACE,UACA,UACG,SAAA,CAAU,OAAO,UAAU,YAAY,OAAO,UAAU,UAAA,KAAe,4BAA4B,SAAS,MAAM,OAAA,CAAQ,MAAM,sBAAsB,IAAK,MAAM,sBAAA,GAAmC,CAAC,CAAA;IAE5M;AACF;AAkBO,IAAM,cAAN,cAA0B,MAAM;IAiDrC,YACE,MAAA,EACA,OAAA,CACA;QACA,IAAI,OAAO,WAAW,UAAU;YAC9B,YAAY,OAAO,OAAA;YACnB,SAAS,OAAO,UAAA;QAClB;QACA,KAAA,CAAM,OAAO;QAxDf,IAAA,CAAiB,uBAAA,GAA0B;QAC3C,IAAA,CAAO,IAAA,GAAO;QAwDZ,IAAA,CAAK,UAAA,GAAa;QAClB,IAAI,CAAC,SAAS;YACZ,MAAM,IAAI,oBAAoB,0EAA0E;gBAAE,OAAO,IAAA;YAAK,CAAC;QACzH;IACF;IAEA,OAAc,cAAc,KAAA,EAAsC;QAEhE,OAAO,OAAO,UAAU,YAAY,UAAU,QAAQ,6BAA6B,SAAS,MAAM,uBAAA,KAA4B;IAChI;IAEO,gBAAgB;QACrB,OAAO,IAAA,CAAK,UAAA,IAAc,OAAO,IAAA,CAAK,UAAA,GAAa;IACrD;IAEO,gBAAgB;QACrB,OAAO,CAAC,IAAA,CAAK,aAAA,CAAc;IAC7B;IAEO,gBAAwB;QAC7B,OAAO,IAAA,CAAK,UAAA;IACd;IAEO,UAAsB;QAC3B,OAAO,IAAI,YAAY,EAAE,MAAA,CAAO,IAAA,CAAK,OAAO;IAC9C;IAEO,aAAuC;QAC5C,OAAO;YACL,gBAAgB;gBAAC,2BAA2B;aAAA;QAC9C;IACF;IAEO,oBAA0B;QAC/B,OAAO;YACL,aAAa,IAAA,CAAK,aAAA,CAAc;YAChC,SAAS,IAAA,CAAK,OAAA;YACd,SAAS,IAAA,CAAK,UAAA,CAAW;QAC3B;IACF;IAAA;;GAAA,GAKO,aAAmB;QACxB,OAAO;YACL,aAAa,IAAA,CAAK,UAAA;YAClB,MAAM,IAAA,CAAK,OAAA;YACX,SAAS,IAAA,CAAK,UAAA,CAAW;QAC3B;IACF;AACF;AA7Ga,YAKG,UAAA,GAAa;IAAE,YAAY;IAAK,SAAS;AAAc;AAL1D,YAMG,YAAA,GAAe;IAAE,YAAY;IAAK,SAAS;AAAe;AAN7D,YAOG,eAAA,GAAkB;IAAE,YAAY;IAAK,SAAS;AAAmB;AAPpE,YAQG,SAAA,GAAY;IAAE,YAAY;IAAK,SAAS;AAAY;AARvD,YASG,QAAA,GAAW;IAAE,YAAY;IAAK,SAAS;AAAY;AATtD,YAUG,gBAAA,GAAmB;IAAE,YAAY;IAAK,SAAS;AAAqB;AAVvE,YAWG,aAAA,GAAgB;IAAE,YAAY;IAAK,SAAS;AAAiB;AAXhE,YAYG,2BAAA,GAA8B;IAAE,YAAY;IAAK,SAAS;AAAgC;AAZ7F,YAaG,cAAA,GAAiB;IAAE,YAAY;IAAK,SAAS;AAAkB;AAblE,YAcG,QAAA,GAAW;IAAE,YAAY;IAAK,SAAS;AAAW;AAdrD,YAeG,IAAA,GAAO;IAAE,YAAY;IAAK,SAAS;AAAO;AAf7C,YAgBG,cAAA,GAAiB;IAAE,YAAY;IAAK,SAAS;AAAkB;AAhBlE,YAiBG,kBAAA,GAAqB;IAAE,YAAY;IAAK,SAAS;AAAsB;AAjB1E,YAkBG,eAAA,GAAkB;IAAE,YAAY;IAAK,SAAS;AAAoB;AAlBrE,YAmBG,UAAA,GAAa;IAAE,YAAY;IAAK,SAAS;AAAe;AAnB3D,YAoBG,oBAAA,GAAuB;IAAE,YAAY;IAAK,SAAS;AAAyB;AApB/E,YAqBG,mBAAA,GAAsB;IAAE,YAAY;IAAK,SAAS;AAAwB;AArB7E,YAsBG,iBAAA,GAAoB;IAAE,YAAY;IAAK,SAAS;AAAqB;AAtBxE,YAuBG,SAAA,GAAY;IAAE,YAAY;IAAK,SAAS;AAAe;AAvB1D,YAwBG,kBAAA,GAAqB;IAAE,YAAY;IAAK,SAAS;AAAsB;AAxB1E,YAyBG,mBAAA,GAAsB;IAAE,YAAY;IAAK,SAAS;AAAuB;AAzB5E,YA0BG,MAAA,GAAS;IAAE,YAAY;IAAK,SAAS;AAAS;AA1BjD,YA2BG,gBAAA,GAAmB;IAAE,YAAY;IAAK,SAAS;AAAoB;AA3BtE,YA4BG,QAAA,GAAW;IAAE,YAAY;IAAK,SAAS;AAAY;AA5BtD,YA6BG,eAAA,GAAkB;IAAE,YAAY;IAAK,SAAS;AAAmB;AA7BpE,YA8BG,oBAAA,GAAuB;IAAE,YAAY;IAAK,SAAS;AAAwB;AA9B9E,YA+BG,eAAA,GAAkB;IAAE,YAAY;IAAK,SAAS;AAAoB;AA/BrE,YAgCG,2BAAA,GAA8B;IAAE,YAAY;IAAK,SAAS;AAAkC;AAhC/F,YAiCG,0BAAA,GAA6B;IAAE,YAAY;IAAK,SAAS;AAAgC;AAjC5F,YAmCG,mBAAA,GAAsB;IAAE,YAAY;IAAK,SAAS;AAAwB;AAnC7E,YAoCG,cAAA,GAAiB;IAAE,YAAY;IAAK,SAAS;AAAkB;AApClE,YAqCG,UAAA,GAAa;IAAE,YAAY;IAAK,SAAS;AAAc;AArC1D,YAsCG,kBAAA,GAAqB;IAAE,YAAY;IAAK,SAAS;AAAsB;AAtC1E,YAuCG,cAAA,GAAiB;IAAE,YAAY;IAAK,SAAS;AAAkB;AAvClE,YAwCG,uBAAA,GAA0B;IAAE,YAAY;IAAK,SAAS;AAA6B;AAxCtF,YAyCG,qBAAA,GAAwB;IAAE,YAAY;IAAK,SAAS;AAA0B;AAzCjF,YA0CG,mBAAA,GAAsB;IAAE,YAAY;IAAK,SAAS;AAAuB;AA1C5E,YA2CG,YAAA,GAAe;IAAE,YAAY;IAAK,SAAS;AAAgB;AA3C9D,YA4CG,WAAA,GAAc;IAAE,YAAY;IAAK,SAAS;AAAe;AA5C5D,YA6CG,6BAAA,GAAgC;IAAE,YAAY;IAAK,SAAS;AAAkC;AAiE9G,YAAY,SAAA,CAAU,IAAA,GAAO"}},
    {"offset": {"line": 1271, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack-shared/src/known-errors.tsx"],"sourcesContent":["import { StackAssertionError, StatusError, throwErr } from \"./utils/errors\";\nimport { identityArgs } from \"./utils/functions\";\nimport { Json } from \"./utils/json\";\nimport { deindent } from \"./utils/strings\";\n\nexport type KnownErrorJson = {\n  code: string,\n  message: string,\n  details?: Json,\n};\n\nexport type AbstractKnownErrorConstructor<Args extends any[]> =\n  & (abstract new (...args: Args) => KnownError)\n  & {\n    constructorArgsFromJson: (json: KnownErrorJson) => Args,\n  };\n\nexport type KnownErrorConstructor<SuperInstance extends KnownError, Args extends any[]> = {\n  new(...args: Args): SuperInstance & { constructorArgs: Args },\n  errorCode: string,\n  constructorArgsFromJson: (json: KnownErrorJson) => Args,\n  isInstance: (error: unknown) => error is SuperInstance & { constructorArgs: Args },\n};\n\nexport abstract class KnownError extends StatusError {\n  private readonly __stackKnownErrorBrand = \"stack-known-error-brand-sentinel\" as const;\n  public name = \"KnownError\";\n\n  constructor(\n    public readonly statusCode: number,\n    public readonly humanReadableMessage: string,\n    public readonly details?: Json,\n  ) {\n    super(\n      statusCode,\n      humanReadableMessage\n    );\n  }\n\n  public static isKnownError(error: unknown): error is KnownError {\n    // like instanceof, but also works for errors thrown in other realms or by different versions of the same package\n    return typeof error === \"object\" && error !== null && \"__stackKnownErrorBrand\" in error && error.__stackKnownErrorBrand === \"stack-known-error-brand-sentinel\";\n  }\n\n  public override getBody(): Uint8Array {\n    return new TextEncoder().encode(JSON.stringify(this.toDescriptiveJson(), undefined, 2));\n  }\n\n  public override getHeaders(): Record<string, string[]> {\n    return {\n      \"Content-Type\": [\"application/json; charset=utf-8\"],\n      \"X-Stack-Known-Error\": [this.errorCode],\n    };\n  }\n\n  public override toDescriptiveJson(): Json {\n    return {\n      code: this.errorCode,\n      ...this.details ? { details: this.details } : {},\n      error: this.humanReadableMessage,\n    };\n  }\n\n  get errorCode(): string {\n    return (this.constructor as any).errorCode ?? throwErr(`Can't find error code for this KnownError. Is its constructor a KnownErrorConstructor? ${this}`);\n  }\n\n  public static constructorArgsFromJson(json: KnownErrorJson): ConstructorParameters<typeof KnownError> {\n    return [\n      400,\n      json.message,\n      json,\n    ];\n  }\n\n  public static fromJson(json: KnownErrorJson): KnownError {\n    for (const [_, KnownErrorType] of Object.entries(KnownErrors)) {\n      if (json.code === KnownErrorType.prototype.errorCode) {\n        const constructorArgs = KnownErrorType.constructorArgsFromJson(json);\n        return new KnownErrorType(\n          // @ts-ignore-next-line\n          ...constructorArgs,\n        );\n      }\n    }\n\n    throw new Error(`Unknown KnownError code. You may need to update your version of Stack to see more detailed information. ${json.code}: ${json.message}`);\n  }\n}\n\nconst knownErrorConstructorErrorCodeSentinel = Symbol(\"knownErrorConstructorErrorCodeSentinel\");\n/**\n * Exists solely so that known errors are nominative types (ie. two KnownErrors with the same interface are not the same type)\n */\ntype KnownErrorBrand<ErrorCode extends string> = {\n  /**\n   * Does not exist at runtime\n   *\n   * Must be an object because it may be true for multiple error codes (it's true for all parents)\n   */\n  [knownErrorConstructorErrorCodeSentinel]: {\n    [K in ErrorCode]: true\n  },\n};\n\nfunction createKnownErrorConstructor<ErrorCode extends string, Super extends AbstractKnownErrorConstructor<any>, Args extends any[]>(\n  SuperClass: Super,\n  errorCode: ErrorCode,\n  create: ((...args: Args) => Readonly<ConstructorParameters<Super>>),\n  constructorArgsFromJson: ((jsonDetails: any) => Args),\n): KnownErrorConstructor<InstanceType<Super> & KnownErrorBrand<ErrorCode>, Args> & { errorCode: ErrorCode };\nfunction createKnownErrorConstructor<ErrorCode extends string, Super extends AbstractKnownErrorConstructor<any>>(\n  SuperClass: Super,\n  errorCode: ErrorCode,\n  create: \"inherit\",\n  constructorArgsFromJson: \"inherit\",\n): KnownErrorConstructor<InstanceType<Super> & KnownErrorBrand<ErrorCode>, ConstructorParameters<Super>> & { errorCode: ErrorCode };\nfunction createKnownErrorConstructor<ErrorCode extends string, Super extends AbstractKnownErrorConstructor<any>, Args extends any[]>(\n  SuperClass: Super,\n  errorCode: ErrorCode,\n  create: \"inherit\" | ((...args: Args) => Readonly<ConstructorParameters<Super>>),\n  constructorArgsFromJson: \"inherit\" | ((jsonDetails: any) => Args),\n): KnownErrorConstructor<InstanceType<Super> & KnownErrorBrand<ErrorCode>, Args> & { errorCode: ErrorCode } {\n  const createFn = create === \"inherit\" ? identityArgs<Args> as never : create;\n  const constructorArgsFromJsonFn = constructorArgsFromJson === \"inherit\" ? SuperClass.constructorArgsFromJson as never : constructorArgsFromJson;\n\n  // @ts-expect-error this is not a mixin, but TS detects it as one\n  class KnownErrorImpl extends SuperClass {\n    public static readonly errorCode = errorCode;\n    public name = `KnownError<${errorCode}>`;\n    public readonly constructorArgs: Args;\n\n    constructor(...args: Args) {\n      // @ts-expect-error DEVIN, STOP REMOVING THIS LINE YOU DUMBASS, YES TYPESCRIPT DOES THROW AN ERROR IF YOU DON'T HAVE IT, NO THIS IS NOT \"UNUSED\", AND YES YOU ARE BREAKING OUR CI PIPELINE EVERY TIME YOU DO IT\n      super(...createFn(...args));\n      this.constructorArgs = args;\n    }\n\n    static constructorArgsFromJson(json: KnownErrorJson): Args {\n      return constructorArgsFromJsonFn(json.details);\n    }\n\n    static isInstance(error: unknown): error is InstanceType<Super> & { constructorArgs: Args } {\n      if (!KnownError.isKnownError(error)) return false;\n      let current: unknown = error;\n      while (true) {\n        current = Object.getPrototypeOf(current);\n        if (!current) break;\n        if (\"errorCode\" in current.constructor && current.constructor.errorCode === errorCode) return true;\n      }\n      return false;\n    }\n  };\n\n  // @ts-expect-error\n  return KnownErrorImpl;\n}\nundefined?.test(\"KnownError.isInstance\", ({ expect }) => {\n  expect(KnownErrors.InvalidProjectAuthentication.isInstance(undefined)).toBe(false);\n  expect(KnownErrors.InvalidProjectAuthentication.isInstance(new Error())).toBe(false);\n\n  const error = new KnownErrors.ProjectKeyWithoutAccessType();\n  expect(KnownErrors.ProjectKeyWithoutAccessType.isInstance(error)).toBe(true);\n  expect(KnownErrors.InvalidProjectAuthentication.isInstance(error)).toBe(true);\n  expect(KnownErrors.InvalidAccessType.isInstance(error)).toBe(false);\n});\n\nconst UnsupportedError = createKnownErrorConstructor(\n  KnownError,\n  \"UNSUPPORTED_ERROR\",\n  (originalErrorCode: string) => [\n    500,\n    `An error occurred that is not currently supported (possibly because it was added in a version of Stack that is newer than this client). The original unsupported error code was: ${originalErrorCode}`,\n    {\n      originalErrorCode,\n    },\n  ] as const,\n  (json) => [\n    (json as any)?.originalErrorCode ?? throwErr(\"originalErrorCode not found in UnsupportedError details\"),\n  ] as const,\n);\n\nconst BodyParsingError = createKnownErrorConstructor(\n  KnownError,\n  \"BODY_PARSING_ERROR\",\n  (message: string) => [\n    400,\n    message,\n  ] as const,\n  (json) => [json.message] as const,\n);\n\nconst SchemaError = createKnownErrorConstructor(\n  KnownError,\n  \"SCHEMA_ERROR\",\n  (message: string) => [\n    400,\n    message || throwErr(\"SchemaError requires a message\"),\n    {\n      message,\n    },\n  ] as const,\n  (json: any) => [json.message] as const,\n);\n\nconst AllOverloadsFailed = createKnownErrorConstructor(\n  KnownError,\n  \"ALL_OVERLOADS_FAILED\",\n  (overloadErrors: Json[]) => [\n    400,\n    deindent`\n      This endpoint has multiple overloads, but they all failed to process the request.\n\n        ${overloadErrors.map((e, i) => deindent`\n          Overload ${i + 1}: ${JSON.stringify(e, undefined, 2)}\n        `).join(\"\\n\\n\")}\n    `,\n    {\n      overload_errors: overloadErrors,\n    },\n  ] as const,\n  (json) => [\n    (json as any)?.overload_errors ?? throwErr(\"overload_errors not found in AllOverloadsFailed details\"),\n  ] as const,\n);\n\nconst ProjectAuthenticationError = createKnownErrorConstructor(\n  KnownError,\n  \"PROJECT_AUTHENTICATION_ERROR\",\n  \"inherit\",\n  \"inherit\",\n);\n\nconst InvalidProjectAuthentication = createKnownErrorConstructor(\n  ProjectAuthenticationError,\n  \"INVALID_PROJECT_AUTHENTICATION\",\n  \"inherit\",\n  \"inherit\",\n);\n\nconst ProjectKeyWithoutAccessType = createKnownErrorConstructor(\n  InvalidProjectAuthentication,\n  \"PROJECT_KEY_WITHOUT_ACCESS_TYPE\",\n  () => [\n    400,\n    \"Either an API key or an admin access token was provided, but the x-stack-access-type header is missing. Set it to 'client', 'server', or 'admin' as appropriate.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst InvalidAccessType = createKnownErrorConstructor(\n  InvalidProjectAuthentication,\n  \"INVALID_ACCESS_TYPE\",\n  (accessType: string) => [\n    400,\n    `The x-stack-access-type header must be 'client', 'server', or 'admin', but was '${accessType}'.`,\n  ] as const,\n  (json) => [\n    (json as any)?.accessType ?? throwErr(\"accessType not found in InvalidAccessType details\"),\n  ] as const,\n);\n\nconst AccessTypeWithoutProjectId = createKnownErrorConstructor(\n  InvalidProjectAuthentication,\n  \"ACCESS_TYPE_WITHOUT_PROJECT_ID\",\n  (accessType: \"client\" | \"server\" | \"admin\") => [\n    400,\n    deindent`\n      The x-stack-access-type header was '${accessType}', but the x-stack-project-id header was not provided.\n      \n      For more information, see the docs on REST API authentication: https://docs.stack-auth.com/rest-api/overview#authentication\n    `,\n    {\n      request_type: accessType,\n    },\n  ] as const,\n  (json: any) => [json.request_type] as const,\n);\n\nconst AccessTypeRequired = createKnownErrorConstructor(\n  InvalidProjectAuthentication,\n  \"ACCESS_TYPE_REQUIRED\",\n  () => [\n    400,\n    deindent`\n      You must specify an access level for this Stack project. Make sure project API keys are provided (eg. x-stack-publishable-client-key) and you set the x-stack-access-type header to 'client', 'server', or 'admin'.\n      \n      For more information, see the docs on REST API authentication: https://docs.stack-auth.com/rest-api/overview#authentication\n    `,\n  ] as const,\n  () => [] as const,\n);\n\nconst InsufficientAccessType = createKnownErrorConstructor(\n  InvalidProjectAuthentication,\n  \"INSUFFICIENT_ACCESS_TYPE\",\n  (actualAccessType: \"client\" | \"server\" | \"admin\", allowedAccessTypes: (\"client\" | \"server\" | \"admin\")[]) => [\n    401,\n    `The x-stack-access-type header must be ${allowedAccessTypes.map(s => `'${s}'`).join(\" or \")}, but was '${actualAccessType}'.`,\n    {\n      actual_access_type: actualAccessType,\n      allowed_access_types: allowedAccessTypes,\n    },\n  ] as const,\n  (json: any) => [\n    json.actual_access_type,\n    json.allowed_access_types,\n  ] as const,\n);\n\nconst InvalidPublishableClientKey = createKnownErrorConstructor(\n  InvalidProjectAuthentication,\n  \"INVALID_PUBLISHABLE_CLIENT_KEY\",\n  (projectId: string) => [\n    401,\n    `The publishable key is not valid for the project ${JSON.stringify(projectId)}. Does the project and/or the key exist?`,\n    {\n      project_id: projectId,\n    },\n  ] as const,\n  (json: any) => [json.project_id] as const,\n);\n\nconst InvalidSecretServerKey = createKnownErrorConstructor(\n  InvalidProjectAuthentication,\n  \"INVALID_SECRET_SERVER_KEY\",\n  (projectId: string) => [\n    401,\n    `The secret server key is not valid for the project ${JSON.stringify(projectId)}. Does the project and/or the key exist?`,\n    {\n      project_id: projectId,\n    },\n  ] as const,\n  (json: any) => [json.project_id] as const,\n);\n\nconst InvalidSuperSecretAdminKey = createKnownErrorConstructor(\n  InvalidProjectAuthentication,\n  \"INVALID_SUPER_SECRET_ADMIN_KEY\",\n  (projectId: string) => [\n    401,\n    `The super secret admin key is not valid for the project ${JSON.stringify(projectId)}. Does the project and/or the key exist?`,\n    {\n      project_id: projectId,\n    },\n  ] as const,\n  (json: any) => [json.project_id] as const,\n);\n\nconst InvalidAdminAccessToken = createKnownErrorConstructor(\n  InvalidProjectAuthentication,\n  \"INVALID_ADMIN_ACCESS_TOKEN\",\n  \"inherit\",\n  \"inherit\",\n);\n\nconst UnparsableAdminAccessToken = createKnownErrorConstructor(\n  InvalidAdminAccessToken,\n  \"UNPARSABLE_ADMIN_ACCESS_TOKEN\",\n  () => [\n    401,\n    \"Admin access token is not parsable.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst AdminAccessTokenExpired = createKnownErrorConstructor(\n  InvalidAdminAccessToken,\n  \"ADMIN_ACCESS_TOKEN_EXPIRED\",\n  (expiredAt: Date | undefined) => [\n    401,\n    `Admin access token has expired. Please refresh it and try again.${expiredAt ? ` (The access token expired at ${expiredAt.toISOString()}.)` : \"\"}`,\n    { expired_at_millis: expiredAt?.getTime() ?? null },\n  ] as const,\n  (json: any) => [json.expired_at_millis ? new Date(json.expired_at_millis) : undefined] as const,\n);\n\nconst InvalidProjectForAdminAccessToken = createKnownErrorConstructor(\n  InvalidAdminAccessToken,\n  \"INVALID_PROJECT_FOR_ADMIN_ACCESS_TOKEN\",\n  () => [\n    401,\n    \"Admin access tokens must be created on the internal project.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst AdminAccessTokenIsNotAdmin = createKnownErrorConstructor(\n  InvalidAdminAccessToken,\n  \"ADMIN_ACCESS_TOKEN_IS_NOT_ADMIN\",\n  () => [\n    401,\n    \"Admin access token does not have the required permissions to access this project.\",\n  ] as const,\n  () => [] as const,\n);\n\n/**\n * @deprecated Use InsufficientAccessType instead\n */\nconst ProjectAuthenticationRequired = createKnownErrorConstructor(\n  ProjectAuthenticationError,\n  \"PROJECT_AUTHENTICATION_REQUIRED\",\n  \"inherit\",\n  \"inherit\",\n);\n\n\n/**\n * @deprecated Use InsufficientAccessType instead\n */\nconst ClientAuthenticationRequired = createKnownErrorConstructor(\n  ProjectAuthenticationRequired,\n  \"CLIENT_AUTHENTICATION_REQUIRED\",\n  () => [\n    401,\n    \"The publishable client key must be provided.\",\n  ] as const,\n  () => [] as const,\n);\n\n/**\n * @deprecated Use InsufficientAccessType instead\n */\nconst ServerAuthenticationRequired = createKnownErrorConstructor(\n  ProjectAuthenticationRequired,\n  \"SERVER_AUTHENTICATION_REQUIRED\",\n  () => [\n    401,\n    \"The secret server key must be provided.\",\n  ] as const,\n  () => [] as const,\n);\n\n/**\n * @deprecated Use InsufficientAccessType instead\n */\nconst ClientOrServerAuthenticationRequired = createKnownErrorConstructor(\n  ProjectAuthenticationRequired,\n  \"CLIENT_OR_SERVER_AUTHENTICATION_REQUIRED\",\n  () => [\n    401,\n    \"Either the publishable client key or the secret server key must be provided.\",\n  ] as const,\n  () => [] as const,\n);\n\n/**\n * @deprecated Use InsufficientAccessType instead\n */\nconst ClientOrAdminAuthenticationRequired = createKnownErrorConstructor(\n  ProjectAuthenticationRequired,\n  \"CLIENT_OR_ADMIN_AUTHENTICATION_REQUIRED\",\n  () => [\n    401,\n    \"Either the publishable client key or the super secret admin key must be provided.\",\n  ] as const,\n  () => [] as const,\n);\n\n/**\n * @deprecated Use InsufficientAccessType instead\n */\nconst ClientOrServerOrAdminAuthenticationRequired = createKnownErrorConstructor(\n  ProjectAuthenticationRequired,\n  \"CLIENT_OR_SERVER_OR_ADMIN_AUTHENTICATION_REQUIRED\",\n  () => [\n    401,\n    \"Either the publishable client key, the secret server key, or the super secret admin key must be provided.\",\n  ] as const,\n  () => [] as const,\n);\n\n/**\n * @deprecated Use InsufficientAccessType instead\n */\nconst AdminAuthenticationRequired = createKnownErrorConstructor(\n  ProjectAuthenticationRequired,\n  \"ADMIN_AUTHENTICATION_REQUIRED\",\n  () => [\n    401,\n    \"The super secret admin key must be provided.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst ExpectedInternalProject = createKnownErrorConstructor(\n  ProjectAuthenticationError,\n  \"EXPECTED_INTERNAL_PROJECT\",\n  () => [\n    401,\n    \"The project ID is expected to be internal.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst SessionAuthenticationError = createKnownErrorConstructor(\n  KnownError,\n  \"SESSION_AUTHENTICATION_ERROR\",\n  \"inherit\",\n  \"inherit\",\n);\n\nconst InvalidSessionAuthentication = createKnownErrorConstructor(\n  SessionAuthenticationError,\n  \"INVALID_SESSION_AUTHENTICATION\",\n  \"inherit\",\n  \"inherit\",\n);\n\nconst InvalidAccessToken = createKnownErrorConstructor(\n  InvalidSessionAuthentication,\n  \"INVALID_ACCESS_TOKEN\",\n  \"inherit\",\n  \"inherit\",\n);\n\nconst UnparsableAccessToken = createKnownErrorConstructor(\n  InvalidAccessToken,\n  \"UNPARSABLE_ACCESS_TOKEN\",\n  () => [\n    401,\n    \"Access token is not parsable.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst AccessTokenExpired = createKnownErrorConstructor(\n  InvalidAccessToken,\n  \"ACCESS_TOKEN_EXPIRED\",\n  (expiredAt: Date | undefined) => [\n    401,\n    `Access token has expired. Please refresh it and try again.${expiredAt ? ` (The access token expired at ${expiredAt.toISOString()}.)` : \"\"}`,\n    { expired_at_millis: expiredAt?.getTime() ?? null },\n  ] as const,\n  (json: any) => [json.expired_at_millis ? new Date(json.expired_at_millis) : undefined] as const,\n);\n\nconst InvalidProjectForAccessToken = createKnownErrorConstructor(\n  InvalidAccessToken,\n  \"INVALID_PROJECT_FOR_ACCESS_TOKEN\",\n  (expectedProjectId: string, actualProjectId: string) => [\n    401,\n    `Access token not valid for this project. Expected project ID ${JSON.stringify(expectedProjectId)}, but the token is for project ID ${JSON.stringify(actualProjectId)}.`,\n    {\n      expected_project_id: expectedProjectId,\n      actual_project_id: actualProjectId,\n    },\n  ] as const,\n  (json: any) => [json.expected_project_id, json.actual_project_id] as const,\n);\n\n\nconst RefreshTokenError = createKnownErrorConstructor(\n  KnownError,\n  \"REFRESH_TOKEN_ERROR\",\n  \"inherit\",\n  \"inherit\",\n);\n\nconst RefreshTokenNotFoundOrExpired = createKnownErrorConstructor(\n  RefreshTokenError,\n  \"REFRESH_TOKEN_NOT_FOUND_OR_EXPIRED\",\n  () => [\n    401,\n    \"Refresh token not found for this project, or the session has expired/been revoked.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst CannotDeleteCurrentSession = createKnownErrorConstructor(\n  RefreshTokenError,\n  \"CANNOT_DELETE_CURRENT_SESSION\",\n  () => [\n    400,\n    \"Cannot delete the current session.\",\n  ] as const,\n  () => [] as const,\n);\n\n\nconst ProviderRejected = createKnownErrorConstructor(\n  RefreshTokenError,\n  \"PROVIDER_REJECTED\",\n  () => [\n    401,\n    \"The provider refused to refresh their token. This usually means that the provider used to authenticate the user no longer regards this session as valid, and the user must re-authenticate.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst UserWithEmailAlreadyExists = createKnownErrorConstructor(\n  KnownError,\n  \"USER_EMAIL_ALREADY_EXISTS\",\n  (email: string, wouldWorkIfEmailWasVerified: boolean = false) => [\n    409,\n    `A user with email ${JSON.stringify(email)} already exists${wouldWorkIfEmailWasVerified ? \" but the email is not verified. Please login to your existing account with the method you used to sign up, and then verify your email to sign in with this login method.\" : \".\"}`,\n    {\n      email,\n      would_work_if_email_was_verified: wouldWorkIfEmailWasVerified,\n    },\n  ] as const,\n  (json: any) => [json.email, json.would_work_if_email_was_verified ?? false] as const,\n);\n\nconst EmailNotVerified = createKnownErrorConstructor(\n  KnownError,\n  \"EMAIL_NOT_VERIFIED\",\n  () => [\n    400,\n    \"The email is not verified.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst CannotGetOwnUserWithoutUser = createKnownErrorConstructor(\n  KnownError,\n  \"CANNOT_GET_OWN_USER_WITHOUT_USER\",\n  () => [\n    400,\n    \"You have specified 'me' as a userId, but did not provide authentication for a user.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst UserIdDoesNotExist = createKnownErrorConstructor(\n  KnownError,\n  \"USER_ID_DOES_NOT_EXIST\",\n  (userId: string) => [\n    400,\n    `The given user with the ID ${userId} does not exist.`,\n    {\n      user_id: userId,\n    },\n  ] as const,\n  (json: any) => [json.user_id] as const,\n);\n\nconst UserNotFound = createKnownErrorConstructor(\n  KnownError,\n  \"USER_NOT_FOUND\",\n  () => [\n    404,\n    \"User not found.\",\n  ] as const,\n  () => [] as const,\n);\n\n\nconst ProjectNotFound = createKnownErrorConstructor(\n  KnownError,\n  \"PROJECT_NOT_FOUND\",\n  (projectId: string) => {\n    if (typeof projectId !== \"string\") throw new StackAssertionError(\"projectId of KnownErrors.ProjectNotFound must be a string\");\n    return [\n      404,\n      `Project ${projectId} not found or is not accessible with the current user.`,\n      {\n        project_id: projectId,\n      },\n    ] as const;\n  },\n  (json: any) => [json.project_id] as const,\n);\n\nconst CurrentProjectNotFound = createKnownErrorConstructor(\n  KnownError,\n  \"CURRENT_PROJECT_NOT_FOUND\",\n  (projectId: string) => [\n    400,\n    `The current project with ID ${projectId} was not found. Please check the value of the x-stack-project-id header.`,\n    {\n      project_id: projectId,\n    },\n  ] as const,\n  (json: any) => [json.project_id] as const,\n);\n\nconst BranchDoesNotExist = createKnownErrorConstructor(\n  KnownError,\n  \"BRANCH_DOES_NOT_EXIST\",\n  (branchId: string) => [\n    400,\n    `The branch with ID ${branchId} does not exist.`,\n    {\n      branch_id: branchId,\n    },\n  ] as const,\n  (json: any) => [json.branch_id] as const,\n);\n\n\nconst SignUpNotEnabled = createKnownErrorConstructor(\n  KnownError,\n  \"SIGN_UP_NOT_ENABLED\",\n  () => [\n    400,\n    \"Creation of new accounts is not enabled for this project. Please ask the project owner to enable it.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst PasswordAuthenticationNotEnabled = createKnownErrorConstructor(\n  KnownError,\n  \"PASSWORD_AUTHENTICATION_NOT_ENABLED\",\n  () => [\n    400,\n    \"Password authentication is not enabled for this project.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst DataVaultStoreDoesNotExist = createKnownErrorConstructor(\n  KnownError,\n  \"DATA_VAULT_STORE_DOES_NOT_EXIST\",\n  (storeId: string) => [\n    400,\n    `Data vault store with ID ${storeId} does not exist.`,\n    {\n      store_id: storeId,\n    },\n  ] as const,\n  (json: any) => [json.store_id] as const,\n);\n\nconst DataVaultStoreHashedKeyDoesNotExist = createKnownErrorConstructor(\n  KnownError,\n  \"DATA_VAULT_STORE_HASHED_KEY_DOES_NOT_EXIST\",\n  (storeId: string, hashedKey: string) => [\n    400,\n    `Data vault store with ID ${storeId} does not contain a key with hash ${hashedKey}.`,\n    {\n      store_id: storeId,\n      hashed_key: hashedKey,\n    },\n  ] as const,\n  (json: any) => [json.store_id, json.hashed_key] as const,\n);\n\nconst PasskeyAuthenticationNotEnabled = createKnownErrorConstructor(\n  KnownError,\n  \"PASSKEY_AUTHENTICATION_NOT_ENABLED\",\n  () => [\n    400,\n    \"Passkey authentication is not enabled for this project.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst AnonymousAccountsNotEnabled = createKnownErrorConstructor(\n  KnownError,\n  \"ANONYMOUS_ACCOUNTS_NOT_ENABLED\",\n  () => [\n    400,\n    \"Anonymous accounts are not enabled for this project.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst AnonymousAuthenticationNotAllowed = createKnownErrorConstructor(\n  KnownError,\n  \"ANONYMOUS_AUTHENTICATION_NOT_ALLOWED\",\n  () => [\n    401,\n    \"X-Stack-Access-Token is for an anonymous user, but anonymous users are not enabled. Set the X-Stack-Allow-Anonymous-User header of this request to 'true' to allow anonymous users.\",\n  ] as const,\n  () => [] as const,\n);\n\n\nconst EmailPasswordMismatch = createKnownErrorConstructor(\n  KnownError,\n  \"EMAIL_PASSWORD_MISMATCH\",\n  () => [\n    400,\n    \"Wrong e-mail or password.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst RedirectUrlNotWhitelisted = createKnownErrorConstructor(\n  KnownError,\n  \"REDIRECT_URL_NOT_WHITELISTED\",\n  () => [\n    400,\n    \"Redirect URL not whitelisted. Did you forget to add this domain to the trusted domains list on the Stack Auth dashboard?\",\n  ] as const,\n  () => [] as const,\n);\n\nconst PasswordRequirementsNotMet = createKnownErrorConstructor(\n  KnownError,\n  \"PASSWORD_REQUIREMENTS_NOT_MET\",\n  \"inherit\",\n  \"inherit\",\n);\n\nconst PasswordTooShort = createKnownErrorConstructor(\n  PasswordRequirementsNotMet,\n  \"PASSWORD_TOO_SHORT\",\n  (minLength: number) => [\n    400,\n    `Password too short. Minimum length is ${minLength}.`,\n    {\n      min_length: minLength,\n    },\n  ] as const,\n  (json) => [\n    (json as any)?.min_length ?? throwErr(\"min_length not found in PasswordTooShort details\"),\n  ] as const,\n);\n\nconst PasswordTooLong = createKnownErrorConstructor(\n  PasswordRequirementsNotMet,\n  \"PASSWORD_TOO_LONG\",\n  (maxLength: number) => [\n    400,\n    `Password too long. Maximum length is ${maxLength}.`,\n    {\n      maxLength,\n    },\n  ] as const,\n  (json) => [\n    (json as any)?.maxLength ?? throwErr(\"maxLength not found in PasswordTooLong details\"),\n  ] as const,\n);\n\nconst UserDoesNotHavePassword = createKnownErrorConstructor(\n  KnownError,\n  \"USER_DOES_NOT_HAVE_PASSWORD\",\n  () => [\n    400,\n    \"This user does not have password authentication enabled.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst VerificationCodeError = createKnownErrorConstructor(\n  KnownError,\n  \"VERIFICATION_ERROR\",\n  \"inherit\",\n  \"inherit\",\n);\n\nconst VerificationCodeNotFound = createKnownErrorConstructor(\n  VerificationCodeError,\n  \"VERIFICATION_CODE_NOT_FOUND\",\n  () => [\n    404,\n    \"The verification code does not exist for this project.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst VerificationCodeExpired = createKnownErrorConstructor(\n  VerificationCodeError,\n  \"VERIFICATION_CODE_EXPIRED\",\n  () => [\n    400,\n    \"The verification code has expired.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst VerificationCodeAlreadyUsed = createKnownErrorConstructor(\n  VerificationCodeError,\n  \"VERIFICATION_CODE_ALREADY_USED\",\n  () => [\n    409,\n    \"The verification link has already been used.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst VerificationCodeMaxAttemptsReached = createKnownErrorConstructor(\n  VerificationCodeError,\n  \"VERIFICATION_CODE_MAX_ATTEMPTS_REACHED\",\n  () => [\n    400,\n    \"The verification code nonce has reached the maximum number of attempts. This code is not valid anymore.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst PasswordConfirmationMismatch = createKnownErrorConstructor(\n  KnownError,\n  \"PASSWORD_CONFIRMATION_MISMATCH\",\n  () => [\n    400,\n    \"Passwords do not match.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst EmailAlreadyVerified = createKnownErrorConstructor(\n  KnownError,\n  \"EMAIL_ALREADY_VERIFIED\",\n  () => [\n    409,\n    \"The e-mail is already verified.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst EmailNotAssociatedWithUser = createKnownErrorConstructor(\n  KnownError,\n  \"EMAIL_NOT_ASSOCIATED_WITH_USER\",\n  () => [\n    400,\n    \"The e-mail is not associated with a user that could log in with that e-mail.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst EmailIsNotPrimaryEmail = createKnownErrorConstructor(\n  KnownError,\n  \"EMAIL_IS_NOT_PRIMARY_EMAIL\",\n  (email: string, primaryEmail: string | null) => [\n    400,\n    `The given e-mail (${email}) must equal the user's primary e-mail (${primaryEmail}).`,\n    {\n      email,\n      primary_email: primaryEmail,\n    },\n  ] as const,\n  (json: any) => [json.email, json.primary_email] as const,\n);\n\n\nconst PasskeyRegistrationFailed = createKnownErrorConstructor(\n  KnownError,\n  \"PASSKEY_REGISTRATION_FAILED\",\n  (message: string) => [\n    400,\n    message,\n  ] as const,\n  (json: any) => [json.message] as const,\n);\n\n\nconst PasskeyWebAuthnError = createKnownErrorConstructor(\n  KnownError,\n  \"PASSKEY_WEBAUTHN_ERROR\",\n  (message: string, code: string) => [\n    400,\n    message,\n    {\n      message,\n      code,\n    },\n  ] as const,\n  (json: any) => [json.message, json.code] as const,\n);\n\nconst PasskeyAuthenticationFailed = createKnownErrorConstructor(\n  KnownError,\n  \"PASSKEY_AUTHENTICATION_FAILED\",\n  (message: string) => [\n    400,\n    message,\n  ] as const,\n  (json: any) => [json.message] as const,\n);\n\n\nconst PermissionNotFound = createKnownErrorConstructor(\n  KnownError,\n  \"PERMISSION_NOT_FOUND\",\n  (permissionId: string) => [\n    404,\n    `Permission \"${permissionId}\" not found. Make sure you created it on the dashboard.`,\n    {\n      permission_id: permissionId,\n    },\n  ] as const,\n  (json: any) => [json.permission_id] as const,\n);\n\nconst PermissionScopeMismatch = createKnownErrorConstructor(\n  KnownError,\n  \"WRONG_PERMISSION_SCOPE\",\n  (permissionId: string, expectedScope: \"team\" | \"project\", actualScope: \"team\" | \"project\" | null) => [\n    404,\n    `Permission ${JSON.stringify(permissionId)} not found. (It was found for a different scope ${JSON.stringify(actualScope)}, but scope ${JSON.stringify(expectedScope)} was expected.)`,\n    {\n      permission_id: permissionId,\n      expected_scope: expectedScope,\n      actual_scope: actualScope,\n    },\n  ] as const,\n  (json: any) => [json.permission_id, json.expected_scope, json.actual_scope] as const,\n);\n\nconst ContainedPermissionNotFound = createKnownErrorConstructor(\n  KnownError,\n  \"CONTAINED_PERMISSION_NOT_FOUND\",\n  (permissionId: string) => [\n    400,\n    `Contained permission with ID \"${permissionId}\" not found. Make sure you created it on the dashboard.`,\n    {\n      permission_id: permissionId,\n    },\n  ] as const,\n  (json: any) => [json.permission_id] as const,\n);\n\nconst TeamNotFound = createKnownErrorConstructor(\n  KnownError,\n  \"TEAM_NOT_FOUND\",\n  (teamId: string) => [\n    404,\n    `Team ${teamId} not found.`,\n    {\n      team_id: teamId,\n    },\n  ] as const,\n  (json: any) => [json.team_id] as const,\n);\n\nconst TeamAlreadyExists = createKnownErrorConstructor(\n  KnownError,\n  \"TEAM_ALREADY_EXISTS\",\n  (teamId: string) => [\n    409,\n    `Team ${teamId} already exists.`,\n    {\n      team_id: teamId,\n    },\n  ] as const,\n  (json: any) => [json.team_id] as const,\n);\n\nconst TeamMembershipNotFound = createKnownErrorConstructor(\n  KnownError,\n  \"TEAM_MEMBERSHIP_NOT_FOUND\",\n  (teamId: string, userId: string) => [\n    404,\n    `User ${userId} is not found in team ${teamId}.`,\n    {\n      team_id: teamId,\n      user_id: userId,\n    },\n  ] as const,\n  (json: any) => [json.team_id, json.user_id] as const,\n);\n\n\nconst EmailTemplateAlreadyExists = createKnownErrorConstructor(\n  KnownError,\n  \"EMAIL_TEMPLATE_ALREADY_EXISTS\",\n  () => [\n    409,\n    \"Email template already exists.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst OAuthConnectionNotConnectedToUser = createKnownErrorConstructor(\n  KnownError,\n  \"OAUTH_CONNECTION_NOT_CONNECTED_TO_USER\",\n  () => [\n    400,\n    \"The OAuth connection is not connected to any user.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst OAuthConnectionAlreadyConnectedToAnotherUser = createKnownErrorConstructor(\n  KnownError,\n  \"OAUTH_CONNECTION_ALREADY_CONNECTED_TO_ANOTHER_USER\",\n  () => [\n    409,\n    \"The OAuth connection is already connected to another user.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst OAuthConnectionDoesNotHaveRequiredScope = createKnownErrorConstructor(\n  KnownError,\n  \"OAUTH_CONNECTION_DOES_NOT_HAVE_REQUIRED_SCOPE\",\n  () => [\n    400,\n    \"The OAuth connection does not have the required scope.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst OAuthExtraScopeNotAvailableWithSharedOAuthKeys = createKnownErrorConstructor(\n  KnownError,\n  \"OAUTH_EXTRA_SCOPE_NOT_AVAILABLE_WITH_SHARED_OAUTH_KEYS\",\n  () => [\n    400,\n    \"Extra scopes are not available with shared OAuth keys. Please add your own OAuth keys on the Stack dashboard to use extra scopes.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst OAuthAccessTokenNotAvailableWithSharedOAuthKeys = createKnownErrorConstructor(\n  KnownError,\n  \"OAUTH_ACCESS_TOKEN_NOT_AVAILABLE_WITH_SHARED_OAUTH_KEYS\",\n  () => [\n    400,\n    \"Access tokens are not available with shared OAuth keys. Please add your own OAuth keys on the Stack dashboard to use access tokens.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst InvalidOAuthClientIdOrSecret = createKnownErrorConstructor(\n  KnownError,\n  \"INVALID_OAUTH_CLIENT_ID_OR_SECRET\",\n  (clientId?: string) => [\n    400,\n    \"The OAuth client ID or secret is invalid. The client ID must be equal to the project ID (potentially with a hash and a branch ID), and the client secret must be a publishable client key.\",\n    {\n      client_id: clientId ?? null,\n    },\n  ] as const,\n  (json: any) => [json.client_id ?? undefined] as const,\n);\n\nconst InvalidScope = createKnownErrorConstructor(\n  KnownError,\n  \"INVALID_SCOPE\",\n  (scope: string) => [\n    400,\n    `The scope \"${scope}\" is not a valid OAuth scope for Stack.`,\n  ] as const,\n  (json: any) => [json.scope] as const,\n);\n\nconst UserAlreadyConnectedToAnotherOAuthConnection = createKnownErrorConstructor(\n  KnownError,\n  \"USER_ALREADY_CONNECTED_TO_ANOTHER_OAUTH_CONNECTION\",\n  () => [\n    409,\n    \"The user is already connected to another OAuth account. Did you maybe selected the wrong account?\",\n  ] as const,\n  () => [] as const,\n);\n\nconst OuterOAuthTimeout = createKnownErrorConstructor(\n  KnownError,\n  \"OUTER_OAUTH_TIMEOUT\",\n  () => [\n    408,\n    \"The OAuth flow has timed out. Please sign in again.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst OAuthProviderNotFoundOrNotEnabled = createKnownErrorConstructor(\n  KnownError,\n  \"OAUTH_PROVIDER_NOT_FOUND_OR_NOT_ENABLED\",\n  () => [\n    400,\n    \"The OAuth provider is not found or not enabled.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst OAuthProviderAccountIdAlreadyUsedForSignIn = createKnownErrorConstructor(\n  KnownError,\n  \"OAUTH_PROVIDER_ACCOUNT_ID_ALREADY_USED_FOR_SIGN_IN\",\n  () => [\n    400,\n    `A provider with the same account ID is already used for signing in.`,\n  ] as const,\n  () => [] as const,\n);\n\nconst MultiFactorAuthenticationRequired = createKnownErrorConstructor(\n  KnownError,\n  \"MULTI_FACTOR_AUTHENTICATION_REQUIRED\",\n  (attemptCode: string) => [\n    400,\n    `Multi-factor authentication is required for this user.`,\n    {\n      attempt_code: attemptCode,\n    },\n  ] as const,\n  (json) => [json.attempt_code] as const,\n);\n\nconst InvalidTotpCode = createKnownErrorConstructor(\n  KnownError,\n  \"INVALID_TOTP_CODE\",\n  () => [\n    400,\n    \"The TOTP code is invalid. Please try again.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst UserAuthenticationRequired = createKnownErrorConstructor(\n  KnownError,\n  \"USER_AUTHENTICATION_REQUIRED\",\n  () => [\n    401,\n    \"User authentication required for this endpoint.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst TeamMembershipAlreadyExists = createKnownErrorConstructor(\n  KnownError,\n  \"TEAM_MEMBERSHIP_ALREADY_EXISTS\",\n  () => [\n    409,\n    \"Team membership already exists.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst ProjectPermissionRequired = createKnownErrorConstructor(\n  KnownError,\n  \"PROJECT_PERMISSION_REQUIRED\",\n  (userId, permissionId) => [\n    401,\n    `User ${userId} does not have permission ${permissionId}.`,\n    {\n      user_id: userId,\n      permission_id: permissionId,\n    },\n  ] as const,\n  (json) => [json.user_id, json.permission_id] as const,\n);\n\nconst TeamPermissionRequired = createKnownErrorConstructor(\n  KnownError,\n  \"TEAM_PERMISSION_REQUIRED\",\n  (teamId, userId, permissionId) => [\n    401,\n    `User ${userId} does not have permission ${permissionId} in team ${teamId}.`,\n    {\n      team_id: teamId,\n      user_id: userId,\n      permission_id: permissionId,\n    },\n  ] as const,\n  (json) => [json.team_id, json.user_id, json.permission_id] as const,\n);\n\nconst TeamPermissionNotFound = createKnownErrorConstructor(\n  KnownError,\n  \"TEAM_PERMISSION_NOT_FOUND\",\n  (teamId, userId, permissionId) => [\n    401,\n    `User ${userId} does not have permission ${permissionId} in team ${teamId}.`,\n    {\n      team_id: teamId,\n      user_id: userId,\n      permission_id: permissionId,\n    },\n  ] as const,\n  (json) => [json.team_id, json.user_id, json.permission_id] as const,\n);\n\nconst InvalidSharedOAuthProviderId = createKnownErrorConstructor(\n  KnownError,\n  \"INVALID_SHARED_OAUTH_PROVIDER_ID\",\n  (providerId) => [\n    400,\n    `The shared OAuth provider with ID ${providerId} is not valid.`,\n    {\n      provider_id: providerId,\n    },\n  ] as const,\n  (json) => [json.provider_id] as const,\n);\n\nconst InvalidStandardOAuthProviderId = createKnownErrorConstructor(\n  KnownError,\n  \"INVALID_STANDARD_OAUTH_PROVIDER_ID\",\n  (providerId) => [\n    400,\n    `The standard OAuth provider with ID ${providerId} is not valid.`,\n    {\n      provider_id: providerId,\n    },\n  ] as const,\n  (json) => [json.provider_id] as const,\n);\n\nconst InvalidAuthorizationCode = createKnownErrorConstructor(\n  KnownError,\n  \"INVALID_AUTHORIZATION_CODE\",\n  () => [\n    400,\n    \"The given authorization code is invalid.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst OAuthProviderAccessDenied = createKnownErrorConstructor(\n  KnownError,\n  \"OAUTH_PROVIDER_ACCESS_DENIED\",\n  () => [\n    400,\n    \"The OAuth provider denied access to the user.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst ContactChannelAlreadyUsedForAuthBySomeoneElse = createKnownErrorConstructor(\n  KnownError,\n  \"CONTACT_CHANNEL_ALREADY_USED_FOR_AUTH_BY_SOMEONE_ELSE\",\n  (type: \"email\", contactChannelValue?: string, wouldWorkIfEmailWasVerified: boolean = false) => [\n    409,\n    `This ${type} ${contactChannelValue ? `\"(${contactChannelValue})\"` : \"\"} is already used for authentication by another account${wouldWorkIfEmailWasVerified ? \" but the email is not verified. Please login to your existing account with the method you used to sign up, and then verify your email to sign in with this login method.\" : \".\"}`,\n    {\n      type,\n      contact_channel_value: contactChannelValue ?? null,\n      would_work_if_email_was_verified: wouldWorkIfEmailWasVerified,\n    },\n  ] as const,\n  (json) => [json.type, json.contact_channel_value, json.would_work_if_email_was_verified ?? false] as const,\n);\n\nconst InvalidPollingCodeError = createKnownErrorConstructor(\n  KnownError,\n  \"INVALID_POLLING_CODE\",\n  (details?: Json) => [\n    400,\n    \"The polling code is invalid or does not exist.\",\n    details,\n  ] as const,\n  (json: any) => [json] as const,\n);\n\nconst CliAuthError = createKnownErrorConstructor(\n  KnownError,\n  \"CLI_AUTH_ERROR\",\n  (message: string) => [\n    400,\n    message,\n  ] as const,\n  (json: any) => [json.message] as const,\n);\n\nconst CliAuthExpiredError = createKnownErrorConstructor(\n  KnownError,\n  \"CLI_AUTH_EXPIRED_ERROR\",\n  (message: string = \"CLI authentication request expired. Please try again.\") => [\n    400,\n    message,\n  ] as const,\n  (json: any) => [json.message] as const,\n);\n\nconst CliAuthUsedError = createKnownErrorConstructor(\n  KnownError,\n  \"CLI_AUTH_USED_ERROR\",\n  (message: string = \"This authentication token has already been used.\") => [\n    400,\n    message,\n  ] as const,\n  (json: any) => [json.message] as const,\n);\n\n\nconst ApiKeyNotValid = createKnownErrorConstructor(\n  KnownError,\n  \"API_KEY_NOT_VALID\",\n  \"inherit\",\n  \"inherit\",\n);\n\nconst ApiKeyExpired = createKnownErrorConstructor(\n  ApiKeyNotValid,\n  \"API_KEY_EXPIRED\",\n  () => [\n    401,\n    \"API key has expired.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst ApiKeyRevoked = createKnownErrorConstructor(\n  ApiKeyNotValid,\n  \"API_KEY_REVOKED\",\n  () => [\n    401,\n    \"API key has been revoked.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst WrongApiKeyType = createKnownErrorConstructor(\n  ApiKeyNotValid,\n  \"WRONG_API_KEY_TYPE\",\n  (expectedType: string, actualType: string) => [\n    400,\n    `This endpoint is for ${expectedType} API keys, but a ${actualType} API key was provided.`,\n    { expected_type: expectedType, actual_type: actualType },\n  ] as const,\n  (json) => [json.expected_type, json.actual_type] as const,\n);\n\nconst ApiKeyNotFound = createKnownErrorConstructor(\n  ApiKeyNotValid,\n  \"API_KEY_NOT_FOUND\",\n  () => [\n    404,\n    \"API key not found.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst PublicApiKeyCannotBeRevoked = createKnownErrorConstructor(\n  ApiKeyNotValid,\n  \"PUBLIC_API_KEY_CANNOT_BE_REVOKED\",\n  () => [\n    400,\n    \"Public API keys cannot be revoked by the secretscanner endpoint.\",\n  ] as const,\n  () => [] as const,\n);\n\nconst PermissionIdAlreadyExists = createKnownErrorConstructor(\n  KnownError,\n  \"PERMISSION_ID_ALREADY_EXISTS\",\n  (permissionId: string) => [\n    400,\n    `Permission with ID \"${permissionId}\" already exists. Choose a different ID.`,\n    {\n      permission_id: permissionId,\n    },\n  ] as const,\n  (json: any) => [json.permission_id] as const,\n);\n\nconst EmailRenderingError = createKnownErrorConstructor(\n  KnownError,\n  \"EMAIL_RENDERING_ERROR\",\n  (error: string) => [\n    400,\n    `Failed to render email with theme: ${error}`,\n    { error },\n  ] as const,\n  (json: any) => [json.error] as const,\n);\n\nconst RequiresCustomEmailServer = createKnownErrorConstructor(\n  KnownError,\n  \"REQUIRES_CUSTOM_EMAIL_SERVER\",\n  () => [\n    400,\n    `This action requires a custom SMTP server. Please edit your email server configuration and try again.`,\n  ] as const,\n  () => [] as const,\n);\n\nconst ItemNotFound = createKnownErrorConstructor(\n  KnownError,\n  \"ITEM_NOT_FOUND\",\n  (itemId: string) => [\n    404,\n    `Item with ID \"${itemId}\" not found.`,\n    {\n      item_id: itemId,\n    },\n  ] as const,\n  (json) => [json.item_id] as const,\n);\n\nconst ItemCustomerTypeDoesNotMatch = createKnownErrorConstructor(\n  KnownError,\n  \"ITEM_CUSTOMER_TYPE_DOES_NOT_MATCH\",\n  (itemId: string, customerId: string, itemCustomerType: \"user\" | \"team\" | \"custom\" | undefined, actualCustomerType: \"user\" | \"team\" | \"custom\") => [\n    400,\n    `The ${actualCustomerType} with ID ${JSON.stringify(customerId)} is not a valid customer for the item with ID ${JSON.stringify(itemId)}. ${itemCustomerType ? `The item is configured to only be available for ${itemCustomerType} customers, but the customer is a ${actualCustomerType}.` : `The item is missing a customer type field. Please make sure it is set up correctly in your project configuration.`}`,\n    {\n      item_id: itemId,\n      customer_id: customerId,\n      item_customer_type: itemCustomerType ?? null,\n      actual_customer_type: actualCustomerType,\n    },\n  ] as const,\n  (json) => [json.item_id, json.customer_id, json.item_customer_type ?? undefined, json.actual_customer_type] as const,\n);\n\nconst CustomerDoesNotExist = createKnownErrorConstructor(\n  KnownError,\n  \"CUSTOMER_DOES_NOT_EXIST\",\n  (customerId: string) => [\n    400,\n    `Customer with ID ${JSON.stringify(customerId)} does not exist.`,\n    {\n      customer_id: customerId,\n    },\n  ] as const,\n  (json) => [json.customer_id] as const,\n);\n\nconst SubscriptionInvoiceNotFound = createKnownErrorConstructor(\n  KnownError,\n  \"SUBSCRIPTION_INVOICE_NOT_FOUND\",\n  (subscriptionInvoiceId: string) => [\n    404,\n    `Subscription invoice with ID ${JSON.stringify(subscriptionInvoiceId)} does not exist.`,\n    {\n      subscription_invoice_id: subscriptionInvoiceId,\n    },\n  ] as const,\n  (json) => [json.subscription_invoice_id] as const,\n);\n\nconst OneTimePurchaseNotFound = createKnownErrorConstructor(\n  KnownError,\n  \"ONE_TIME_PURCHASE_NOT_FOUND\",\n  (purchaseId: string) => [\n    404,\n    `One-time purchase with ID ${JSON.stringify(purchaseId)} does not exist.`,\n    {\n      one_time_purchase_id: purchaseId,\n    },\n  ] as const,\n  (json) => [json.one_time_purchase_id] as const,\n);\n\nconst SubscriptionAlreadyRefunded = createKnownErrorConstructor(\n  KnownError,\n  \"SUBSCRIPTION_ALREADY_REFUNDED\",\n  (subscriptionId: string) => [\n    400,\n    `Subscription with ID ${JSON.stringify(subscriptionId)} was already refunded.`,\n    {\n      subscription_id: subscriptionId,\n    },\n  ] as const,\n  (json) => [json.subscription_id] as const,\n);\n\nconst OneTimePurchaseAlreadyRefunded = createKnownErrorConstructor(\n  KnownError,\n  \"ONE_TIME_PURCHASE_ALREADY_REFUNDED\",\n  (purchaseId: string) => [\n    400,\n    `One-time purchase with ID ${JSON.stringify(purchaseId)} was already refunded.`,\n    {\n      one_time_purchase_id: purchaseId,\n    },\n  ] as const,\n  (json) => [json.one_time_purchase_id] as const,\n);\n\nconst TestModePurchaseNonRefundable = createKnownErrorConstructor(\n  KnownError,\n  \"TEST_MODE_PURCHASE_NON_REFUNDABLE\",\n  () => [\n    400,\n    \"Test mode purchases are not refundable.\",\n  ] as const,\n  () => [] as const,\n);\n\n\nconst ProductDoesNotExist = createKnownErrorConstructor(\n  KnownError,\n  \"PRODUCT_DOES_NOT_EXIST\",\n  (productId: string, context: \"item_exists\" | \"server_only\" | null) => [\n    400,\n    `Product with ID ${JSON.stringify(productId)} ${context === \"server_only\"\n      ? \"is marked as server-only and cannot be accessed client side.\"\n      : context === \"item_exists\"\n        ? \"does not exist, but an item with this ID exists.\"\n        : \"does not exist.\"\n    }`,\n    {\n      product_id: productId,\n      context,\n    } as const,\n  ] as const,\n  (json) => [json.product_id, json.context] as const,\n);\n\nconst ProductCustomerTypeDoesNotMatch = createKnownErrorConstructor(\n  KnownError,\n  \"PRODUCT_CUSTOMER_TYPE_DOES_NOT_MATCH\",\n  (productId: string | undefined, customerId: string, productCustomerType: \"user\" | \"team\" | \"custom\" | undefined, actualCustomerType: \"user\" | \"team\" | \"custom\") => [\n    400,\n    `The ${actualCustomerType} with ID ${JSON.stringify(customerId)} is not a valid customer for the inline product that has been passed in. ${productCustomerType ? `The product is configured to only be available for ${productCustomerType} customers, but the customer is a ${actualCustomerType}.` : `The product is missing a customer type field. Please make sure it is set up correctly in your project configuration.`}`,\n    {\n      product_id: productId ?? null,\n      customer_id: customerId,\n      product_customer_type: productCustomerType ?? null,\n      actual_customer_type: actualCustomerType,\n    },\n  ] as const,\n  (json) => [json.product_id ?? undefined, json.customer_id, json.product_customer_type ?? undefined, json.actual_customer_type] as const,\n);\n\nconst ProductAlreadyGranted = createKnownErrorConstructor(\n  KnownError,\n  \"PRODUCT_ALREADY_GRANTED\",\n  (productId: string, customerId: string) => [\n    400,\n    `Customer with ID ${JSON.stringify(customerId)} already owns product ${JSON.stringify(productId)}.`,\n    {\n      product_id: productId,\n      customer_id: customerId,\n    },\n  ] as const,\n  (json) => [json.product_id, json.customer_id] as const,\n);\n\nconst ItemQuantityInsufficientAmount = createKnownErrorConstructor(\n  KnownError,\n  \"ITEM_QUANTITY_INSUFFICIENT_AMOUNT\",\n  (itemId: string, customerId: string, quantity: number) => [\n    400,\n    `The item with ID ${JSON.stringify(itemId)} has an insufficient quantity for the customer with ID ${JSON.stringify(customerId)}. An attempt was made to charge ${quantity} credits.`,\n    {\n      item_id: itemId,\n      customer_id: customerId,\n      quantity,\n    },\n  ] as const,\n  (json) => [json.item_id, json.customer_id, json.quantity] as const,\n);\n\nconst StripeAccountInfoNotFound = createKnownErrorConstructor(\n  KnownError,\n  \"STRIPE_ACCOUNT_INFO_NOT_FOUND\",\n  () => [\n    404,\n    \"Stripe account information not found. Please make sure the user has onboarded with Stripe.\",\n  ] as const,\n  () => [] as const,\n);\n\nexport type KnownErrors = {\n  [K in keyof typeof KnownErrors]: InstanceType<typeof KnownErrors[K]>;\n};\n\nexport const KnownErrors = {\n  CannotDeleteCurrentSession,\n  UnsupportedError,\n  BodyParsingError,\n  SchemaError,\n  AllOverloadsFailed,\n  ProjectAuthenticationError,\n  PermissionIdAlreadyExists,\n  CliAuthError,\n  CliAuthExpiredError,\n  CliAuthUsedError,\n  InvalidProjectAuthentication,\n  ProjectKeyWithoutAccessType,\n  InvalidAccessType,\n  AccessTypeWithoutProjectId,\n  AccessTypeRequired,\n  CannotGetOwnUserWithoutUser,\n  InsufficientAccessType,\n  InvalidPublishableClientKey,\n  InvalidSecretServerKey,\n  InvalidSuperSecretAdminKey,\n  InvalidAdminAccessToken,\n  UnparsableAdminAccessToken,\n  AdminAccessTokenExpired,\n  InvalidProjectForAdminAccessToken,\n  AdminAccessTokenIsNotAdmin,\n  ProjectAuthenticationRequired,\n  ClientAuthenticationRequired,\n  ServerAuthenticationRequired,\n  ClientOrServerAuthenticationRequired,\n  ClientOrAdminAuthenticationRequired,\n  ClientOrServerOrAdminAuthenticationRequired,\n  AdminAuthenticationRequired,\n  ExpectedInternalProject,\n  SessionAuthenticationError,\n  InvalidSessionAuthentication,\n  InvalidAccessToken,\n  UnparsableAccessToken,\n  AccessTokenExpired,\n  InvalidProjectForAccessToken,\n  RefreshTokenError,\n  ProviderRejected,\n  RefreshTokenNotFoundOrExpired,\n  UserWithEmailAlreadyExists,\n  EmailNotVerified,\n  UserIdDoesNotExist,\n  UserNotFound,\n  ApiKeyNotFound,\n  PublicApiKeyCannotBeRevoked,\n  ProjectNotFound,\n  CurrentProjectNotFound,\n  BranchDoesNotExist,\n  SignUpNotEnabled,\n  PasswordAuthenticationNotEnabled,\n  PasskeyAuthenticationNotEnabled,\n  AnonymousAccountsNotEnabled,\n  AnonymousAuthenticationNotAllowed,\n  EmailPasswordMismatch,\n  RedirectUrlNotWhitelisted,\n  PasswordRequirementsNotMet,\n  PasswordTooShort,\n  PasswordTooLong,\n  UserDoesNotHavePassword,\n  VerificationCodeError,\n  VerificationCodeNotFound,\n  VerificationCodeExpired,\n  VerificationCodeAlreadyUsed,\n  VerificationCodeMaxAttemptsReached,\n  PasswordConfirmationMismatch,\n  EmailAlreadyVerified,\n  EmailNotAssociatedWithUser,\n  EmailIsNotPrimaryEmail,\n  PasskeyRegistrationFailed,\n  PasskeyWebAuthnError,\n  PasskeyAuthenticationFailed,\n  PermissionNotFound,\n  PermissionScopeMismatch,\n  ContainedPermissionNotFound,\n  TeamNotFound,\n  TeamMembershipNotFound,\n  EmailTemplateAlreadyExists,\n  OAuthConnectionNotConnectedToUser,\n  OAuthConnectionAlreadyConnectedToAnotherUser,\n  OAuthConnectionDoesNotHaveRequiredScope,\n  OAuthExtraScopeNotAvailableWithSharedOAuthKeys,\n  OAuthAccessTokenNotAvailableWithSharedOAuthKeys,\n  InvalidOAuthClientIdOrSecret,\n  InvalidScope,\n  UserAlreadyConnectedToAnotherOAuthConnection,\n  OuterOAuthTimeout,\n  OAuthProviderNotFoundOrNotEnabled,\n  OAuthProviderAccountIdAlreadyUsedForSignIn,\n  MultiFactorAuthenticationRequired,\n  InvalidTotpCode,\n  UserAuthenticationRequired,\n  TeamMembershipAlreadyExists,\n  ProjectPermissionRequired,\n  TeamPermissionRequired,\n  InvalidSharedOAuthProviderId,\n  InvalidStandardOAuthProviderId,\n  InvalidAuthorizationCode,\n  TeamPermissionNotFound,\n  OAuthProviderAccessDenied,\n  ContactChannelAlreadyUsedForAuthBySomeoneElse,\n  InvalidPollingCodeError,\n  ApiKeyNotValid,\n  ApiKeyExpired,\n  ApiKeyRevoked,\n  WrongApiKeyType,\n  EmailRenderingError,\n  RequiresCustomEmailServer,\n  ItemNotFound,\n  ItemCustomerTypeDoesNotMatch,\n  CustomerDoesNotExist,\n  ProductDoesNotExist,\n  ProductCustomerTypeDoesNotMatch,\n  ProductAlreadyGranted,\n  SubscriptionInvoiceNotFound,\n  OneTimePurchaseNotFound,\n  SubscriptionAlreadyRefunded,\n  OneTimePurchaseAlreadyRefunded,\n  TestModePurchaseNonRefundable,\n  ItemQuantityInsufficientAmount,\n  StripeAccountInfoNotFound,\n  DataVaultStoreDoesNotExist,\n  DataVaultStoreHashedKeyDoesNotExist,\n} satisfies Record<string, KnownErrorConstructor<any, any>>;\n\n\n// ensure that all known error codes are unique\nconst knownErrorCodes = new Set<string>();\nfor (const [_, KnownError] of Object.entries(KnownErrors)) {\n  if (knownErrorCodes.has(KnownError.errorCode)) {\n    throw new Error(`Duplicate known error code: ${KnownError.errorCode}`);\n  }\n  knownErrorCodes.add(KnownError.errorCode);\n}\n"],"names":["KnownError"],"mappings":";;;;;;;AAAA,SAAS,qBAAqB,aAAa,gBAAgB;AAC3D,SAAS,oBAAoB;AAE7B,SAAS,gBAAgB;;;;AAqBlB,IAAe,aAAf,cAAkC,uOAAA,CAAY;IAInD,YACkB,UAAA,EACA,oBAAA,EACA,OAAA,CAChB;QACA,KAAA,CACE,YACA;QANc,IAAA,CAAA,UAAA,GAAA;QACA,IAAA,CAAA,oBAAA,GAAA;QACA,IAAA,CAAA,OAAA,GAAA;QANlB,IAAA,CAAiB,sBAAA,GAAyB;QAC1C,IAAA,CAAO,IAAA,GAAO;IAWd;IAEA,OAAc,aAAa,KAAA,EAAqC;QAE9D,OAAO,OAAO,UAAU,YAAY,UAAU,QAAQ,4BAA4B,SAAS,MAAM,sBAAA,KAA2B;IAC9H;IAEgB,UAAsB;QACpC,OAAO,IAAI,YAAY,EAAE,MAAA,CAAO,KAAK,SAAA,CAAU,IAAA,CAAK,iBAAA,CAAkB,GAAG,KAAA,GAAW,CAAC,CAAC;IACxF;IAEgB,aAAuC;QACrD,OAAO;YACL,gBAAgB;gBAAC,iCAAiC;aAAA;YAClD,uBAAuB;gBAAC,IAAA,CAAK,SAAS;aAAA;QACxC;IACF;IAEgB,oBAA0B;QACxC,OAAO;YACL,MAAM,IAAA,CAAK,SAAA;YACX,GAAG,IAAA,CAAK,OAAA,GAAU;gBAAE,SAAS,IAAA,CAAK,OAAA;YAAQ,IAAI,CAAC,CAAA;YAC/C,OAAO,IAAA,CAAK,oBAAA;QACd;IACF;IAEA,IAAI,YAAoB;QACtB,OAAQ,IAAA,CAAK,WAAA,CAAoB,SAAA,QAAa,oOAAA,EAAS,CAAA,uFAAA,EAA0F,IAAI,EAAE;IACzJ;IAEA,OAAc,wBAAwB,IAAA,EAAgE;QACpG,OAAO;YACL;YACA,KAAK,OAAA;YACL;SACF;IACF;IAEA,OAAc,SAAS,IAAA,EAAkC;QACvD,KAAA,MAAW,CAAC,GAAG,cAAc,CAAA,IAAK,OAAO,OAAA,CAAQ,WAAW,EAAG;YAC7D,IAAI,KAAK,IAAA,KAAS,eAAe,SAAA,CAAU,SAAA,EAAW;gBACpD,MAAM,kBAAkB,eAAe,uBAAA,CAAwB,IAAI;gBACnE,OAAO,IAAI,kBAEN;YAEP;QACF;QAEA,MAAM,IAAI,MAAM,CAAA,wGAAA,EAA2G,KAAK,IAAI,CAAA,EAAA,EAAK,KAAK,OAAO,EAAE;IACzJ;AACF;AAEA,IAAM,yCAAyC,OAAO,wCAAwC;AA2B9F,SAAS,4BACP,UAAA,EACA,SAAA,EACA,MAAA,EACA,uBAAA,EAC0G;IAC1G,MAAM,WAAW,WAAW,YAAY,2OAAA,GAA8B;IACtE,MAAM,4BAA4B,4BAA4B,YAAY,WAAW,uBAAA,GAAmC;IAGxH,MAAM,uBAAuB,WAAW;QAKtC,YAAA,GAAe,IAAA,CAAY;YAEzB,KAAA,CAAM,GAAG,SAAS,GAAG,IAAI,CAAC;YAL5B,IAAA,CAAO,IAAA,GAAO,CAAA,WAAA,EAAc,SAAS,CAAA,CAAA,CAAA;YAMnC,IAAA,CAAK,eAAA,GAAkB;QACzB;QAEA,OAAO,wBAAwB,IAAA,EAA4B;YACzD,OAAO,0BAA0B,KAAK,OAAO;QAC/C;QAEA,OAAO,WAAW,KAAA,EAA0E;YAC1F,IAAI,CAAC,WAAW,YAAA,CAAa,KAAK,EAAG,CAAA,OAAO;YAC5C,IAAI,UAAmB;YACvB,MAAO,KAAM;gBACX,UAAU,OAAO,cAAA,CAAe,OAAO;gBACvC,IAAI,CAAC,QAAS,CAAA;gBACd,IAAI,eAAe,QAAQ,WAAA,IAAe,QAAQ,WAAA,CAAY,SAAA,KAAc,UAAW,CAAA,OAAO;YAChG;YACA,OAAO;QACT;IACF;IAzBM,eACmB,SAAA,GAAY;;IA2BrC,OAAO;AACT;AAWA,IAAM,mBAAmB,4BACvB,YACA,qBACA,CAAC,oBAA8B;QAC7B;QACA,CAAA,iLAAA,EAAoL,iBAAiB,EAAA;QACrM;YACE;QACF;KACF,EACA,CAAC,OAAS;QACP,MAAc,yBAAqB,oOAAA,EAAS,yDAAyD;KACxG;AAGF,IAAM,mBAAmB,4BACvB,YACA,sBACA,CAAC,UAAoB;QACnB;QACA;KACF,EACA,CAAC,OAAS;QAAC,KAAK,OAAO;KAAA;AAGzB,IAAM,cAAc,4BAClB,YACA,gBACA,CAAC,UAAoB;QACnB;QACA,eAAW,oOAAA,EAAS,gCAAgC;QACpD;YACE;QACF;KACF,EACA,CAAC,OAAc;QAAC,KAAK,OAAO;KAAA;AAG9B,IAAM,qBAAqB,4BACzB,YACA,wBACA,CAAC,iBAA2B;QAC1B;QACA,qOAAA,CAAA;;;QAAA,EAGM,eAAe,GAAA,CAAI,CAAC,GAAG,IAAM,qOAAA,CAAA;mBAAA,EAClB,IAAI,CAAC,CAAA,EAAA,EAAK,KAAK,SAAA,CAAU,GAAG,KAAA,GAAW,CAAC,CAAC,CAAA;QAAA,CACrD,EAAE,IAAA,CAAK,MAAM,CAAC,CAAA;IAAA,CAAA;QAEnB;YACE,iBAAiB;QACnB;KACF,EACA,CAAC,OAAS;QACP,MAAc,uBAAmB,oOAAA,EAAS,yDAAyD;KACtG;AAGF,IAAM,6BAA6B,4BACjC,YACA,gCACA,WACA;AAGF,IAAM,+BAA+B,4BACnC,4BACA,kCACA,WACA;AAGF,IAAM,8BAA8B,4BAClC,8BACA,mCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,oBAAoB,4BACxB,8BACA,uBACA,CAAC,aAAuB;QACtB;QACA,CAAA,gFAAA,EAAmF,UAAU,CAAA,EAAA,CAAA;KAC/F,EACA,CAAC,OAAS;QACP,MAAc,kBAAc,oOAAA,EAAS,mDAAmD;KAC3F;AAGF,IAAM,6BAA6B,4BACjC,8BACA,kCACA,CAAC,aAA8C;QAC7C;QACA,qOAAA,CAAA;0CAAA,EACwC,UAAU,CAAA;;;IAAA,CAAA;QAIlD;YACE,cAAc;QAChB;KACF,EACA,CAAC,OAAc;QAAC,KAAK,YAAY;KAAA;AAGnC,IAAM,qBAAqB,4BACzB,8BACA,wBACA,IAAM;QACJ;QACA,qOAAA,CAAA;;;;IAAA,CAAA;KAKF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,yBAAyB,4BAC7B,8BACA,4BACA,CAAC,kBAAiD,qBAA0D;QAC1G;QACA,CAAA,uCAAA,EAA0C,mBAAmB,GAAA,CAAI,CAAA,IAAK,CAAA,CAAA,EAAI,CAAC,CAAA,CAAA,CAAG,EAAE,IAAA,CAAK,MAAM,CAAC,CAAA,WAAA,EAAc,gBAAgB,CAAA,EAAA,CAAA;QAC1H;YACE,oBAAoB;YACpB,sBAAsB;QACxB;KACF,EACA,CAAC,OAAc;QACb,KAAK,kBAAA;QACL,KAAK,oBAAA;KACP;AAGF,IAAM,8BAA8B,4BAClC,8BACA,kCACA,CAAC,YAAsB;QACrB;QACA,CAAA,iDAAA,EAAoD,KAAK,SAAA,CAAU,SAAS,CAAC,CAAA,wCAAA,CAAA;QAC7E;YACE,YAAY;QACd;KACF,EACA,CAAC,OAAc;QAAC,KAAK,UAAU;KAAA;AAGjC,IAAM,yBAAyB,4BAC7B,8BACA,6BACA,CAAC,YAAsB;QACrB;QACA,CAAA,mDAAA,EAAsD,KAAK,SAAA,CAAU,SAAS,CAAC,CAAA,wCAAA,CAAA;QAC/E;YACE,YAAY;QACd;KACF,EACA,CAAC,OAAc;QAAC,KAAK,UAAU;KAAA;AAGjC,IAAM,6BAA6B,4BACjC,8BACA,kCACA,CAAC,YAAsB;QACrB;QACA,CAAA,wDAAA,EAA2D,KAAK,SAAA,CAAU,SAAS,CAAC,CAAA,wCAAA,CAAA;QACpF;YACE,YAAY;QACd;KACF,EACA,CAAC,OAAc;QAAC,KAAK,UAAU;KAAA;AAGjC,IAAM,0BAA0B,4BAC9B,8BACA,8BACA,WACA;AAGF,IAAM,6BAA6B,4BACjC,yBACA,iCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,0BAA0B,4BAC9B,yBACA,8BACA,CAAC,YAAgC;QAC/B;QACA,CAAA,gEAAA,EAAmE,YAAY,CAAA,8BAAA,EAAiC,UAAU,WAAA,CAAY,CAAC,CAAA,EAAA,CAAA,GAAO,EAAE,EAAA;QAChJ;YAAE,mBAAmB,WAAW,QAAQ,KAAK;QAAK;KACpD,EACA,CAAC,OAAc;QAAC,KAAK,iBAAA,GAAoB,IAAI,KAAK,KAAK,iBAAiB,IAAI,KAAA,CAAS;KAAA;AAGvF,IAAM,oCAAoC,4BACxC,yBACA,0CACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,6BAA6B,4BACjC,yBACA,mCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAMT,IAAM,gCAAgC,4BACpC,4BACA,mCACA,WACA;AAOF,IAAM,+BAA+B,4BACnC,+BACA,kCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAMT,IAAM,+BAA+B,4BACnC,+BACA,kCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAMT,IAAM,uCAAuC,4BAC3C,+BACA,4CACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAMT,IAAM,sCAAsC,4BAC1C,+BACA,2CACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAMT,IAAM,8CAA8C,4BAClD,+BACA,qDACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAMT,IAAM,8BAA8B,4BAClC,+BACA,iCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,0BAA0B,4BAC9B,4BACA,6BACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,6BAA6B,4BACjC,YACA,gCACA,WACA;AAGF,IAAM,+BAA+B,4BACnC,4BACA,kCACA,WACA;AAGF,IAAM,qBAAqB,4BACzB,8BACA,wBACA,WACA;AAGF,IAAM,wBAAwB,4BAC5B,oBACA,2BACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,qBAAqB,4BACzB,oBACA,wBACA,CAAC,YAAgC;QAC/B;QACA,CAAA,0DAAA,EAA6D,YAAY,CAAA,8BAAA,EAAiC,UAAU,WAAA,CAAY,CAAC,CAAA,EAAA,CAAA,GAAO,EAAE,EAAA;QAC1I;YAAE,mBAAmB,WAAW,QAAQ,KAAK;QAAK;KACpD,EACA,CAAC,OAAc;QAAC,KAAK,iBAAA,GAAoB,IAAI,KAAK,KAAK,iBAAiB,IAAI,KAAA,CAAS;KAAA;AAGvF,IAAM,+BAA+B,4BACnC,oBACA,oCACA,CAAC,mBAA2B,kBAA4B;QACtD;QACA,CAAA,6DAAA,EAAgE,KAAK,SAAA,CAAU,iBAAiB,CAAC,CAAA,kCAAA,EAAqC,KAAK,SAAA,CAAU,eAAe,CAAC,CAAA,CAAA,CAAA;QACrK;YACE,qBAAqB;YACrB,mBAAmB;QACrB;KACF,EACA,CAAC,OAAc;QAAC,KAAK,mBAAA;QAAqB,KAAK,iBAAiB;KAAA;AAIlE,IAAM,oBAAoB,4BACxB,YACA,uBACA,WACA;AAGF,IAAM,gCAAgC,4BACpC,mBACA,sCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,6BAA6B,4BACjC,mBACA,iCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAIT,IAAM,mBAAmB,4BACvB,mBACA,qBACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,6BAA6B,4BACjC,YACA,6BACA,CAAC,OAAe,8BAAuC,KAAA,GAAU;QAC/D;QACA,CAAA,kBAAA,EAAqB,KAAK,SAAA,CAAU,KAAK,CAAC,CAAA,eAAA,EAAkB,8BAA8B,6KAA6K,GAAG,EAAA;QAC1Q;YACE;YACA,kCAAkC;QACpC;KACF,EACA,CAAC,OAAc;QAAC,KAAK,KAAA;QAAO,KAAK,gCAAA,IAAoC,KAAK;KAAA;AAG5E,IAAM,mBAAmB,4BACvB,YACA,sBACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,8BAA8B,4BAClC,YACA,oCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,qBAAqB,4BACzB,YACA,0BACA,CAAC,SAAmB;QAClB;QACA,CAAA,2BAAA,EAA8B,MAAM,CAAA,gBAAA,CAAA;QACpC;YACE,SAAS;QACX;KACF,EACA,CAAC,OAAc;QAAC,KAAK,OAAO;KAAA;AAG9B,IAAM,eAAe,4BACnB,YACA,kBACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAIT,IAAM,kBAAkB,4BACtB,YACA,qBACA,CAAC,cAAsB;IACrB,IAAI,OAAO,cAAc,SAAU,CAAA,MAAM,IAAI,+OAAA,CAAoB,2DAA2D;IAC5H,OAAO;QACL;QACA,CAAA,QAAA,EAAW,SAAS,CAAA,sDAAA,CAAA;QACpB;YACE,YAAY;QACd;KACF;AACF,GACA,CAAC,OAAc;QAAC,KAAK,UAAU;KAAA;AAGjC,IAAM,yBAAyB,4BAC7B,YACA,6BACA,CAAC,YAAsB;QACrB;QACA,CAAA,4BAAA,EAA+B,SAAS,CAAA,wEAAA,CAAA;QACxC;YACE,YAAY;QACd;KACF,EACA,CAAC,OAAc;QAAC,KAAK,UAAU;KAAA;AAGjC,IAAM,qBAAqB,4BACzB,YACA,yBACA,CAAC,WAAqB;QACpB;QACA,CAAA,mBAAA,EAAsB,QAAQ,CAAA,gBAAA,CAAA;QAC9B;YACE,WAAW;QACb;KACF,EACA,CAAC,OAAc;QAAC,KAAK,SAAS;KAAA;AAIhC,IAAM,mBAAmB,4BACvB,YACA,uBACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,mCAAmC,4BACvC,YACA,uCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,6BAA6B,4BACjC,YACA,mCACA,CAAC,UAAoB;QACnB;QACA,CAAA,yBAAA,EAA4B,OAAO,CAAA,gBAAA,CAAA;QACnC;YACE,UAAU;QACZ;KACF,EACA,CAAC,OAAc;QAAC,KAAK,QAAQ;KAAA;AAG/B,IAAM,sCAAsC,4BAC1C,YACA,8CACA,CAAC,SAAiB,YAAsB;QACtC;QACA,CAAA,yBAAA,EAA4B,OAAO,CAAA,kCAAA,EAAqC,SAAS,CAAA,CAAA,CAAA;QACjF;YACE,UAAU;YACV,YAAY;QACd;KACF,EACA,CAAC,OAAc;QAAC,KAAK,QAAA;QAAU,KAAK,UAAU;KAAA;AAGhD,IAAM,kCAAkC,4BACtC,YACA,sCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,8BAA8B,4BAClC,YACA,kCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,oCAAoC,4BACxC,YACA,wCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAIT,IAAM,wBAAwB,4BAC5B,YACA,2BACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,4BAA4B,4BAChC,YACA,gCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,6BAA6B,4BACjC,YACA,iCACA,WACA;AAGF,IAAM,mBAAmB,4BACvB,4BACA,sBACA,CAAC,YAAsB;QACrB;QACA,CAAA,sCAAA,EAAyC,SAAS,CAAA,CAAA,CAAA;QAClD;YACE,YAAY;QACd;KACF,EACA,CAAC,OAAS;QACP,MAAc,kBAAc,oOAAA,EAAS,kDAAkD;KAC1F;AAGF,IAAM,kBAAkB,4BACtB,4BACA,qBACA,CAAC,YAAsB;QACrB;QACA,CAAA,qCAAA,EAAwC,SAAS,CAAA,CAAA,CAAA;QACjD;YACE;QACF;KACF,EACA,CAAC,OAAS;QACP,MAAc,iBAAa,oOAAA,EAAS,gDAAgD;KACvF;AAGF,IAAM,0BAA0B,4BAC9B,YACA,+BACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,wBAAwB,4BAC5B,YACA,sBACA,WACA;AAGF,IAAM,2BAA2B,4BAC/B,uBACA,+BACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,0BAA0B,4BAC9B,uBACA,6BACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,8BAA8B,4BAClC,uBACA,kCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,qCAAqC,4BACzC,uBACA,0CACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,+BAA+B,4BACnC,YACA,kCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,uBAAuB,4BAC3B,YACA,0BACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,6BAA6B,4BACjC,YACA,kCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,yBAAyB,4BAC7B,YACA,8BACA,CAAC,OAAe,eAAgC;QAC9C;QACA,CAAA,kBAAA,EAAqB,KAAK,CAAA,wCAAA,EAA2C,YAAY,CAAA,EAAA,CAAA;QACjF;YACE;YACA,eAAe;QACjB;KACF,EACA,CAAC,OAAc;QAAC,KAAK,KAAA;QAAO,KAAK,aAAa;KAAA;AAIhD,IAAM,4BAA4B,4BAChC,YACA,+BACA,CAAC,UAAoB;QACnB;QACA;KACF,EACA,CAAC,OAAc;QAAC,KAAK,OAAO;KAAA;AAI9B,IAAM,uBAAuB,4BAC3B,YACA,0BACA,CAAC,SAAiB,OAAiB;QACjC;QACA;QACA;YACE;YACA;QACF;KACF,EACA,CAAC,OAAc;QAAC,KAAK,OAAA;QAAS,KAAK,IAAI;KAAA;AAGzC,IAAM,8BAA8B,4BAClC,YACA,iCACA,CAAC,UAAoB;QACnB;QACA;KACF,EACA,CAAC,OAAc;QAAC,KAAK,OAAO;KAAA;AAI9B,IAAM,qBAAqB,4BACzB,YACA,wBACA,CAAC,eAAyB;QACxB;QACA,CAAA,YAAA,EAAe,YAAY,CAAA,uDAAA,CAAA;QAC3B;YACE,eAAe;QACjB;KACF,EACA,CAAC,OAAc;QAAC,KAAK,aAAa;KAAA;AAGpC,IAAM,0BAA0B,4BAC9B,YACA,0BACA,CAAC,cAAsB,eAAmC,cAA2C;QACnG;QACA,CAAA,WAAA,EAAc,KAAK,SAAA,CAAU,YAAY,CAAC,CAAA,gDAAA,EAAmD,KAAK,SAAA,CAAU,WAAW,CAAC,CAAA,YAAA,EAAe,KAAK,SAAA,CAAU,aAAa,CAAC,CAAA,eAAA,CAAA;QACpK;YACE,eAAe;YACf,gBAAgB;YAChB,cAAc;QAChB;KACF,EACA,CAAC,OAAc;QAAC,KAAK,aAAA;QAAe,KAAK,cAAA;QAAgB,KAAK,YAAY;KAAA;AAG5E,IAAM,8BAA8B,4BAClC,YACA,kCACA,CAAC,eAAyB;QACxB;QACA,CAAA,8BAAA,EAAiC,YAAY,CAAA,uDAAA,CAAA;QAC7C;YACE,eAAe;QACjB;KACF,EACA,CAAC,OAAc;QAAC,KAAK,aAAa;KAAA;AAGpC,IAAM,eAAe,4BACnB,YACA,kBACA,CAAC,SAAmB;QAClB;QACA,CAAA,KAAA,EAAQ,MAAM,CAAA,WAAA,CAAA;QACd;YACE,SAAS;QACX;KACF,EACA,CAAC,OAAc;QAAC,KAAK,OAAO;KAAA;AAG9B,IAAM,oBAAoB,4BACxB,YACA,uBACA,CAAC,SAAmB;QAClB;QACA,CAAA,KAAA,EAAQ,MAAM,CAAA,gBAAA,CAAA;QACd;YACE,SAAS;QACX;KACF,EACA,CAAC,OAAc;QAAC,KAAK,OAAO;KAAA;AAG9B,IAAM,yBAAyB,4BAC7B,YACA,6BACA,CAAC,QAAgB,SAAmB;QAClC;QACA,CAAA,KAAA,EAAQ,MAAM,CAAA,sBAAA,EAAyB,MAAM,CAAA,CAAA,CAAA;QAC7C;YACE,SAAS;YACT,SAAS;QACX;KACF,EACA,CAAC,OAAc;QAAC,KAAK,OAAA;QAAS,KAAK,OAAO;KAAA;AAI5C,IAAM,6BAA6B,4BACjC,YACA,iCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,oCAAoC,4BACxC,YACA,0CACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,+CAA+C,4BACnD,YACA,sDACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,0CAA0C,4BAC9C,YACA,iDACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,iDAAiD,4BACrD,YACA,0DACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,kDAAkD,4BACtD,YACA,2DACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,+BAA+B,4BACnC,YACA,qCACA,CAAC,WAAsB;QACrB;QACA;QACA;YACE,WAAW,YAAY;QACzB;KACF,EACA,CAAC,OAAc;QAAC,KAAK,SAAA,IAAa,KAAA,CAAS;KAAA;AAG7C,IAAM,eAAe,4BACnB,YACA,iBACA,CAAC,QAAkB;QACjB;QACA,CAAA,WAAA,EAAc,KAAK,CAAA,uCAAA,CAAA;KACrB,EACA,CAAC,OAAc;QAAC,KAAK,KAAK;KAAA;AAG5B,IAAM,+CAA+C,4BACnD,YACA,sDACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,oBAAoB,4BACxB,YACA,uBACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,oCAAoC,4BACxC,YACA,2CACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,6CAA6C,4BACjD,YACA,sDACA,IAAM;QACJ;QACA,CAAA,mEAAA,CAAA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,oCAAoC,4BACxC,YACA,wCACA,CAAC,cAAwB;QACvB;QACA,CAAA,sDAAA,CAAA;QACA;YACE,cAAc;QAChB;KACF,EACA,CAAC,OAAS;QAAC,KAAK,YAAY;KAAA;AAG9B,IAAM,kBAAkB,4BACtB,YACA,qBACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,6BAA6B,4BACjC,YACA,gCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,8BAA8B,4BAClC,YACA,kCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,4BAA4B,4BAChC,YACA,+BACA,CAAC,QAAQ,eAAiB;QACxB;QACA,CAAA,KAAA,EAAQ,MAAM,CAAA,0BAAA,EAA6B,YAAY,CAAA,CAAA,CAAA;QACvD;YACE,SAAS;YACT,eAAe;QACjB;KACF,EACA,CAAC,OAAS;QAAC,KAAK,OAAA;QAAS,KAAK,aAAa;KAAA;AAG7C,IAAM,yBAAyB,4BAC7B,YACA,4BACA,CAAC,QAAQ,QAAQ,eAAiB;QAChC;QACA,CAAA,KAAA,EAAQ,MAAM,CAAA,0BAAA,EAA6B,YAAY,CAAA,SAAA,EAAY,MAAM,CAAA,CAAA,CAAA;QACzE;YACE,SAAS;YACT,SAAS;YACT,eAAe;QACjB;KACF,EACA,CAAC,OAAS;QAAC,KAAK,OAAA;QAAS,KAAK,OAAA;QAAS,KAAK,aAAa;KAAA;AAG3D,IAAM,yBAAyB,4BAC7B,YACA,6BACA,CAAC,QAAQ,QAAQ,eAAiB;QAChC;QACA,CAAA,KAAA,EAAQ,MAAM,CAAA,0BAAA,EAA6B,YAAY,CAAA,SAAA,EAAY,MAAM,CAAA,CAAA,CAAA;QACzE;YACE,SAAS;YACT,SAAS;YACT,eAAe;QACjB;KACF,EACA,CAAC,OAAS;QAAC,KAAK,OAAA;QAAS,KAAK,OAAA;QAAS,KAAK,aAAa;KAAA;AAG3D,IAAM,+BAA+B,4BACnC,YACA,oCACA,CAAC,aAAe;QACd;QACA,CAAA,kCAAA,EAAqC,UAAU,CAAA,cAAA,CAAA;QAC/C;YACE,aAAa;QACf;KACF,EACA,CAAC,OAAS;QAAC,KAAK,WAAW;KAAA;AAG7B,IAAM,iCAAiC,4BACrC,YACA,sCACA,CAAC,aAAe;QACd;QACA,CAAA,oCAAA,EAAuC,UAAU,CAAA,cAAA,CAAA;QACjD;YACE,aAAa;QACf;KACF,EACA,CAAC,OAAS;QAAC,KAAK,WAAW;KAAA;AAG7B,IAAM,2BAA2B,4BAC/B,YACA,8BACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,4BAA4B,4BAChC,YACA,gCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,gDAAgD,4BACpD,YACA,yDACA,CAAC,MAAe,qBAA8B,8BAAuC,KAAA,GAAU;QAC7F;QACA,CAAA,KAAA,EAAQ,IAAI,CAAA,CAAA,EAAI,sBAAsB,CAAA,EAAA,EAAK,mBAAmB,CAAA,EAAA,CAAA,GAAO,EAAE,CAAA,sDAAA,EAAyD,8BAA8B,6KAA6K,GAAG,EAAA;QAC9U;YACE;YACA,uBAAuB,uBAAuB;YAC9C,kCAAkC;QACpC;KACF,EACA,CAAC,OAAS;QAAC,KAAK,IAAA;QAAM,KAAK,qBAAA;QAAuB,KAAK,gCAAA,IAAoC,KAAK;KAAA;AAGlG,IAAM,0BAA0B,4BAC9B,YACA,wBACA,CAAC,UAAmB;QAClB;QACA;QACA;KACF,EACA,CAAC,OAAc;QAAC,IAAI;KAAA;AAGtB,IAAM,eAAe,4BACnB,YACA,kBACA,CAAC,UAAoB;QACnB;QACA;KACF,EACA,CAAC,OAAc;QAAC,KAAK,OAAO;KAAA;AAG9B,IAAM,sBAAsB,4BAC1B,YACA,0BACA,CAAC,UAAkB,uDAAA,GAA4D;QAC7E;QACA;KACF,EACA,CAAC,OAAc;QAAC,KAAK,OAAO;KAAA;AAG9B,IAAM,mBAAmB,4BACvB,YACA,uBACA,CAAC,UAAkB,kDAAA,GAAuD;QACxE;QACA;KACF,EACA,CAAC,OAAc;QAAC,KAAK,OAAO;KAAA;AAI9B,IAAM,iBAAiB,4BACrB,YACA,qBACA,WACA;AAGF,IAAM,gBAAgB,4BACpB,gBACA,mBACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,gBAAgB,4BACpB,gBACA,mBACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,kBAAkB,4BACtB,gBACA,sBACA,CAAC,cAAsB,aAAuB;QAC5C;QACA,CAAA,qBAAA,EAAwB,YAAY,CAAA,iBAAA,EAAoB,UAAU,CAAA,sBAAA,CAAA;QAClE;YAAE,eAAe;YAAc,aAAa;QAAW;KACzD,EACA,CAAC,OAAS;QAAC,KAAK,aAAA;QAAe,KAAK,WAAW;KAAA;AAGjD,IAAM,iBAAiB,4BACrB,gBACA,qBACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,8BAA8B,4BAClC,gBACA,oCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,4BAA4B,4BAChC,YACA,gCACA,CAAC,eAAyB;QACxB;QACA,CAAA,oBAAA,EAAuB,YAAY,CAAA,wCAAA,CAAA;QACnC;YACE,eAAe;QACjB;KACF,EACA,CAAC,OAAc;QAAC,KAAK,aAAa;KAAA;AAGpC,IAAM,sBAAsB,4BAC1B,YACA,yBACA,CAAC,QAAkB;QACjB;QACA,CAAA,mCAAA,EAAsC,KAAK,EAAA;QAC3C;YAAE;QAAM;KACV,EACA,CAAC,OAAc;QAAC,KAAK,KAAK;KAAA;AAG5B,IAAM,4BAA4B,4BAChC,YACA,gCACA,IAAM;QACJ;QACA,CAAA,qGAAA,CAAA;KACF,EACA,IAAM,CAAC,CAAA;AAGT,IAAM,eAAe,4BACnB,YACA,kBACA,CAAC,SAAmB;QAClB;QACA,CAAA,cAAA,EAAiB,MAAM,CAAA,YAAA,CAAA;QACvB;YACE,SAAS;QACX;KACF,EACA,CAAC,OAAS;QAAC,KAAK,OAAO;KAAA;AAGzB,IAAM,+BAA+B,4BACnC,YACA,qCACA,CAAC,QAAgB,YAAoB,kBAA0D,qBAAmD;QAChJ;QACA,CAAA,IAAA,EAAO,kBAAkB,CAAA,SAAA,EAAY,KAAK,SAAA,CAAU,UAAU,CAAC,CAAA,8CAAA,EAAiD,KAAK,SAAA,CAAU,MAAM,CAAC,CAAA,EAAA,EAAK,mBAAmB,CAAA,gDAAA,EAAmD,gBAAgB,CAAA,kCAAA,EAAqC,kBAAkB,CAAA,CAAA,CAAA,GAAM,CAAA,iHAAA,CAAmH,EAAA;QACjZ;YACE,SAAS;YACT,aAAa;YACb,oBAAoB,oBAAoB;YACxC,sBAAsB;QACxB;KACF,EACA,CAAC,OAAS;QAAC,KAAK,OAAA;QAAS,KAAK,WAAA;QAAa,KAAK,kBAAA,IAAsB,KAAA;QAAW,KAAK,oBAAoB;KAAA;AAG5G,IAAM,uBAAuB,4BAC3B,YACA,2BACA,CAAC,aAAuB;QACtB;QACA,CAAA,iBAAA,EAAoB,KAAK,SAAA,CAAU,UAAU,CAAC,CAAA,gBAAA,CAAA;QAC9C;YACE,aAAa;QACf;KACF,EACA,CAAC,OAAS;QAAC,KAAK,WAAW;KAAA;AAG7B,IAAM,8BAA8B,4BAClC,YACA,kCACA,CAAC,wBAAkC;QACjC;QACA,CAAA,6BAAA,EAAgC,KAAK,SAAA,CAAU,qBAAqB,CAAC,CAAA,gBAAA,CAAA;QACrE;YACE,yBAAyB;QAC3B;KACF,EACA,CAAC,OAAS;QAAC,KAAK,uBAAuB;KAAA;AAGzC,IAAM,0BAA0B,4BAC9B,YACA,+BACA,CAAC,aAAuB;QACtB;QACA,CAAA,0BAAA,EAA6B,KAAK,SAAA,CAAU,UAAU,CAAC,CAAA,gBAAA,CAAA;QACvD;YACE,sBAAsB;QACxB;KACF,EACA,CAAC,OAAS;QAAC,KAAK,oBAAoB;KAAA;AAGtC,IAAM,8BAA8B,4BAClC,YACA,iCACA,CAAC,iBAA2B;QAC1B;QACA,CAAA,qBAAA,EAAwB,KAAK,SAAA,CAAU,cAAc,CAAC,CAAA,sBAAA,CAAA;QACtD;YACE,iBAAiB;QACnB;KACF,EACA,CAAC,OAAS;QAAC,KAAK,eAAe;KAAA;AAGjC,IAAM,iCAAiC,4BACrC,YACA,sCACA,CAAC,aAAuB;QACtB;QACA,CAAA,0BAAA,EAA6B,KAAK,SAAA,CAAU,UAAU,CAAC,CAAA,sBAAA,CAAA;QACvD;YACE,sBAAsB;QACxB;KACF,EACA,CAAC,OAAS;QAAC,KAAK,oBAAoB;KAAA;AAGtC,IAAM,gCAAgC,4BACpC,YACA,qCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAIT,IAAM,sBAAsB,4BAC1B,YACA,0BACA,CAAC,WAAmB,UAAkD;QACpE;QACA,CAAA,gBAAA,EAAmB,KAAK,SAAA,CAAU,SAAS,CAAC,CAAA,CAAA,EAAI,YAAY,gBACxD,iEACA,YAAY,gBACV,qDACA,iBACN,EAAA;QACA;YACE,YAAY;YACZ;QACF;KACF,EACA,CAAC,OAAS;QAAC,KAAK,UAAA;QAAY,KAAK,OAAO;KAAA;AAG1C,IAAM,kCAAkC,4BACtC,YACA,wCACA,CAAC,WAA+B,YAAoB,qBAA6D,qBAAmD;QAClK;QACA,CAAA,IAAA,EAAO,kBAAkB,CAAA,SAAA,EAAY,KAAK,SAAA,CAAU,UAAU,CAAC,CAAA,yEAAA,EAA4E,sBAAsB,CAAA,mDAAA,EAAsD,mBAAmB,CAAA,kCAAA,EAAqC,kBAAkB,CAAA,CAAA,CAAA,GAAM,CAAA,oHAAA,CAAsH,EAAA;QAC7Z;YACE,YAAY,aAAa;YACzB,aAAa;YACb,uBAAuB,uBAAuB;YAC9C,sBAAsB;QACxB;KACF,EACA,CAAC,OAAS;QAAC,KAAK,UAAA,IAAc,KAAA;QAAW,KAAK,WAAA;QAAa,KAAK,qBAAA,IAAyB,KAAA;QAAW,KAAK,oBAAoB;KAAA;AAG/H,IAAM,wBAAwB,4BAC5B,YACA,2BACA,CAAC,WAAmB,aAAuB;QACzC;QACA,CAAA,iBAAA,EAAoB,KAAK,SAAA,CAAU,UAAU,CAAC,CAAA,sBAAA,EAAyB,KAAK,SAAA,CAAU,SAAS,CAAC,CAAA,CAAA,CAAA;QAChG;YACE,YAAY;YACZ,aAAa;QACf;KACF,EACA,CAAC,OAAS;QAAC,KAAK,UAAA;QAAY,KAAK,WAAW;KAAA;AAG9C,IAAM,iCAAiC,4BACrC,YACA,qCACA,CAAC,QAAgB,YAAoB,WAAqB;QACxD;QACA,CAAA,iBAAA,EAAoB,KAAK,SAAA,CAAU,MAAM,CAAC,CAAA,uDAAA,EAA0D,KAAK,SAAA,CAAU,UAAU,CAAC,CAAA,gCAAA,EAAmC,QAAQ,CAAA,SAAA,CAAA;QACzK;YACE,SAAS;YACT,aAAa;YACb;QACF;KACF,EACA,CAAC,OAAS;QAAC,KAAK,OAAA;QAAS,KAAK,WAAA;QAAa,KAAK,QAAQ;KAAA;AAG1D,IAAM,4BAA4B,4BAChC,YACA,iCACA,IAAM;QACJ;QACA;KACF,EACA,IAAM,CAAC,CAAA;AAOF,IAAM,cAAc;IACzB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACF;AAIA,IAAM,kBAAkB,aAAA,GAAA,IAAI,IAAY;AACxC,KAAA,MAAW,CAAC,GAAGA,WAAU,CAAA,IAAK,OAAO,OAAA,CAAQ,WAAW,EAAG;IACzD,IAAI,gBAAgB,GAAA,CAAIA,YAAW,SAAS,GAAG;QAC7C,MAAM,IAAI,MAAM,CAAA,4BAAA,EAA+BA,YAAW,SAAS,EAAE;IACvE;IACA,gBAAgB,GAAA,CAAIA,YAAW,SAAS;AAC1C"}},
    {"offset": {"line": 2317, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack-shared/src/utils/maps.tsx"],"sourcesContent":["import { Result } from \"./results\";\n\nexport class WeakRefIfAvailable<T extends object> {\n  private readonly _ref: { deref: () => T | undefined };\n\n  constructor(value: T) {\n    if (typeof WeakRef === \"undefined\") {\n      this._ref = { deref: () => value };\n    } else {\n      this._ref = new WeakRef<T>(value);\n    }\n  }\n\n  deref(): T | undefined {\n    return this._ref.deref();\n  }\n}\nundefined?.test(\"WeakRefIfAvailable\", ({ expect }) => {\n  // Test with an object\n  const obj = { id: 1, name: \"test\" };\n  const weakRef = new WeakRefIfAvailable(obj);\n\n  // Test deref returns the original object\n  expect(weakRef.deref()).toBe(obj);\n\n  // Test with a different object\n  const obj2 = { id: 2, name: \"test2\" };\n  const weakRef2 = new WeakRefIfAvailable(obj2);\n  expect(weakRef2.deref()).toBe(obj2);\n  expect(weakRef2.deref()).not.toBe(obj);\n\n  // We can't easily test garbage collection in this environment,\n  // but we can verify the basic functionality works\n});\n\n\n/**\n * A WeakMap-like object that can be iterated over.\n *\n * Note that it relies on WeakRef, and always falls back to the regular Map behavior (ie. no GC) in browsers that don't support it.\n */\nexport class IterableWeakMap<K extends object, V> {\n  private readonly _weakMap: WeakMap<K & WeakKey, { value: V, keyRef: WeakRefIfAvailable<K & WeakKey> }>;\n  private readonly _keyRefs: Set<WeakRefIfAvailable<K & WeakKey>>;\n\n  constructor(entries?: readonly (readonly [K, V])[] | null) {\n    const mappedEntries = entries?.map((e) => [e[0], { value: e[1], keyRef: new WeakRefIfAvailable(e[0]) }] as const);\n    this._weakMap = new WeakMap(mappedEntries ?? []);\n    this._keyRefs = new Set(mappedEntries?.map((e) => e[1].keyRef) ?? []);\n  }\n\n  get(key: K): V | undefined {\n    return this._weakMap.get(key)?.value;\n  }\n\n  set(key: K, value: V): this {\n    const existing = this._weakMap.get(key);\n    const updated = { value, keyRef: existing?.keyRef ?? new WeakRefIfAvailable(key) };\n    this._weakMap.set(key, updated);\n    this._keyRefs.add(updated.keyRef);\n    return this;\n  }\n\n  delete(key: K): boolean {\n    const res = this._weakMap.get(key);\n    if (res) {\n      this._weakMap.delete(key);\n      this._keyRefs.delete(res.keyRef);\n      return true;\n    }\n    return false;\n  }\n\n  has(key: K): boolean {\n    return this._weakMap.has(key) && this._keyRefs.has(this._weakMap.get(key)!.keyRef);\n  }\n\n  *[Symbol.iterator](): IterableIterator<[K, V]> {\n    for (const keyRef of this._keyRefs) {\n      const key = keyRef.deref();\n      const existing = key ? this._weakMap.get(key) : undefined;\n      if (!key) {\n        // This can happen if the key was GCed. Remove it so the next iteration is faster.\n        this._keyRefs.delete(keyRef);\n      } else if (existing) {\n        yield [key, existing.value];\n      }\n    }\n  }\n\n  [Symbol.toStringTag] = \"IterableWeakMap\";\n}\nundefined?.test(\"IterableWeakMap\", ({ expect }) => {\n  // Test basic functionality\n  const map = new IterableWeakMap<{ id: number }, string>();\n\n  // Create object keys\n  const obj1 = { id: 1 };\n  const obj2 = { id: 2 };\n\n  // Test set and get\n  map.set(obj1, \"value1\");\n  expect(map.get(obj1)).toBe(\"value1\");\n\n  // Test has\n  expect(map.has(obj1)).toBe(true);\n  expect(map.has(obj2)).toBe(false);\n  expect(map.has({ id: 1 })).toBe(false); // Different object with same content\n\n  // Test with multiple keys\n  map.set(obj2, \"value2\");\n  expect(map.get(obj2)).toBe(\"value2\");\n  expect(map.get(obj1)).toBe(\"value1\"); // Original still exists\n\n  // Test delete\n  expect(map.delete(obj1)).toBe(true);\n  expect(map.has(obj1)).toBe(false);\n  expect(map.get(obj1)).toBeUndefined();\n  expect(map.has(obj2)).toBe(true); // Other key still exists\n\n  // Test delete non-existent key\n  expect(map.delete({ id: 3 })).toBe(false);\n\n  // Test iteration\n  const iterMap = new IterableWeakMap<{ id: number }, number>();\n  const iterObj1 = { id: 1 };\n  const iterObj2 = { id: 2 };\n  const iterObj3 = { id: 3 };\n\n  iterMap.set(iterObj1, 1);\n  iterMap.set(iterObj2, 2);\n  iterMap.set(iterObj3, 3);\n\n  const entries = Array.from(iterMap);\n  expect(entries.length).toBe(3);\n\n  // Find entries by their values since we can't directly compare objects in the array\n  const values = entries.map(entry => entry[1]);\n  expect(values).toContain(1);\n  expect(values).toContain(2);\n  expect(values).toContain(3);\n\n  // Test constructor with entries\n  const initialEntries: [{ id: number }, string][] = [\n    [{ id: 4 }, \"initial1\"],\n    [{ id: 5 }, \"initial2\"]\n  ];\n  const mapWithEntries = new IterableWeakMap(initialEntries);\n\n  // We can't directly access the initial entries since they're different object references\n  // But we can verify the map has the correct number of entries\n  const entriesFromConstructor = Array.from(mapWithEntries);\n  expect(entriesFromConstructor.length).toBe(2);\n});\n\n/**\n * A map that is a IterableWeakMap for object keys and a regular Map for primitive keys. Also provides iteration over both\n * object and primitive keys.\n *\n * Note that, just like IterableWeakMap, older browsers without support for WeakRef will use a regular Map for object keys.\n */\nexport class MaybeWeakMap<K, V> {\n  private readonly _primitiveMap: Map<K, V>;\n  private readonly _weakMap: IterableWeakMap<K & WeakKey, V>;\n\n  constructor(entries?: readonly (readonly [K, V])[] | null) {\n    const entriesArray = [...entries ?? []];\n    this._primitiveMap = new Map(entriesArray.filter((e) => !this._isAllowedInWeakMap(e[0])));\n    this._weakMap = new IterableWeakMap(entriesArray.filter((e): e is [K & WeakKey, V] => this._isAllowedInWeakMap(e[0])));\n  }\n\n  private _isAllowedInWeakMap(key: K): key is K & WeakKey {\n    return (typeof key === \"object\" && key !== null) || (typeof key === \"symbol\" && Symbol.keyFor(key) === undefined);\n  }\n\n  get(key: K): V | undefined {\n    if (this._isAllowedInWeakMap(key)) {\n      return this._weakMap.get(key);\n    } else {\n      return this._primitiveMap.get(key);\n    }\n  }\n\n  set(key: K, value: V): this {\n    if (this._isAllowedInWeakMap(key)) {\n      this._weakMap.set(key, value);\n    } else {\n      this._primitiveMap.set(key, value);\n    }\n    return this;\n  }\n\n  delete(key: K): boolean {\n    if (this._isAllowedInWeakMap(key)) {\n      return this._weakMap.delete(key);\n    } else {\n      return this._primitiveMap.delete(key);\n    }\n  }\n\n  has(key: K): boolean {\n    if (this._isAllowedInWeakMap(key)) {\n      return this._weakMap.has(key);\n    } else {\n      return this._primitiveMap.has(key);\n    }\n  }\n\n  *[Symbol.iterator](): IterableIterator<[K, V]> {\n    yield* this._primitiveMap;\n    yield* this._weakMap;\n  }\n\n  [Symbol.toStringTag] = \"MaybeWeakMap\";\n}\nundefined?.test(\"MaybeWeakMap\", ({ expect }) => {\n  // Test with primitive keys\n  const map = new MaybeWeakMap<string | object, number>();\n\n  // Test with string keys\n  map.set(\"key1\", 1);\n  map.set(\"key2\", 2);\n  expect(map.get(\"key1\")).toBe(1);\n  expect(map.get(\"key2\")).toBe(2);\n  expect(map.has(\"key1\")).toBe(true);\n  expect(map.has(\"nonexistent\")).toBe(false);\n\n  // Test with object keys\n  const obj1 = { id: 1 };\n  const obj2 = { id: 2 };\n  map.set(obj1, 3);\n  map.set(obj2, 4);\n  expect(map.get(obj1)).toBe(3);\n  expect(map.get(obj2)).toBe(4);\n  expect(map.has(obj1)).toBe(true);\n\n  // Test delete with primitive key\n  expect(map.delete(\"key1\")).toBe(true);\n  expect(map.has(\"key1\")).toBe(false);\n  expect(map.delete(\"nonexistent\")).toBe(false);\n\n  // Test delete with object key\n  expect(map.delete(obj1)).toBe(true);\n  expect(map.has(obj1)).toBe(false);\n\n  // Test iteration\n  const entries = Array.from(map);\n  expect(entries.length).toBe(2);\n  expect(entries).toContainEqual([\"key2\", 2]);\n  expect(entries).toContainEqual([obj2, 4]);\n\n  // Test constructor with entries\n  const initialEntries: [string | object, number][] = [\n    [\"initial1\", 10],\n    [{ id: 3 }, 20]\n  ];\n  const mapWithEntries = new MaybeWeakMap(initialEntries);\n  expect(mapWithEntries.get(\"initial1\")).toBe(10);\n  expect(mapWithEntries.get(initialEntries[1][0])).toBe(20);\n});\n\n\ntype DependenciesMapInner<V> = (\n  & { map: MaybeWeakMap<unknown, DependenciesMapInner<V>> }\n  & (\n    | { hasValue: true, value: V }\n    | { hasValue: false, value: undefined }\n  )\n);\n\n/**\n * A map that stores values indexed by an array of keys. If the keys are objects and the environment supports WeakRefs,\n * they are stored in a WeakMap.\n */\nexport class DependenciesMap<K extends any[], V> {\n  private _inner: DependenciesMapInner<V> = { map: new MaybeWeakMap(), hasValue: false, value: undefined };\n\n  private _valueToResult(inner: DependenciesMapInner<V>): Result<V, void> {\n    if (inner.hasValue) {\n      return Result.ok(inner.value);\n    } else {\n      return Result.error(undefined);\n    }\n  }\n\n\n  private _unwrapFromInner(dependencies: any[], inner: DependenciesMapInner<V>): Result<V, void> {\n    if ((dependencies.length === 0)) {\n      return this._valueToResult(inner);\n    } else {\n      const [key, ...rest] = dependencies;\n      const newInner = inner.map.get(key);\n      if (!newInner) {\n        return Result.error(undefined);\n      }\n      return this._unwrapFromInner(rest, newInner);\n    }\n  }\n\n  private _setInInner(dependencies: any[], value: Result<V, void>, inner: DependenciesMapInner<V>): Result<V, void> {\n    if (dependencies.length === 0) {\n      const res = this._valueToResult(inner);\n      if (value.status === \"ok\") {\n        inner.hasValue = true;\n        inner.value = value.data;\n      } else {\n        inner.hasValue = false;\n        inner.value = undefined;\n      }\n      return res;\n    } else {\n      const [key, ...rest] = dependencies;\n      let newInner = inner.map.get(key);\n      if (!newInner) {\n        inner.map.set(key, newInner = { map: new MaybeWeakMap(), hasValue: false, value: undefined });\n      }\n      return this._setInInner(rest, value, newInner);\n    }\n  }\n\n  private *_iterateInner(dependencies: any[], inner: DependenciesMapInner<V>): IterableIterator<[K, V]> {\n    if (inner.hasValue) {\n      yield [dependencies as K, inner.value];\n    }\n    for (const [key, value] of inner.map) {\n      yield* this._iterateInner([...dependencies, key], value);\n    }\n  }\n\n  get(dependencies: K): V | undefined {\n    return Result.or(this._unwrapFromInner(dependencies, this._inner), undefined);\n  }\n\n  set(dependencies: K, value: V): this {\n    this._setInInner(dependencies, Result.ok(value), this._inner);\n    return this;\n  }\n\n  delete(dependencies: K): boolean {\n    return this._setInInner(dependencies, Result.error(undefined), this._inner).status === \"ok\";\n  }\n\n  has(dependencies: K): boolean {\n    return this._unwrapFromInner(dependencies, this._inner).status === \"ok\";\n  }\n\n  clear(): void {\n    this._inner = { map: new MaybeWeakMap(), hasValue: false, value: undefined };\n  }\n\n  *[Symbol.iterator](): IterableIterator<[K, V]> {\n    yield* this._iterateInner([], this._inner);\n  }\n\n  [Symbol.toStringTag] = \"DependenciesMap\";\n}\nundefined?.test(\"DependenciesMap\", ({ expect }) => {\n  // Test basic functionality\n  const map = new DependenciesMap<[string, number], string>();\n\n  // Test set and get\n  map.set([\"key\", 1], \"value1\");\n  expect(map.get([\"key\", 1])).toBe(\"value1\");\n\n  // Test has\n  expect(map.has([\"key\", 1])).toBe(true);\n  expect(map.has([\"key\", 2])).toBe(false);\n\n  // Test with different dependencies\n  map.set([\"key\", 2], \"value2\");\n  expect(map.get([\"key\", 2])).toBe(\"value2\");\n  expect(map.get([\"key\", 1])).toBe(\"value1\"); // Original still exists\n\n  // Test delete\n  expect(map.delete([\"key\", 1])).toBe(true);\n  expect(map.has([\"key\", 1])).toBe(false);\n  expect(map.get([\"key\", 1])).toBeUndefined();\n  expect(map.has([\"key\", 2])).toBe(true); // Other key still exists\n\n  // Test delete non-existent key\n  expect(map.delete([\"nonexistent\", 1])).toBe(false);\n\n  // Test clear\n  map.clear();\n  expect(map.has([\"key\", 2])).toBe(false);\n\n  // Test with object keys\n  const objMap = new DependenciesMap<[object, number], string>();\n  const obj1 = { id: 1 };\n  const obj2 = { id: 2 };\n  objMap.set([obj1, 1], \"object1\");\n  objMap.set([obj2, 2], \"object2\");\n  expect(objMap.get([obj1, 1])).toBe(\"object1\");\n  expect(objMap.get([obj2, 2])).toBe(\"object2\");\n\n  // Test iteration\n  const iterMap = new DependenciesMap<[string], number>();\n  iterMap.set([\"a\"], 1);\n  iterMap.set([\"b\"], 2);\n  iterMap.set([\"c\"], 3);\n\n  const entries = Array.from(iterMap);\n  expect(entries.length).toBe(3);\n  expect(entries).toContainEqual([[\"a\"], 1]);\n  expect(entries).toContainEqual([[\"b\"], 2]);\n  expect(entries).toContainEqual([[\"c\"], 3]);\n});\n"],"names":["_a","_b"],"mappings":"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"}},
    {"offset": {"line": 2542, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack-shared/src/utils/bytes.tsx"],"sourcesContent":["import { StackAssertionError } from \"./errors\";\n\nconst crockfordAlphabet = \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\";\nconst crockfordReplacements = new Map([\n  [\"o\", \"0\"],\n  [\"i\", \"1\"],\n  [\"l\", \"1\"],\n]);\n\nexport function toHexString(input: Uint8Array): string {\n  return Array.from(input).map(b => b.toString(16).padStart(2, \"0\")).join(\"\");\n}\nundefined?.test(\"toHexString\", ({ expect }) => {\n  expect(toHexString(new Uint8Array([]))).toBe(\"\");\n  expect(toHexString(new Uint8Array([0]))).toBe(\"00\");\n  expect(toHexString(new Uint8Array([15]))).toBe(\"0f\");\n  expect(toHexString(new Uint8Array([16]))).toBe(\"10\");\n  expect(toHexString(new Uint8Array([255]))).toBe(\"ff\");\n  expect(toHexString(new Uint8Array([1, 2, 3]))).toBe(\"010203\");\n});\n\nexport function getBase32CharacterFromIndex(index: number): string {\n  if (index < 0 || index >= crockfordAlphabet.length) {\n    throw new StackAssertionError(`Invalid base32 index: ${index}`);\n  }\n  return crockfordAlphabet[index];\n}\nundefined?.test(\"getBase32CharacterFromIndex\", ({ expect }) => {\n  expect(getBase32CharacterFromIndex(0)).toBe(\"0\");\n  expect(getBase32CharacterFromIndex(15)).toBe(\"F\");\n  expect(() => getBase32CharacterFromIndex(32)).toThrow();\n});\n\nexport function getBase32IndexFromCharacter(character: string): number {\n  if (character.length !== 1) {\n    throw new StackAssertionError(`Invalid base32 character: ${character}`);\n  }\n  const index = crockfordAlphabet.indexOf(character.toUpperCase());\n  if (index === -1) {\n    throw new StackAssertionError(`Invalid base32 character: ${character}`);\n  }\n  return index;\n}\nundefined?.test(\"getBase32IndexFromCharacter\", ({ expect }) => {\n  expect(getBase32IndexFromCharacter(\"0\")).toBe(0);\n  expect(getBase32IndexFromCharacter(\"F\")).toBe(15);\n  expect(() => getBase32IndexFromCharacter(\"_\")).toThrow();\n});\n\nexport function encodeBase32(input: Uint8Array): string {\n  let bits = 0;\n  let value = 0;\n  let output = \"\";\n  for (let i = 0; i < input.length; i++) {\n    value = (value << 8) | input[i];\n    bits += 8;\n    while (bits >= 5) {\n      output += getBase32CharacterFromIndex((value >>> (bits - 5)) & 31);\n      bits -= 5;\n    }\n  }\n  if (bits > 0) {\n    output += getBase32CharacterFromIndex((value << (5 - bits)) & 31);\n  }\n\n  // sanity check\n  if (!isBase32(output)) {\n    throw new StackAssertionError(\"Invalid base32 output; this should never happen\");\n  }\n\n  return output;\n}\nundefined?.test(\"encodeBase32\", ({ expect }) => {\n  expect(encodeBase32(new Uint8Array([]))).toBe(\"\");\n  expect(encodeBase32(new Uint8Array([1]))).toBe(\"04\");\n  expect(encodeBase32(new Uint8Array([15]))).toBe(\"1W\");\n  expect(encodeBase32(new Uint8Array([16]))).toBe(\"20\");\n  expect(encodeBase32(new Uint8Array([255]))).toBe(\"ZW\");\n  expect(encodeBase32(new Uint8Array([255,255]))).toBe(\"ZZZG\");\n});\nexport function decodeBase32(input: string): Uint8Array {\n  if (!isBase32(input)) {\n    throw new StackAssertionError(\"Invalid base32 string\");\n  }\n\n  const output = new Uint8Array((input.length * 5 / 8) | 0);\n  let bits = 0;\n  let value = 0;\n  let outputIndex = 0;\n  for (let i = 0; i < input.length; i++) {\n    let char = input[i].toLowerCase();\n    if (char === \" \") continue;\n    if (crockfordReplacements.has(char)) {\n      char = crockfordReplacements.get(char)!;\n    }\n    const index = getBase32IndexFromCharacter(char);\n    value = (value << 5) | index;\n    bits += 5;\n    if (bits >= 8) {\n      output[outputIndex++] = (value >>> (bits - 8)) & 255;\n      bits -= 8;\n    }\n  }\n  return output;\n}\nundefined?.test(\"decodeBase32\", ({ expect }) => {\n  expect(decodeBase32(\"\")).toEqual(new Uint8Array([]));\n  expect(decodeBase32(\"00\")).toEqual(new Uint8Array([0]));\n  expect(decodeBase32(\"1W\")).toEqual(new Uint8Array([15]));\n  expect(decodeBase32(\"20\")).toEqual(new Uint8Array([16]));\n  expect(decodeBase32(\"ZW\")).toEqual(new Uint8Array([255]));\n});\n\nexport function encodeBase64(input: Uint8Array): string {\n  return btoa([...input].map((b) => String.fromCharCode(b)).join(\"\"));\n}\n\nexport function decodeBase64(input: string): Uint8Array {\n  return new Uint8Array(atob(input).split(\"\").map((char) => char.charCodeAt(0)));\n}\nundefined?.test(\"encodeBase64/decodeBase64\", ({ expect }) => {\n  const testCases = [\n    { input: new Uint8Array([72, 101, 108, 108, 111]), expected: \"SGVsbG8=\" },\n    { input: new Uint8Array([0, 1, 2, 3, 4]), expected: \"AAECAwQ=\" },\n    { input: new Uint8Array([255, 254, 253, 252]), expected: \"//79/A==\" },\n    { input: new Uint8Array([]), expected: \"\" },\n    {\n      input: (() => {\n        // make sure huge inputs are supported; 48MB array of every possible triple-byte combination\n        const input = new Uint8Array(3 * (2 ** 24));\n        for (let i = 0; i < input.length / 3; i++) {\n          input[3 * i] = Math.floor(i / 256 / 256);\n          input[3 * i + 1] = Math.floor(i / 256) % 256;\n          input[3 * i + 2] = i % 256;\n        }\n        return input;\n      })(),\n      expected: (() => {\n        const base64Alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n        const output = [];\n        for (let i = 0; i < 2 ** 24; i++) {\n          output.push(\n            base64Alphabet[Math.floor(i / 64 / 64 / 64)]\n              + base64Alphabet[Math.floor(i / 64 / 64) % 64]\n              + base64Alphabet[Math.floor(i / 64) % 64]\n              + base64Alphabet[i % 64]\n          );\n        }\n        return output.join(\"\");\n      })(),\n    },\n  ];\n\n  for (const [i, { input, expected }] of testCases.entries()) {\n    // expect(...) is pretty slow with long inputs, so we throw our own assertions\n    const encoded = encodeBase64(input);\n    if (encoded !== expected) {\n      throw new StackAssertionError(`encodeBase64 test case ${i} failed`);\n    }\n    const decoded = decodeBase64(encoded);\n    if (decoded.some((b, i) => b !== input[i])) {\n      throw new StackAssertionError(`decodeBase64 test case ${i} failed`);\n    }\n  }\n\n  // Test invalid input for decodeBase64\n  expect(() => decodeBase64(\"invalid!\")).toThrow();\n}, {\n  timeout: 30000,\n});\n\nexport function encodeBase64Url(input: Uint8Array): string {\n  const res = encodeBase64(input).replace(/=+$/, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n\n  // Skip sanity check for test cases\n  // This avoids circular dependency with isBase64Url function\n  return res;\n}\n\nexport function decodeBase64Url(input: string): Uint8Array {\n  if (!isBase64Url(input)) {\n    throw new StackAssertionError(\"Invalid base64url string\");\n  }\n\n  // Handle empty string case\n  if (input === \"\") {\n    return new Uint8Array(0);\n  }\n\n  return decodeBase64(input.replace(/-/g, \"+\").replace(/_/g, \"/\") + \"====\".slice((input.length - 1) % 4 + 1));\n}\nundefined?.test(\"encodeBase64Url/decodeBase64Url\", ({ expect }) => {\n  const testCases = [\n    { input: new Uint8Array([72, 101, 108, 108, 111]), expected: \"SGVsbG8\" },\n    { input: new Uint8Array([0, 1, 2, 3, 4]), expected: \"AAECAwQ\" },\n    { input: new Uint8Array([255, 254, 253, 252]), expected: \"__79_A\" },\n    { input: new Uint8Array([]), expected: \"\" },\n  ];\n\n  for (const { input, expected } of testCases) {\n    const encoded = encodeBase64Url(input);\n    expect(encoded).toBe(expected);\n    const decoded = decodeBase64Url(encoded);\n    expect(decoded).toEqual(input);\n  }\n\n  // Test invalid input for decodeBase64Url\n  expect(() => decodeBase64Url(\"invalid!\")).toThrow();\n});\n\nexport function decodeBase64OrBase64Url(input: string): Uint8Array {\n  if (isBase64Url(input)) {\n    return decodeBase64Url(input);\n  } else if (isBase64(input)) {\n    return decodeBase64(input);\n  } else {\n    throw new StackAssertionError(\"Invalid base64 or base64url string\");\n  }\n}\nundefined?.test(\"decodeBase64OrBase64Url\", ({ expect }) => {\n  // Test with base64 input\n  const base64Input = \"SGVsbG8gV29ybGQ=\";\n  const base64Expected = new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]);\n  expect(decodeBase64OrBase64Url(base64Input)).toEqual(base64Expected);\n\n  // Test with base64url input\n  const base64UrlInput = \"SGVsbG8gV29ybGQ\";\n  const base64UrlExpected = new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]);\n  expect(decodeBase64OrBase64Url(base64UrlInput)).toEqual(base64UrlExpected);\n\n  // Test with invalid input\n  expect(() => decodeBase64OrBase64Url(\"invalid!\")).toThrow();\n});\n\nexport function isBase32(input: string): boolean {\n  for (const char of input) {\n    if (char === \" \") continue;\n    const upperChar = char.toUpperCase();\n    // Check if the character is in the Crockford alphabet\n    if (!crockfordAlphabet.includes(upperChar)) {\n      return false;\n    }\n  }\n  return true;\n}\nundefined?.test(\"isBase32\", ({ expect }) => {\n  expect(isBase32(\"0123456789ABCDEFGHJKMNPQRSTVWXYZ\")).toBe(true);\n  expect(isBase32(\"0OIJ\")).toBe(false); // O and I are not allowed\n  expect(isBase32(\"ABC DEF\")).toBe(true); // Spaces are allowed\n  expect(isBase32(\"ABC!\")).toBe(false); // Special characters not allowed\n  expect(isBase32(\"\")).toBe(true);\n});\n\nexport function isBase64(input: string): boolean {\n  // This regex allows for standard base64 with proper padding\n  const regex = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;\n  return regex.test(input);\n}\nundefined?.test(\"isBase64\", ({ expect }) => {\n  expect(isBase64(\"SGVsbG8gV29ybGQ=\")).toBe(true);\n  expect(isBase64(\"SGVsbG8gV29ybGQ\")).toBe(false); // No padding\n  expect(isBase64(\"SGVsbG8gV29ybGQ==\")).toBe(false); // Wrong padding\n  expect(isBase64(\"SGVsbG8!V29ybGQ=\")).toBe(false); // Invalid character\n  expect(isBase64(\"\")).toBe(true);\n});\n\nexport function isBase64Url(input: string): boolean {\n  if (input === \"\") {\n    return true;\n  }\n  const regex = /^[0-9a-zA-Z_-]+$/;\n  return regex.test(input);\n}\nundefined?.test(\"isBase64Url\", ({ expect }) => {\n  expect(isBase64Url(\"SGVsbG8gV2 9ybGQ\")).toBe(false); // Space is not valid\n  expect(isBase64Url(\"SGVsbG8_V29ybGQ\")).toBe(true); // _ is a valid character\n  expect(isBase64Url(\"SGVsbG8-V29ybGQ\")).toBe(true); // - is valid\n  expect(isBase64Url(\"SGVsbG8_V29ybGQ=\")).toBe(false); // = not allowed\n  expect(isBase64Url(\"\")).toBe(true); // Empty string is valid\n});\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2708, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack-shared/src/utils/crypto.tsx"],"sourcesContent":["import { encodeBase32, encodeBase64 } from \"./bytes\";\nimport { StackAssertionError } from \"./errors\";\nimport { globalVar } from \"./globals\";\nimport { Result } from \"./results\";\n\nexport function generateRandomValues(array: Uint8Array): typeof array {\n  if (!globalVar.crypto) {\n    throw new StackAssertionError(\"Crypto API is not available in this environment. Are you using an old browser?\");\n  }\n  if (!globalVar.crypto.getRandomValues) {\n    throw new StackAssertionError(\"crypto.getRandomValues is not available in this environment. Are you using an old browser?\");\n  }\n  return globalVar.crypto.getRandomValues(array);\n}\n\n/**\n * Generates a secure alphanumeric string using the system's cryptographically secure\n * random number generator.\n */\nexport function generateSecureRandomString(minBitsOfEntropy: number = 224) {\n  const base32CharactersCount = Math.ceil(minBitsOfEntropy / 5);\n  const bytesCount = Math.ceil(base32CharactersCount * 5 / 8);\n  const randomBytes = generateRandomValues(new Uint8Array(bytesCount));\n  const str = encodeBase32(randomBytes);\n  return str.slice(str.length - base32CharactersCount).toLowerCase();\n}\n\nasync function getDerivedSymmetricKey(purpose: string, secret: string | Uint8Array, salt: Uint8Array) {\n  const originalSecretKey = await crypto.subtle.importKey(\"raw\", typeof secret === \"string\" ? new TextEncoder().encode(secret) : secret, \"HKDF\", false, [\"deriveKey\"]);\n  return await crypto.subtle.deriveKey(\n    {\n      name: \"HKDF\",\n      salt,\n      hash: \"SHA-256\",\n      info: new TextEncoder().encode(JSON.stringify([\n        \"stack-crypto-helper-derived-symmetric-key\",\n        purpose,\n        typeof secret === \"string\" ? \"string-key\" : \"binary-key\",\n        encodeBase64(salt),\n      ])),\n    },\n    originalSecretKey,\n    { name: \"AES-GCM\", length: 256 },\n    false,\n    [\"encrypt\", \"decrypt\"]\n  );\n}\n\nexport async function encrypt({ purpose, secret, value }: { purpose: string, secret: string | Uint8Array, value: Uint8Array }) {\n  const iv = crypto.getRandomValues(new Uint8Array(12));\n  const salt = crypto.getRandomValues(new Uint8Array(16));\n  const derivedSecretKey = await getDerivedSymmetricKey(purpose, secret, salt);\n\n  const cipher = await crypto.subtle.encrypt({\n    name: \"AES-GCM\",\n    iv,\n  }, derivedSecretKey, value);\n\n  const version = [0x01, 0x00];\n  return new Uint8Array([...version, ...salt, ...iv, ...new Uint8Array(cipher)]);\n}\n\nexport async function decrypt({ purpose, secret, cipher }: { purpose: string, secret: string | Uint8Array, cipher: Uint8Array }) {\n  const version = cipher.slice(0, 2);\n  if (version[0] !== 0x01 || version[1] !== 0x00) throw new StackAssertionError(\"Invalid ciphertext version in decrypt(...); expected 0x0100\", { purpose });\n  const salt = cipher.slice(2, 18);\n  const iv = cipher.slice(18, 30);\n  const cipherBytes = cipher.slice(30);\n  const derivedSecretKey = await getDerivedSymmetricKey(purpose, secret, salt);\n\n  try {\n    const plaintext = await crypto.subtle.decrypt({\n      name: \"AES-GCM\",\n      iv,\n    }, derivedSecretKey, cipherBytes);\n    return Result.ok(new Uint8Array(plaintext));\n  } catch (e) {\n    if (e instanceof DOMException && e.name === \"OperationError\") {\n      return Result.error(new Error(\"Invalid ciphertext or secret when decrypting encrypted value\", { cause: e }));\n    }\n    throw e;\n  }\n}\n\nundefined?.test(\"encrypt & decrypt\", async ({ expect }) => {\n  const encryptAndDecrypt = async (encryptPurpose: string, decryptPurpose: string, encryptSecret: string | Uint8Array, decryptSecret: string | Uint8Array, value: Uint8Array) => {\n    const encrypted = await encrypt({ purpose: encryptPurpose, secret: encryptSecret, value });\n    const decrypted = await decrypt({ purpose: decryptPurpose, secret: decryptSecret, cipher: encrypted });\n    return decrypted;\n  };\n\n  const exampleBytes = new TextEncoder().encode(\"hello\");\n\n  const exampleKey1 = crypto.getRandomValues(new Uint8Array(32));\n  const exampleKey2 = crypto.getRandomValues(new Uint8Array(32));\n\n  expect(await encryptAndDecrypt(\"p\", \"p\", \"secret\", \"secret\", exampleBytes)).toEqual(Result.ok(exampleBytes));\n  expect(await encryptAndDecrypt(\"p\", \"p\", exampleKey1, exampleKey1, exampleBytes)).toEqual(Result.ok(exampleBytes));\n  expect(await encryptAndDecrypt(\"p\", \"p\", exampleKey1, \"secret\", exampleBytes)).toEqual(Result.error(expect.objectContaining({ message: \"Invalid ciphertext or secret when decrypting encrypted value\" })));\n  expect(await encryptAndDecrypt(\"p\", \"p\", exampleKey1, exampleKey2, exampleBytes)).toEqual(Result.error(expect.objectContaining({ message: \"Invalid ciphertext or secret when decrypting encrypted value\" })));\n  expect(await encryptAndDecrypt(\"p\", \"not-p\", exampleKey1, exampleKey1, exampleBytes)).toEqual(Result.error(expect.objectContaining({ message: \"Invalid ciphertext or secret when decrypting encrypted value\" })));\n});\n\nexport type HashOptions = {\n  purpose: string,\n  salt?: string | Uint8Array,\n  extra?: string | Uint8Array,\n  value: string | Uint8Array,\n};\n\nexport async function hash(options: HashOptions) {\n  return await iteratedHash({ ...options, iterations: 1 });\n}\n\nexport async function iteratedHash(options: HashOptions & { iterations: number }) {\n  const stringOrUint8ArrayToUint8Array = (value: string | Uint8Array) => typeof value === \"string\" ? new TextEncoder().encode(value) : value;\n  const stringOrUint8ArrayToBase64 = (value: string | Uint8Array) => encodeBase64(stringOrUint8ArrayToUint8Array(value));\n  const input = await crypto.subtle.importKey(\n    \"raw\",\n    stringOrUint8ArrayToUint8Array(options.value),\n    \"PBKDF2\",\n    false,\n    [\"deriveBits\"]\n  );\n  return new Uint8Array(await crypto.subtle.deriveBits({\n    name: \"PBKDF2\",\n    salt: new TextEncoder().encode(JSON.stringify([\n      \"stack-crypto-helper-iterated-hash\",\n      options.purpose,\n      stringOrUint8ArrayToBase64(options.salt ?? \"\"),\n      stringOrUint8ArrayToBase64(options.extra ?? \"\"),\n    ])),\n    iterations: options.iterations,\n    hash: \"SHA-256\",\n  }, input, 256));\n}\n\nundefined?.test(\"iteratedHash\", async ({ expect }) => {\n  const valueBytes = new TextEncoder().encode(\"hello\");\n  const incrementBytes = new Uint8Array([0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10]);\n\n  const hash = await iteratedHash({ purpose: \"purpose\", value: valueBytes, iterations: 100_000 });\n  const hash2 = await iteratedHash({ purpose: \"purpose\", value: valueBytes, iterations: 100_000 });\n  const hashWithDifferentPurpose = await iteratedHash({ purpose: \"different-purpose\", value: valueBytes, iterations: 100_000 });\n  const hashWithEmptySalt = await iteratedHash({ purpose: \"purpose\", value: valueBytes, salt: new Uint8Array(0), iterations: 100_000 });\n  const hashWithDifferentSalt = await iteratedHash({ purpose: \"purpose\", value: valueBytes, salt: incrementBytes, iterations: 100_000 });\n  const hashWithEmptyExtra = await iteratedHash({ purpose: \"purpose\", value: valueBytes, extra: new Uint8Array(0), iterations: 100_000 });\n  const hashWithDifferentExtra = await iteratedHash({ purpose: \"purpose\", value: valueBytes, extra: incrementBytes, iterations: 100_000 });\n  const hashWithDifferentValue = await iteratedHash({ purpose: \"purpose\", value: new TextEncoder().encode(\"hello2\"), iterations: 100_000 });\n  const hashWithDifferentSaltAndExtra = await iteratedHash({ purpose: \"purpose\", value: valueBytes, salt: incrementBytes, extra: incrementBytes, iterations: 100_000 });\n  const hashWithDifferentIterations = await iteratedHash({ purpose: \"purpose\", value: valueBytes, iterations: 100_001 });\n\n\n  expect(hash).toEqual(hash2);\n  expect(hash).not.toEqual(hashWithDifferentPurpose);\n  expect(hash).toEqual(hashWithEmptySalt);\n  expect(hash).not.toEqual(hashWithDifferentSalt);\n  expect(hash).toEqual(hashWithEmptyExtra);\n  expect(hash).not.toEqual(hashWithDifferentExtra);\n  expect(hash).not.toEqual(hashWithDifferentValue);\n  expect(hash).not.toEqual(hashWithDifferentIterations);\n\n  expect(hashWithDifferentSalt).not.toEqual(hashWithDifferentExtra);\n  expect(hashWithDifferentSalt).not.toEqual(hashWithDifferentSaltAndExtra);\n  expect(hashWithDifferentExtra).not.toEqual(hashWithDifferentSaltAndExtra);\n});\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2842, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack-shared/src/utils/uuids.tsx"],"sourcesContent":["import { generateRandomValues } from \"./crypto\";\n\nexport function generateUuid() {\n  // crypto.randomUuid is not supported in all browsers, so this is a polyfill\n  return \"10000000-1000-4000-8000-100000000000\".replace(/[018]/g, c =>\n    (+c ^ generateRandomValues(new Uint8Array(1))[0] & 15 >> +c / 4).toString(16)\n  );\n}\nundefined?.test(\"generateUuid\", ({ expect }) => {\n  // Test that the function returns a valid UUID\n  const uuid = generateUuid();\n  expect(uuid).toMatch(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/);\n\n  // Test that multiple calls generate different UUIDs\n  const uuid2 = generateUuid();\n  expect(uuid).not.toBe(uuid2);\n\n  // Test that the UUID is version 4 (random)\n  expect(uuid.charAt(14)).toBe('4');\n\n  // Test that the UUID has the correct variant (8, 9, a, or b in position 19)\n  expect('89ab').toContain(uuid.charAt(19));\n});\n\nexport function isUuid(str: string) {\n  return /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/.test(str);\n}\nundefined?.test(\"isUuid\", ({ expect }) => {\n  // Test with valid UUIDs\n  expect(isUuid(\"123e4567-e89b-42d3-a456-426614174000\")).toBe(true);\n  expect(isUuid(\"123e4567-e89b-42d3-8456-426614174000\")).toBe(true);\n  expect(isUuid(\"123e4567-e89b-42d3-9456-426614174000\")).toBe(true);\n  expect(isUuid(\"123e4567-e89b-42d3-a456-426614174000\")).toBe(true);\n  expect(isUuid(\"123e4567-e89b-42d3-b456-426614174000\")).toBe(true);\n\n  // Test with invalid UUIDs\n  expect(isUuid(\"\")).toBe(false);\n  expect(isUuid(\"not-a-uuid\")).toBe(false);\n  expect(isUuid(\"123e4567-e89b-12d3-a456-426614174000\")).toBe(false); // Wrong version (not 4)\n  expect(isUuid(\"123e4567-e89b-42d3-c456-426614174000\")).toBe(false); // Wrong variant (not 8, 9, a, or b)\n  expect(isUuid(\"123e4567-e89b-42d3-a456-42661417400\")).toBe(false); // Too short\n  expect(isUuid(\"123e4567-e89b-42d3-a456-4266141740000\")).toBe(false); // Too long\n  expect(isUuid(\"123e4567-e89b-42d3-a456_426614174000\")).toBe(false); // Wrong format (underscore instead of dash)\n\n  // Test with uppercase letters (should fail as UUID should be lowercase)\n  expect(isUuid(\"123E4567-E89B-42D3-A456-426614174000\")).toBe(false);\n});\n"],"names":[],"mappings":";;;;;;;AAAA,SAAS,4BAA4B;;AAE9B,SAAS,eAAe;IAE7B,OAAO,uCAAuC,OAAA,CAAQ,UAAU,CAAA,IAAA,CAC7D,CAAC,QAAI,gPAAA,EAAqB,IAAI,WAAW,CAAC,CAAC,CAAA,CAAE,CAAC,CAAA,GAAI,MAAM,CAAC,IAAI,CAAA,EAAG,QAAA,CAAS,EAAE;AAEhF;AAiBO,SAAS,OAAO,GAAA,EAAa;IAClC,OAAO,wEAAwE,IAAA,CAAK,GAAG;AACzF"}},
    {"offset": {"line": 2863, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack-shared/src/utils/promises.tsx"],"sourcesContent":["import { KnownError } from \"..\";\nimport { StackAssertionError, captureError, concatStacktraces, errorToNiceString } from \"./errors\";\nimport { DependenciesMap } from \"./maps\";\nimport { Result } from \"./results\";\nimport { generateUuid } from \"./uuids\";\n\nexport type ReactPromise<T> = Promise<T> & (\n  | { status: \"rejected\", reason: unknown }\n  | { status: \"fulfilled\", value: T }\n  | { status: \"pending\" }\n);\n\ntype Resolve<T> = (value: T) => void;\ntype Reject = (reason: unknown) => void;\nexport function createPromise<T>(callback: (resolve: Resolve<T>, reject: Reject) => void): ReactPromise<T> {\n  let status = \"pending\" as \"fulfilled\" | \"rejected\" | \"pending\";\n  let valueOrReason: T | unknown | undefined = undefined;\n  let resolve: Resolve<T> | null = null;\n  let reject: Reject | null = null;\n  const promise = new Promise<T>((res, rej) => {\n    resolve = (value) => {\n      if (status !== \"pending\") return;\n      status = \"fulfilled\";\n      valueOrReason = value;\n      res(value);\n    };\n    reject = (reason) => {\n      if (status !== \"pending\") return;\n      status = \"rejected\";\n      valueOrReason = reason;\n      rej(reason);\n    };\n  });\n\n  callback(resolve!, reject!);\n  return Object.assign(promise, {\n    status: status,\n    ...status === \"fulfilled\" ? { value: valueOrReason as T } : {},\n    ...status === \"rejected\" ? { reason: valueOrReason } : {},\n  } as any);\n}\nundefined?.test(\"createPromise\", async ({ expect }) => {\n  // Test resolved promise\n  const resolvedPromise = createPromise<number>((resolve) => {\n    resolve(42);\n  });\n  expect(resolvedPromise.status).toBe(\"fulfilled\");\n  expect((resolvedPromise as any).value).toBe(42);\n  expect(await resolvedPromise).toBe(42);\n\n  // Test rejected promise\n  const error = new Error(\"Test error\");\n  const rejectedPromise = createPromise<number>((_, reject) => {\n    reject(error);\n  });\n  expect(rejectedPromise.status).toBe(\"rejected\");\n  expect((rejectedPromise as any).reason).toBe(error);\n  await expect(rejectedPromise).rejects.toBe(error);\n\n  // Test pending promise\n  const pendingPromise = createPromise<number>(() => {\n    // Do nothing, leave it pending\n  });\n  expect(pendingPromise.status).toBe(\"pending\");\n  expect((pendingPromise as any).value).toBeUndefined();\n  expect((pendingPromise as any).reason).toBeUndefined();\n\n  // Test that resolving after already resolved does nothing\n  let resolveCount = 0;\n  const multiResolvePromise = createPromise<number>((resolve) => {\n    resolve(1);\n    resolveCount++;\n    resolve(2);\n    resolveCount++;\n  });\n  expect(resolveCount).toBe(2); // Both resolve calls executed\n  expect(multiResolvePromise.status).toBe(\"fulfilled\");\n  expect((multiResolvePromise as any).value).toBe(1); // Only first resolve took effect\n  expect(await multiResolvePromise).toBe(1);\n});\n\nlet resolvedCache: DependenciesMap<[unknown], ReactPromise<unknown>> | null = null;\n/**\n * Like Promise.resolve(...), but also adds the status and value properties for use with React's `use` hook, and caches\n * the value so that invoking `resolved` twice returns the same promise.\n */\nexport function resolved<T>(value: T): ReactPromise<T> {\n  resolvedCache ??= new DependenciesMap<[unknown], ReactPromise<unknown>>();\n  if (resolvedCache.has([value])) {\n    return resolvedCache.get([value]) as ReactPromise<T>;\n  }\n\n  const res = Object.assign(Promise.resolve(value), {\n    status: \"fulfilled\",\n    value,\n  } as const);\n  resolvedCache.set([value], res);\n  return res;\n}\nundefined?.test(\"resolved\", async ({ expect }) => {\n  // Test with primitive value\n  const promise1 = resolved(42);\n  expect(promise1.status).toBe(\"fulfilled\");\n  // Need to use type assertion since value is only available when status is \"fulfilled\"\n  expect((promise1 as { value: number }).value).toBe(42);\n  expect(await promise1).toBe(42);\n\n  // Test with object value\n  const obj = { test: true };\n  const promise2 = resolved(obj);\n  expect(promise2.status).toBe(\"fulfilled\");\n  expect((promise2 as { value: typeof obj }).value).toBe(obj);\n  expect(await promise2).toBe(obj);\n\n  // Test caching (same reference for same value)\n  const promise3 = resolved(42);\n  expect(promise3).toBe(promise1); // Same reference due to caching\n\n  // Test with different value (different reference)\n  const promise4 = resolved(43);\n  expect(promise4).not.toBe(promise1);\n});\n\nlet rejectedCache: DependenciesMap<[unknown], ReactPromise<unknown>> | null = null;\n/**\n * Like Promise.reject(...), but also adds the status and value properties for use with React's `use` hook, and caches\n * the value so that invoking `rejected` twice returns the same promise.\n */\nexport function rejected<T>(reason: unknown): ReactPromise<T> {\n  rejectedCache ??= new DependenciesMap<[unknown], ReactPromise<unknown>>();\n  if (rejectedCache.has([reason])) {\n    return rejectedCache.get([reason]) as ReactPromise<T>;\n  }\n\n  const promise = Promise.reject(reason);\n  ignoreUnhandledRejection(promise);\n  const res = Object.assign(promise, {\n    status: \"rejected\",\n    reason: reason,\n  } as const);\n  rejectedCache.set([reason], res);\n  return res;\n}\nundefined?.test(\"rejected\", ({ expect }) => {\n  // Test with error object\n  const error = new Error(\"Test error\");\n  const promise1 = rejected<number>(error);\n  expect(promise1.status).toBe(\"rejected\");\n  // Need to use type assertion since reason is only available when status is \"rejected\"\n  expect((promise1 as { reason: Error }).reason).toBe(error);\n\n  // Test with string reason\n  const promise2 = rejected<string>(\"error message\");\n  expect(promise2.status).toBe(\"rejected\");\n  expect((promise2 as { reason: string }).reason).toBe(\"error message\");\n\n  // Test caching (same reference for same reason)\n  const promise3 = rejected<number>(error);\n  expect(promise3).toBe(promise1); // Same reference due to caching\n\n  // Test with different reason (different reference)\n  const differentError = new Error(\"Different error\");\n  const promise4 = rejected<number>(differentError);\n  expect(promise4).not.toBe(promise1);\n\n  // Note: We're not using await expect(promise).rejects to avoid unhandled rejections\n});\n\n// We'll skip the rejection test for pending() since it's causing unhandled rejections\n// The function is already well tested through other tests like rejected() and createPromise()\n\n\nconst neverResolvePromise = pending(new Promise<never>(() => {}));\nexport function neverResolve(): ReactPromise<never> {\n  return neverResolvePromise;\n}\nundefined?.test(\"neverResolve\", ({ expect }) => {\n  const promise = neverResolve();\n  expect(promise.status).toBe(\"pending\");\n  expect((promise as any).value).toBeUndefined();\n  expect((promise as any).reason).toBeUndefined();\n\n  // Test that multiple calls return the same promise\n  const promise2 = neverResolve();\n  expect(promise2).toBe(promise);\n});\n\nexport function pending<T>(promise: Promise<T>, options: { disableErrorWrapping?: boolean } = {}): ReactPromise<T> {\n  const res = promise.then(\n    value => {\n      res.status = \"fulfilled\";\n      (res as any).value = value;\n      return value;\n    },\n    actualReason => {\n      res.status = \"rejected\";\n      (res as any).reason = actualReason;\n      throw actualReason;\n    },\n  ) as ReactPromise<T>;\n  res.status = \"pending\";\n  return res;\n}\nundefined?.test(\"pending\", async ({ expect }) => {\n  // Test with a promise that resolves\n  const resolvePromise = Promise.resolve(42);\n  const pendingPromise = pending(resolvePromise);\n\n  // Initially it should be pending\n  expect(pendingPromise.status).toBe(\"pending\");\n\n  // After resolution, it should be fulfilled\n  await resolvePromise;\n  // Need to wait a tick for the then handler to execute\n  await new Promise(resolve => setTimeout(resolve, 0));\n  expect(pendingPromise.status).toBe(\"fulfilled\");\n  expect((pendingPromise as { value: number }).value).toBe(42);\n\n  // For the rejection test, we'll use a separate test to avoid unhandled rejections\n});\n\n/**\n * Should be used to wrap Promises that are not immediately awaited, so they don't throw an unhandled promise rejection\n * error.\n *\n * Vercel kills serverless functions on unhandled promise rejection errors, so this is important.\n */\nexport function ignoreUnhandledRejection<T extends Promise<any>>(promise: T): void {\n  promise.catch(() => {});\n}\nundefined?.test(\"ignoreUnhandledRejection\", async ({ expect }) => {\n  // Test with a promise that resolves\n  const resolvePromise = Promise.resolve(42);\n  ignoreUnhandledRejection(resolvePromise);\n  expect(await resolvePromise).toBe(42); // Should still resolve to the same value\n\n  // Test with a promise that rejects\n  // The promise should still reject, but the rejection is caught internally\n  // so it doesn't cause an unhandled rejection error\n  const error = new Error(\"Test error\");\n  const rejectPromise = Promise.reject(error);\n  ignoreUnhandledRejection(rejectPromise);\n  await expect(rejectPromise).rejects.toBe(error);\n});\n\n/**\n * See concatStacktraces for more information.\n */\nexport function concatStacktracesIfRejected<T>(promise: Promise<T>): void {\n  const currentError = new Error();\n  promise.catch(error => {\n    if (error instanceof Error) {\n      concatStacktraces(error, currentError);\n    } else {\n      // we can only concatenate errors, so we'll just ignore the non-error\n    }\n  });\n}\n\nexport async function wait(ms: number) {\n  if (!Number.isFinite(ms) || ms < 0) {\n    throw new StackAssertionError(`wait() requires a non-negative integer number of milliseconds to wait. (found: ${ms}ms)`);\n  }\n  if (ms >= 2**31) {\n    throw new StackAssertionError(\"The maximum timeout for wait() is 2147483647ms (2**31 - 1). (found: ${ms}ms)\");\n  }\n  return await new Promise<void>(resolve => setTimeout(resolve, ms));\n}\nundefined?.test(\"wait\", async ({ expect }) => {\n  // Test with valid input\n  const start = Date.now();\n  await wait(10);\n  const elapsed = Date.now() - start;\n  expect(elapsed).toBeGreaterThanOrEqual(5); // Allow some flexibility in timing\n\n  // Test with zero\n  await expect(wait(0)).resolves.toBeUndefined();\n\n  // Test with negative number\n  await expect(wait(-10)).rejects.toThrow(\"wait() requires a non-negative integer\");\n\n  // Test with non-finite number\n  await expect(wait(NaN)).rejects.toThrow(\"wait() requires a non-negative integer\");\n  await expect(wait(Infinity)).rejects.toThrow(\"wait() requires a non-negative integer\");\n\n  // Test with too large number\n  await expect(wait(2**31)).rejects.toThrow(\"The maximum timeout for wait()\");\n});\n\nexport async function waitUntil(date: Date) {\n  return await wait(date.getTime() - Date.now());\n}\nundefined?.test(\"waitUntil\", async ({ expect }) => {\n  // Test with future date\n  const futureDate = new Date(Date.now() + 10);\n  const start = Date.now();\n  await waitUntil(futureDate);\n  const elapsed = Date.now() - start;\n  expect(elapsed).toBeGreaterThanOrEqual(5); // Allow some flexibility in timing\n\n  // Test with past date - this will throw because wait() requires non-negative time\n  // We need to verify it throws the correct error\n  try {\n    await waitUntil(new Date(Date.now() - 1000));\n    expect.fail(\"Should have thrown an error\");\n  } catch (error) {\n    expect(error).toBeInstanceOf(StackAssertionError);\n    expect((error as Error).message).toContain(\"wait() requires a non-negative integer\");\n  }\n});\n\nexport function runAsynchronouslyWithAlert(...args: Parameters<typeof runAsynchronously>) {\n  return runAsynchronously(\n    args[0],\n    {\n      ...args[1],\n      onError: error => {\n        if (KnownError.isKnownError(error) && typeof process !== \"undefined\" && (process.env.NODE_ENV as any)?.includes(\"production\")) {\n          alert(error.message);\n        } else {\n          alert(`An unhandled error occurred. Please ${process.env.NODE_ENV === \"development\" ? `check the browser console for the full error.` : \"report this to the developer.\"}\\n\\n${error}`);\n        }\n        args[1]?.onError?.(error);\n      },\n    },\n    ...args.slice(2) as [],\n  );\n}\nundefined?.test(\"runAsynchronouslyWithAlert\", ({ expect }) => {\n  // Simple test to verify the function calls runAsynchronously\n  // We can't easily test the alert functionality without mocking\n  const testFn = () => Promise.resolve(\"test\");\n  const testOptions = { noErrorLogging: true };\n\n  // Just verify it doesn't throw\n  expect(() => runAsynchronouslyWithAlert(testFn, testOptions)).not.toThrow();\n\n  // We can't easily test the error handling without mocking, so we'll\n  // just verify the function exists and can be called\n  expect(typeof runAsynchronouslyWithAlert).toBe(\"function\");\n});\n\nexport function runAsynchronously(\n  promiseOrFunc: void | Promise<unknown> | (() => void | Promise<unknown>) | undefined,\n  options: {\n    noErrorLogging?: boolean,\n    onError?: (error: Error) => void,\n  } = {},\n): void {\n  if (typeof promiseOrFunc === \"function\") {\n    promiseOrFunc = promiseOrFunc();\n  }\n  if (promiseOrFunc) {\n    concatStacktracesIfRejected(promiseOrFunc);\n    promiseOrFunc.catch(error => {\n      options.onError?.(error);\n      const newError = new StackAssertionError(\n        \"Uncaught error in asynchronous function: \" + errorToNiceString(error),\n        { cause: error },\n      );\n      if (!options.noErrorLogging) {\n        captureError(\"runAsynchronously\", newError);\n      }\n    });\n  }\n}\nundefined?.test(\"runAsynchronously\", ({ expect }) => {\n  // Simple test to verify the function exists and can be called\n  const testFn = () => Promise.resolve(\"test\");\n\n  // Just verify it doesn't throw\n  expect(() => runAsynchronously(testFn)).not.toThrow();\n  expect(() => runAsynchronously(Promise.resolve(\"test\"))).not.toThrow();\n  expect(() => runAsynchronously(undefined)).not.toThrow();\n\n  // We can't easily test the error handling without mocking, so we'll\n  // just verify the function exists and can be called with options\n  expect(() => runAsynchronously(testFn, { noErrorLogging: true })).not.toThrow();\n  expect(() => runAsynchronously(testFn, { onError: () => {} })).not.toThrow();\n});\n\n\nclass TimeoutError extends Error {\n  constructor(public readonly ms: number) {\n    super(`Timeout after ${ms}ms`);\n    this.name = \"TimeoutError\";\n  }\n}\n\nexport async function timeout<T>(promiseOrFunc: Promise<T> | (() => Promise<T>), ms: number): Promise<Result<T, TimeoutError>> {\n  const promise = typeof promiseOrFunc === \"function\" ? promiseOrFunc() : promiseOrFunc;\n  return await Promise.race([\n    promise.then(value => Result.ok(value)),\n    wait(ms).then(() => Result.error(new TimeoutError(ms))),\n  ]);\n}\nundefined?.test(\"timeout\", async ({ expect }) => {\n  // Test with a promise that resolves quickly\n  const fastPromise = Promise.resolve(42);\n  const fastResult = await timeout(fastPromise, 100);\n  expect(fastResult.status).toBe(\"ok\");\n  if (fastResult.status === \"ok\") {\n    expect(fastResult.data).toBe(42);\n  }\n\n  // Test with a promise that takes longer than the timeout\n  const slowPromise = new Promise(resolve => setTimeout(() => resolve(\"too late\"), 50));\n  const slowResult = await timeout(slowPromise, 10);\n  expect(slowResult.status).toBe(\"error\");\n  if (slowResult.status === \"error\") {\n    expect(slowResult.error).toBeInstanceOf(TimeoutError);\n    expect((slowResult.error as TimeoutError).ms).toBe(10);\n  }\n});\n\nexport async function timeoutThrow<T>(promise: Promise<T>, ms: number): Promise<T> {\n  return Result.orThrow(await timeout(promise, ms));\n}\nundefined?.test(\"timeoutThrow\", async ({ expect }) => {\n  // Test with a promise that resolves quickly\n  const fastPromise = Promise.resolve(42);\n  const fastResult = await timeoutThrow(fastPromise, 100);\n  expect(fastResult).toBe(42);\n\n  // Test with a promise that takes longer than the timeout\n  const slowPromise = new Promise(resolve => setTimeout(() => resolve(\"too late\"), 50));\n  await expect(timeoutThrow(slowPromise, 10)).rejects.toThrow(\"Timeout after 10ms\");\n  await expect(timeoutThrow(slowPromise, 10)).rejects.toBeInstanceOf(TimeoutError);\n});\n\n\nexport type RateLimitOptions = {\n  /**\n   * The number of requests to process in parallel. Currently only 1 is supported.\n   */\n  concurrency: 1,\n\n  /**\n   * If true, multiple requests waiting at the same time will be reduced to just one. Default is false.\n   */\n  batchCalls?: boolean,\n\n  /**\n   * Waits for throttleMs since the start of last request before starting the next request. Default is 0.\n   */\n  throttleMs?: number,\n\n  /**\n   * Waits for gapMs since the end of last request before starting the next request. Default is 0.\n   */\n  gapMs?: number,\n\n  /**\n   * Waits until there have been no new requests for debounceMs before starting a new request. Default is 0.\n   */\n  debounceMs?: number,\n};\n\nexport function rateLimited<T>(\n  func: () => Promise<T>,\n  options: RateLimitOptions,\n): () => Promise<T> {\n  let waitUntil = performance.now();\n  let queue: [(t: T) => void, (e: unknown) => void][] = [];\n  let addedToQueueCallbacks = new Map<string, () => void>;\n\n  const next = async () => {\n    while (true) {\n      if (waitUntil > performance.now()) {\n        await wait(Math.max(1, waitUntil - performance.now() + 1));\n      } else if (queue.length === 0) {\n        const uuid = generateUuid();\n        await new Promise<void>(resolve => {\n          addedToQueueCallbacks.set(uuid, resolve);\n        });\n        addedToQueueCallbacks.delete(uuid);\n      } else {\n        break;\n      }\n    }\n    const nextFuncs = options.batchCalls ? queue.splice(0, queue.length) : [queue.shift()!];\n\n    const start = performance.now();\n    const value = await Result.fromPromise(func());\n    const end = performance.now();\n\n    waitUntil = Math.max(\n      waitUntil,\n      start + (options.throttleMs ?? 0),\n      end + (options.gapMs ?? 0),\n    );\n\n    for (const nextFunc of nextFuncs) {\n      if (value.status === \"ok\") {\n        nextFunc[0](value.data);\n      } else {\n        nextFunc[1](value.error);\n      }\n    }\n  };\n\n  runAsynchronously(async () => {\n    while (true) {\n      await next();\n    }\n  });\n\n  return () => {\n    return new Promise<T>((resolve, reject) => {\n      waitUntil = Math.max(\n        waitUntil,\n        performance.now() + (options.debounceMs ?? 0),\n      );\n      queue.push([resolve, reject]);\n      addedToQueueCallbacks.forEach(cb => cb());\n    });\n  };\n}\n\nexport function throttled<T, A extends any[]>(func: (...args: A) => Promise<T>, delayMs: number): (...args: A) => Promise<T> {\n  let timeout: ReturnType<typeof setTimeout> | null = null;\n  let nextAvailable: Promise<T> | null = null;\n  return async (...args) => {\n    while (nextAvailable !== null) {\n      await nextAvailable;\n    }\n    nextAvailable = new Promise<T>(resolve => {\n      timeout = setTimeout(() => {\n        nextAvailable = null;\n        resolve(func(...args));\n      }, delayMs);\n    });\n    return await nextAvailable;\n  };\n}\n"],"names":["waitUntil","timeout"],"mappings":"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"}},
    {"offset": {"line": 3138, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack-shared/src/utils/results.tsx"],"sourcesContent":["import { wait } from \"./promises\";\nimport { deindent, nicify } from \"./strings\";\n\nexport type Result<T, E = unknown> =\n  | {\n    status: \"ok\",\n    data: T,\n  }\n  | {\n    status: \"error\",\n    error: E,\n  };\n\nexport type AsyncResult<T, E = unknown, P = void> =\n  | Result<T, E>\n  | (\n    & {\n      status: \"pending\",\n    }\n    & {\n      progress: P,\n    }\n  );\n\n\nexport const Result = {\n  fromThrowing,\n  fromThrowingAsync,\n  fromPromise: promiseToResult,\n  ok<T>(data: T): Result<T, never> & { status: \"ok\" } {\n    return {\n      status: \"ok\",\n      data,\n    };\n  },\n  error<E>(error: E): Result<never, E> & { status: \"error\" } {\n    return {\n      status: \"error\",\n      error,\n    };\n  },\n  map: mapResult,\n  or: <T, E, U>(result: Result<T, E>, fallback: U): T | U => {\n    return result.status === \"ok\" ? result.data : fallback;\n  },\n  orThrow: <T, E>(result: Result<T, E>): T => {\n    if (result.status === \"error\") {\n      throw result.error;\n    }\n    return result.data;\n  },\n  orThrowAsync: async <T, E>(result: Promise<Result<T, E>>): Promise<T> => {\n    return Result.orThrow(await result);\n  },\n  retry,\n};\nundefined?.test(\"Result.ok and Result.error\", ({ expect }) => {\n  // Test Result.ok\n  const okResult = Result.ok(42);\n  expect(okResult.status).toBe(\"ok\");\n  expect(okResult.data).toBe(42);\n\n  // Test Result.error\n  const error = new Error(\"Test error\");\n  const errorResult = Result.error(error);\n  expect(errorResult.status).toBe(\"error\");\n  expect(errorResult.error).toBe(error);\n});\n\nundefined?.test(\"Result.or\", ({ expect }) => {\n  // Test with ok result\n  const okResult: Result<number, string> = { status: \"ok\", data: 42 };\n  expect(Result.or(okResult, 0)).toBe(42);\n\n  // Test with error result\n  const errorResult: Result<number, string> = { status: \"error\", error: \"error message\" };\n  expect(Result.or(errorResult, 0)).toBe(0);\n});\n\nundefined?.test(\"Result.orThrow\", ({ expect }) => {\n  // Test with ok result\n  const okResult: Result<number, Error> = { status: \"ok\", data: 42 };\n  expect(Result.orThrow(okResult)).toBe(42);\n\n  // Test with error result\n  const error = new Error(\"Test error\");\n  const errorResult: Result<number, Error> = { status: \"error\", error };\n  expect(() => Result.orThrow(errorResult)).toThrow(error);\n});\n\nundefined?.test(\"Result.orThrowAsync\", async ({ expect }) => {\n  // Test with ok result\n  const okPromise = Promise.resolve({ status: \"ok\", data: 42 } as Result<number, Error>);\n  expect(await Result.orThrowAsync(okPromise)).toBe(42);\n\n  // Test with error result\n  const error = new Error(\"Test error\");\n  const errorPromise = Promise.resolve({ status: \"error\", error } as Result<number, Error>);\n  await expect(Result.orThrowAsync(errorPromise)).rejects.toThrow(error);\n});\n\nexport const AsyncResult = {\n  fromThrowing,\n  fromPromise: promiseToResult,\n  ok: Result.ok,\n  error: Result.error,\n  pending,\n  map: mapResult,\n  or: <T, E, P, U>(result: AsyncResult<T, E, P>, fallback: U): T | U => {\n    if (result.status === \"pending\") {\n      return fallback;\n    }\n    return Result.or(result, fallback);\n  },\n  orThrow: <T, E, P>(result: AsyncResult<T, E, P>): T => {\n    if (result.status === \"pending\") {\n      throw new Error(\"Result still pending\");\n    }\n    return Result.orThrow(result);\n  },\n  retry,\n};\nundefined?.test(\"AsyncResult.or\", ({ expect }) => {\n  // Test with ok result\n  const okResult: AsyncResult<number, string> = { status: \"ok\", data: 42 };\n  expect(AsyncResult.or(okResult, 0)).toBe(42);\n\n  // Test with error result\n  const errorResult: AsyncResult<number, string> = { status: \"error\", error: \"error message\" };\n  expect(AsyncResult.or(errorResult, 0)).toBe(0);\n\n  // Test with pending result\n  const pendingResult: AsyncResult<number, string> = { status: \"pending\", progress: undefined };\n  expect(AsyncResult.or(pendingResult, 0)).toBe(0);\n});\n\nundefined?.test(\"AsyncResult.orThrow\", ({ expect }) => {\n  // Test with ok result\n  const okResult: AsyncResult<number, Error> = { status: \"ok\", data: 42 };\n  expect(AsyncResult.orThrow(okResult)).toBe(42);\n\n  // Test with error result\n  const error = new Error(\"Test error\");\n  const errorResult: AsyncResult<number, Error> = { status: \"error\", error };\n  expect(() => AsyncResult.orThrow(errorResult)).toThrow(error);\n\n  // Test with pending result\n  const pendingResult: AsyncResult<number, Error> = { status: \"pending\", progress: undefined };\n  expect(() => AsyncResult.orThrow(pendingResult)).toThrow(\"Result still pending\");\n});\n\nfunction pending(): AsyncResult<never, never, void> & { status: \"pending\" };\nfunction pending<P>(progress: P): AsyncResult<never, never, P> & { status: \"pending\" };\nfunction pending<P>(progress?: P): AsyncResult<never, never, P> & { status: \"pending\" } {\n  return {\n    status: \"pending\",\n    progress: progress!,\n  };\n}\nundefined?.test(\"pending\", ({ expect }) => {\n  // Test without progress\n  const pendingResult = pending();\n  expect(pendingResult.status).toBe(\"pending\");\n  expect(pendingResult.progress).toBe(undefined);\n\n  // Test with progress\n  const progressValue = { loaded: 50, total: 100 };\n  const pendingWithProgress = pending(progressValue);\n  expect(pendingWithProgress.status).toBe(\"pending\");\n  expect(pendingWithProgress.progress).toBe(progressValue);\n});\n\nasync function promiseToResult<T>(promise: Promise<T>): Promise<Result<T>> {\n  try {\n    const value = await promise;\n    return Result.ok(value);\n  } catch (error) {\n    return Result.error(error);\n  }\n}\nundefined?.test(\"promiseToResult\", async ({ expect }) => {\n  // Test with resolved promise\n  const resolvedPromise = Promise.resolve(42);\n  const resolvedResult = await promiseToResult(resolvedPromise);\n  expect(resolvedResult.status).toBe(\"ok\");\n  if (resolvedResult.status === \"ok\") {\n    expect(resolvedResult.data).toBe(42);\n  }\n\n  // Test with rejected promise\n  const error = new Error(\"Test error\");\n  const rejectedPromise = Promise.reject(error);\n  const rejectedResult = await promiseToResult(rejectedPromise);\n  expect(rejectedResult.status).toBe(\"error\");\n  if (rejectedResult.status === \"error\") {\n    expect(rejectedResult.error).toBe(error);\n  }\n});\n\nfunction fromThrowing<T>(fn: () => T): Result<T, unknown> {\n  try {\n    return Result.ok(fn());\n  } catch (error) {\n    return Result.error(error);\n  }\n}\nundefined?.test(\"fromThrowing\", ({ expect }) => {\n  // Test with function that succeeds\n  const successFn = () => 42;\n  const successResult = fromThrowing(successFn);\n  expect(successResult.status).toBe(\"ok\");\n  if (successResult.status === \"ok\") {\n    expect(successResult.data).toBe(42);\n  }\n\n  // Test with function that throws\n  const error = new Error(\"Test error\");\n  const errorFn = () => {\n    throw error;\n  };\n  const errorResult = fromThrowing(errorFn);\n  expect(errorResult.status).toBe(\"error\");\n  if (errorResult.status === \"error\") {\n    expect(errorResult.error).toBe(error);\n  }\n});\n\nasync function fromThrowingAsync<T>(fn: () => Promise<T>): Promise<Result<T, unknown>> {\n  try {\n    return Result.ok(await fn());\n  } catch (error) {\n    return Result.error(error);\n  }\n}\nundefined?.test(\"fromThrowingAsync\", async ({ expect }) => {\n  // Test with async function that succeeds\n  const successFn = async () => 42;\n  const successResult = await fromThrowingAsync(successFn);\n  expect(successResult.status).toBe(\"ok\");\n  if (successResult.status === \"ok\") {\n    expect(successResult.data).toBe(42);\n  }\n\n  // Test with async function that throws\n  const error = new Error(\"Test error\");\n  const errorFn = async () => {\n    throw error;\n  };\n  const errorResult = await fromThrowingAsync(errorFn);\n  expect(errorResult.status).toBe(\"error\");\n  if (errorResult.status === \"error\") {\n    expect(errorResult.error).toBe(error);\n  }\n});\n\nfunction mapResult<T, U, E = unknown, P = unknown>(result: Result<T, E>, fn: (data: T) => U): Result<U, E>;\nfunction mapResult<T, U, E = unknown, P = unknown>(result: AsyncResult<T, E, P>, fn: (data: T) => U): AsyncResult<U, E, P>;\nfunction mapResult<T, U, E = unknown, P = unknown>(result: AsyncResult<T, E, P>, fn: (data: T) => U): AsyncResult<U, E, P> {\n  if (result.status === \"error\") return {\n    status: \"error\",\n    error: result.error,\n  };\n  if (result.status === \"pending\") return {\n    status: \"pending\",\n    ...\"progress\" in result ? { progress: result.progress } : {},\n  } as any;\n\n  return Result.ok(fn(result.data));\n}\nundefined?.test(\"mapResult\", ({ expect }) => {\n  // Test with ok result\n  const okResult: Result<number, string> = { status: \"ok\", data: 42 };\n  const mappedOk = mapResult(okResult, (n: number) => n * 2);\n  expect(mappedOk.status).toBe(\"ok\");\n  if (mappedOk.status === \"ok\") {\n    expect(mappedOk.data).toBe(84);\n  }\n\n  // Test with error result\n  const errorResult: Result<number, string> = { status: \"error\", error: \"error message\" };\n  const mappedError = mapResult(errorResult, (n: number) => n * 2);\n  expect(mappedError.status).toBe(\"error\");\n  if (mappedError.status === \"error\") {\n    expect(mappedError.error).toBe(\"error message\");\n  }\n\n  // Test with pending result (no progress)\n  const pendingResult: AsyncResult<number, string, void> = { status: \"pending\", progress: undefined };\n  const mappedPending = mapResult(pendingResult, (n: number) => n * 2);\n  expect(mappedPending.status).toBe(\"pending\");\n\n  // Test with pending result (with progress)\n  const progressValue = { loaded: 50, total: 100 };\n  const pendingWithProgress: AsyncResult<number, string, typeof progressValue> = {\n    status: \"pending\",\n    progress: progressValue\n  };\n  const mappedPendingWithProgress = mapResult(pendingWithProgress, (n: number) => n * 2);\n  expect(mappedPendingWithProgress.status).toBe(\"pending\");\n  if (mappedPendingWithProgress.status === \"pending\") {\n    expect(mappedPendingWithProgress.progress).toBe(progressValue);\n  }\n});\n\n\nclass RetryError extends AggregateError {\n  constructor(public readonly errors: unknown[]) {\n    const strings = errors.map(e => nicify(e));\n    const isAllSame = strings.length > 1 && strings.every(s => s === strings[0]);\n    super(\n      errors,\n      deindent`\n      Error after ${errors.length} attempts.\n      \n      ${isAllSame ? deindent`\n        Attempts 1-${errors.length}:\n          ${strings[0]}\n      ` : strings.map((s, i) => deindent`\n          Attempt ${i + 1}:\n            ${s}\n        `).join(\"\\n\\n\")}\n      `,\n      { cause: errors[errors.length - 1] }\n    );\n    this.name = \"RetryError\";\n  }\n\n  get attempts() {\n    return this.errors.length;\n  }\n}\nRetryError.prototype.name = \"RetryError\";\n\nundefined?.test(\"RetryError\", ({ expect }) => {\n  // Test with single error\n  const singleError = new Error(\"Single error\");\n  const retryErrorSingle = new RetryError([singleError]);\n  expect(retryErrorSingle.name).toBe(\"RetryError\");\n  expect(retryErrorSingle.errors).toEqual([singleError]);\n  expect(retryErrorSingle.attempts).toBe(1);\n  expect(retryErrorSingle.cause).toBe(singleError);\n  expect(retryErrorSingle.message).toContain(\"Error after 1 attempts\");\n\n  // Test with multiple different errors\n  const error1 = new Error(\"Error 1\");\n  const error2 = new Error(\"Error 2\");\n  const retryErrorMultiple = new RetryError([error1, error2]);\n  expect(retryErrorMultiple.name).toBe(\"RetryError\");\n  expect(retryErrorMultiple.errors).toEqual([error1, error2]);\n  expect(retryErrorMultiple.attempts).toBe(2);\n  expect(retryErrorMultiple.cause).toBe(error2);\n  expect(retryErrorMultiple.message).toContain(\"Error after 2 attempts\");\n  expect(retryErrorMultiple.message).toContain(\"Attempt 1\");\n  expect(retryErrorMultiple.message).toContain(\"Attempt 2\");\n\n  // Test with multiple identical errors\n  const sameError = new Error(\"Same error\");\n  const retryErrorSame = new RetryError([sameError, sameError]);\n  expect(retryErrorSame.name).toBe(\"RetryError\");\n  expect(retryErrorSame.errors).toEqual([sameError, sameError]);\n  expect(retryErrorSame.attempts).toBe(2);\n  expect(retryErrorSame.cause).toBe(sameError);\n  expect(retryErrorSame.message).toContain(\"Error after 2 attempts\");\n  expect(retryErrorSame.message).toContain(\"Attempts 1-2\");\n});\n\nasync function retry<T>(\n  fn: (attemptIndex: number) => Result<T> | Promise<Result<T>>,\n  totalAttempts: number,\n  { exponentialDelayBase = 1000 } = {},\n): Promise<Result<T, RetryError> & { attempts: number }> {\n  const errors: unknown[] = [];\n  for (let i = 0; i < totalAttempts; i++) {\n    const res = await fn(i);\n    if (res.status === \"ok\") {\n      return Object.assign(Result.ok(res.data), { attempts: i + 1 });\n    } else {\n      errors.push(res.error);\n      if (i < totalAttempts - 1) {\n        await wait((Math.random() + 0.5) * exponentialDelayBase * (2 ** i));\n      }\n    }\n  }\n  return Object.assign(Result.error(new RetryError(errors)), { attempts: totalAttempts });\n}\nundefined?.test(\"retry\", async ({ expect }) => {\n  // Test successful on first attempt\n  const successFn = async () => Result.ok(\"success\");\n  const successResult = await retry(successFn, 3, { exponentialDelayBase: 0 });\n    expect(successResult).toEqual({ status: \"ok\", data: \"success\", attempts: 1 });\n\n    // Test successful after failures\n    let attemptCount = 0;\n    const eventualSuccessFn = async () => {\n      return ++attemptCount < 2 ? Result.error(new Error(`Attempt ${attemptCount} failed`))\n        : Result.ok(\"eventual success\");\n    };\n    const eventualSuccessResult = await retry(eventualSuccessFn, 3, { exponentialDelayBase: 0 });\n    expect(eventualSuccessResult).toEqual({ status: \"ok\", data: \"eventual success\", attempts: 2 });\n\n    // Test all attempts fail\n    const errors = [new Error(\"Error 1\"), new Error(\"Error 2\"), new Error(\"Error 3\")];\n    const allFailFn = async (attempt: number) => {\n      return Result.error(errors[attempt]);\n    };\n    const allFailResult = await retry(allFailFn, 3, { exponentialDelayBase: 0 });\n    expect(allFailResult).toEqual({ status: \"error\", error: expect.any(RetryError), attempts: 3 });\n    const retryError = (allFailResult as any).error as RetryError;\n    expect(retryError.errors).toEqual(errors);\n    expect(retryError.attempts).toBe(3);\n});\n"],"names":[],"mappings":";;;;;;;AAAA,SAAS,YAAY;AACrB,SAAS,UAAU,cAAc;;;AAwB1B,IAAM,SAAS;IACpB;IACA;IACA,aAAa;IACb,IAAM,IAAA,EAA8C;QAClD,OAAO;YACL,QAAQ;YACR;QACF;IACF;IACA,OAAS,KAAA,EAAkD;QACzD,OAAO;YACL,QAAQ;YACR;QACF;IACF;IACA,KAAK;IACL,IAAI,CAAU,QAAsB,aAAuB;QACzD,OAAO,OAAO,MAAA,KAAW,OAAO,OAAO,IAAA,GAAO;IAChD;IACA,SAAS,CAAO,WAA4B;QAC1C,IAAI,OAAO,MAAA,KAAW,SAAS;YAC7B,MAAM,OAAO,KAAA;QACf;QACA,OAAO,OAAO,IAAA;IAChB;IACA,cAAc,OAAa,WAA8C;QACvE,OAAO,OAAO,OAAA,CAAQ,MAAM,MAAM;IACpC;IACA;AACF;AA8CO,IAAM,cAAc;IACzB;IACA,aAAa;IACb,IAAI,OAAO,EAAA;IACX,OAAO,OAAO,KAAA;IACd;IACA,KAAK;IACL,IAAI,CAAa,QAA8B,aAAuB;QACpE,IAAI,OAAO,MAAA,KAAW,WAAW;YAC/B,OAAO;QACT;QACA,OAAO,OAAO,EAAA,CAAG,QAAQ,QAAQ;IACnC;IACA,SAAS,CAAU,WAAoC;QACrD,IAAI,OAAO,MAAA,KAAW,WAAW;YAC/B,MAAM,IAAI,MAAM,sBAAsB;QACxC;QACA,OAAO,OAAO,OAAA,CAAQ,MAAM;IAC9B;IACA;AACF;AAgCA,SAAS,QAAW,QAAA,EAAoE;IACtF,OAAO;QACL,QAAQ;QACR;IACF;AACF;AAcA,eAAe,gBAAmB,OAAA,EAAyC;IACzE,IAAI;QACF,MAAM,QAAQ,MAAM;QACpB,OAAO,OAAO,EAAA,CAAG,KAAK;IACxB,EAAA,OAAS,OAAO;QACd,OAAO,OAAO,KAAA,CAAM,KAAK;IAC3B;AACF;AAoBA,SAAS,aAAgB,EAAA,EAAiC;IACxD,IAAI;QACF,OAAO,OAAO,EAAA,CAAG,GAAG,CAAC;IACvB,EAAA,OAAS,OAAO;QACd,OAAO,OAAO,KAAA,CAAM,KAAK;IAC3B;AACF;AAsBA,eAAe,kBAAqB,EAAA,EAAmD;IACrF,IAAI;QACF,OAAO,OAAO,EAAA,CAAG,MAAM,GAAG,CAAC;IAC7B,EAAA,OAAS,OAAO;QACd,OAAO,OAAO,KAAA,CAAM,KAAK;IAC3B;AACF;AAwBA,SAAS,UAA0C,MAAA,EAA8B,EAAA,EAA0C;IACzH,IAAI,OAAO,MAAA,KAAW,QAAS,CAAA,OAAO;QACpC,QAAQ;QACR,OAAO,OAAO,KAAA;IAChB;IACA,IAAI,OAAO,MAAA,KAAW,UAAW,CAAA,OAAO;QACtC,QAAQ;QACR,GAAG,cAAc,SAAS;YAAE,UAAU,OAAO,QAAA;QAAS,IAAI,CAAC,CAAA;IAC7D;IAEA,OAAO,OAAO,EAAA,CAAG,GAAG,OAAO,IAAI,CAAC;AAClC;AAqCA,IAAM,aAAN,cAAyB,eAAe;IACtC,YAA4B,MAAA,CAAmB;QAC7C,MAAM,UAAU,OAAO,GAAA,CAAI,CAAA,QAAK,mOAAA,EAAO,CAAC,CAAC;QACzC,MAAM,YAAY,QAAQ,MAAA,GAAS,KAAK,QAAQ,KAAA,CAAM,CAAA,IAAK,MAAM,OAAA,CAAQ,CAAC,CAAC;QAC3E,KAAA,CACE,QACA,qOAAA,CAAA;kBAAA,EACc,OAAO,MAAM,CAAA;;MAAA,EAEzB,YAAY,qOAAA,CAAA;mBAAA,EACC,OAAO,MAAM,CAAA;UAAA,EACtB,OAAA,CAAQ,CAAC,CAAC,CAAA;MAAA,CAAA,GACZ,QAAQ,GAAA,CAAI,CAAC,GAAG,IAAM,qOAAA,CAAA;kBAAA,EACZ,IAAI,CAAC,CAAA;YAAA,EACX,CAAC,CAAA;QAAA,CACN,EAAE,IAAA,CAAK,MAAM,CAAC,CAAA;MAAA,CAAA,EAEjB;YAAE,OAAO,MAAA,CAAO,OAAO,MAAA,GAAS,CAAC,CAAA;QAAE;QAhBX,IAAA,CAAA,MAAA,GAAA;QAkB1B,IAAA,CAAK,IAAA,GAAO;IACd;IAEA,IAAI,WAAW;QACb,OAAO,IAAA,CAAK,MAAA,CAAO,MAAA;IACrB;AACF;AACA,WAAW,SAAA,CAAU,IAAA,GAAO;AAmC5B,eAAe,MACb,EAAA,EACA,aAAA,EACA,EAAE,uBAAuB,GAAA,CAAK,CAAA,GAAI,CAAC,CAAA,EACoB;IACvD,MAAM,SAAoB,CAAC,CAAA;IAC3B,IAAA,IAAS,IAAI,GAAG,IAAI,eAAe,IAAK;QACtC,MAAM,MAAM,MAAM,GAAG,CAAC;QACtB,IAAI,IAAI,MAAA,KAAW,MAAM;YACvB,OAAO,OAAO,MAAA,CAAO,OAAO,EAAA,CAAG,IAAI,IAAI,GAAG;gBAAE,UAAU,IAAI;YAAE,CAAC;QAC/D,OAAO;YACL,OAAO,IAAA,CAAK,IAAI,KAAK;YACrB,IAAI,IAAI,gBAAgB,GAAG;gBACzB,UAAM,kOAAA,EAAA,CAAM,KAAK,MAAA,CAAO,IAAI,GAAA,IAAO,uBAAwB,KAAK,CAAE;YACpE;QACF;IACF;IACA,OAAO,OAAO,MAAA,CAAO,OAAO,KAAA,CAAM,IAAI,WAAW,MAAM,CAAC,GAAG;QAAE,UAAU;IAAc,CAAC;AACxF"}},
    {"offset": {"line": 3292, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack-shared/src/helpers/vault/client-side.ts"],"sourcesContent":["import { decodeBase64, encodeBase64 } from \"../../utils/bytes\";\nimport { decrypt, encrypt, hash, iteratedHash } from \"../../utils/crypto\";\n\nconst hashPurpose = \"stack-data-vault-client-side-encryption-key-hash\";\nconst encryptionSecretPurpose = \"stack-data-vault-client-side-encryption-value-encryption-key-hash\";\nconst encryptionValuePurpose = \"stack-data-vault-client-side-encryption-value-encryption-value-encryption\";\n\n\nasync function getDerivedKey(secret: string, key: string) {\n  return await iteratedHash({\n    purpose: encryptionSecretPurpose,\n    extra: secret,\n    value: key,\n    iterations: 100_000,\n  });\n}\n\n/**\n * Use to hash the key so the server cannot infer it.\n */\nexport async function hashKey(secret: string, key: string) {\n  return encodeBase64(await hash({\n    purpose: hashPurpose,\n    extra: secret,\n    value: await getDerivedKey(secret, key),\n  }));\n}\n\n/**\n * Use to encrypt the value so that the server cannot read the value without knowing the key.\n */\nexport async function encryptValue(secret: string, key: string, value: string) {\n  const valueEncryptionDerivedKey = await getDerivedKey(secret, key);\n\n  const bytes = await encrypt({\n    purpose: encryptionValuePurpose,\n    secret: valueEncryptionDerivedKey,\n    value: new TextEncoder().encode(value)\n  });\n  return encodeBase64(bytes);\n}\n\n/**\n * Use to decrypt the value. See encryptValue.\n */\nexport async function decryptValue(secret: string, key: string, encryptedValue: string) {\n  const valueEncryptionDerivedKey = await getDerivedKey(secret, key);\n\n  const bytesResult = await decrypt({\n    purpose: encryptionValuePurpose,\n    secret: valueEncryptionDerivedKey,\n    cipher: decodeBase64(encryptedValue),\n  });\n  if (bytesResult.status === \"error\") throw new Error(\"Data vault client-side decryption failed. Are you sure you're using the correct secret?\", { cause: bytesResult.error });\n  return new TextDecoder().decode(bytesResult.data);\n}\n\n\nundefined?.describe(\"encryptValue & decryptValue\", () => {\n  undefined?.it(\"should encrypt and decrypt a value\", async ({ expect }) => {\n    const secret = \"test-secret\";\n    const value = \"test-value\";\n    const encrypted = await encryptValue(secret, \"key\", value);\n    const decrypted = await decryptValue(secret, \"key\", encrypted);\n    expect(decrypted).toEqual(value);\n  });\n\n  undefined?.it(\"should not decrypt a value with a different secret\", async ({ expect }) => {\n    const secret = \"test-secret\";\n    const value = \"test-value\";\n    const encrypted = await encryptValue(secret, \"key\", value);\n    await expect(decryptValue(\"different-secret\", \"key\", encrypted)).rejects.toThrow();\n  });\n\n  undefined?.it(\"should not decrypt a value with a different key\", async ({ expect }) => {\n    const secret = \"test-secret\";\n    const value = \"test-value\";\n    const encrypted = await encryptValue(secret, \"key\", value);\n    await expect(decryptValue(secret, \"different-key\", encrypted)).rejects.toThrow();\n  });\n\n  undefined?.it(\"should not decrypt a value if the cipher was tampered with\", async ({ expect }) => {\n    const secret = \"test-secret\";\n    const value = \"test-value\";\n    const encrypted = await encryptValue(secret, \"key\", value);\n    const tampered = encrypted + \"7\";\n    await expect(decryptValue(secret, \"key\", tampered)).rejects.toThrow();\n  });\n});\n"],"names":[],"mappings":";;;;;;;;;AAAA,SAAS,cAAc,oBAAoB;AAC3C,SAAS,SAAS,SAAS,MAAM,oBAAoB;;;AAErD,IAAM,cAAc;AACpB,IAAM,0BAA0B;AAChC,IAAM,yBAAyB;AAG/B,eAAe,cAAc,MAAA,EAAgB,GAAA,EAAa;IACxD,OAAO,UAAM,wOAAA,EAAa;QACxB,SAAS;QACT,OAAO;QACP,OAAO;QACP,YAAY;IACd,CAAC;AACH;AAKA,eAAsB,QAAQ,MAAA,EAAgB,GAAA,EAAa;IACzD,WAAO,uOAAA,EAAa,UAAM,gOAAA,EAAK;QAC7B,SAAS;QACT,OAAO;QACP,OAAO,MAAM,cAAc,QAAQ,GAAG;IACxC,CAAC,CAAC;AACJ;AAKA,eAAsB,aAAa,MAAA,EAAgB,GAAA,EAAa,KAAA,EAAe;IAC7E,MAAM,4BAA4B,MAAM,cAAc,QAAQ,GAAG;IAEjE,MAAM,QAAQ,UAAM,mOAAA,EAAQ;QAC1B,SAAS;QACT,QAAQ;QACR,OAAO,IAAI,YAAY,EAAE,MAAA,CAAO,KAAK;IACvC,CAAC;IACD,WAAO,uOAAA,EAAa,KAAK;AAC3B;AAKA,eAAsB,aAAa,MAAA,EAAgB,GAAA,EAAa,cAAA,EAAwB;IACtF,MAAM,4BAA4B,MAAM,cAAc,QAAQ,GAAG;IAEjE,MAAM,cAAc,UAAM,mOAAA,EAAQ;QAChC,SAAS;QACT,QAAQ;QACR,YAAQ,uOAAA,EAAa,cAAc;IACrC,CAAC;IACD,IAAI,YAAY,MAAA,KAAW,QAAS,CAAA,MAAM,IAAI,MAAM,2FAA2F;QAAE,OAAO,YAAY,KAAA;IAAM,CAAC;IAC3K,OAAO,IAAI,YAAY,EAAE,MAAA,CAAO,YAAY,IAAI;AAClD"}},
    {"offset": {"line": 3350, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack-shared/src/utils/currency-constants.tsx"],"sourcesContent":["export type MoneyAmount = `${number}` | `${number}.${number}`;\n\nexport type Currency = {\n  code: Uppercase<string>,\n  decimals: number,\n  stripeDecimals: number,\n};\n\nexport const SUPPORTED_CURRENCIES = [\n  {\n    code: 'USD',\n    decimals: 2,\n    stripeDecimals: 2,\n  },\n  {\n    code: 'EUR',\n    decimals: 2,\n    stripeDecimals: 2,\n  },\n  {\n    code: 'GBP',\n    decimals: 2,\n    stripeDecimals: 2,\n  },\n  {\n    code: 'JPY',\n    decimals: 0,\n    stripeDecimals: 0,\n  },\n  {\n    code: 'INR',\n    decimals: 2,\n    stripeDecimals: 2,\n  },\n  {\n    code: 'AUD',\n    decimals: 2,\n    stripeDecimals: 2,\n  },\n  {\n    code: 'CAD',\n    decimals: 2,\n    stripeDecimals: 2,\n  },\n] as const satisfies Currency[];\n"],"names":[],"mappings":";;;;;AAQO,IAAM,uBAAuB;IAClC;QACE,MAAM;QACN,UAAU;QACV,gBAAgB;IAClB;IACA;QACE,MAAM;QACN,UAAU;QACV,gBAAgB;IAClB;IACA;QACE,MAAM;QACN,UAAU;QACV,gBAAgB;IAClB;IACA;QACE,MAAM;QACN,UAAU;QACV,gBAAgB;IAClB;IACA;QACE,MAAM;QACN,UAAU;QACV,gBAAgB;IAClB;IACA;QACE,MAAM;QACN,UAAU;QACV,gBAAgB;IAClB;IACA;QACE,MAAM;QACN,UAAU;QACV,gBAAgB;IAClB;CACF"}},
    {"offset": {"line": 3398, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack-shared/src/utils/http.tsx"],"sourcesContent":["import { decodeBase64, encodeBase64, isBase64 } from \"./bytes\";\n\nexport const HTTP_METHODS = {\n  \"GET\": {\n    safe: true,\n    idempotent: true,\n  },\n  \"POST\": {\n    safe: false,\n    idempotent: false,\n  },\n  \"PUT\": {\n    safe: false,\n    idempotent: true,\n  },\n  \"DELETE\": {\n    safe: false,\n    idempotent: true,\n  },\n  \"PATCH\": {\n    safe: false,\n    idempotent: false,\n  },\n  \"OPTIONS\": {\n    safe: true,\n    idempotent: true,\n  },\n  \"HEAD\": {\n    safe: true,\n    idempotent: true,\n  },\n  \"TRACE\": {\n    safe: true,\n    idempotent: true,\n  },\n  \"CONNECT\": {\n    safe: false,\n    idempotent: false,\n  },\n} as const;\nexport type HttpMethod = keyof typeof HTTP_METHODS;\n\nexport function decodeBasicAuthorizationHeader(value: string): [string, string] | null {\n  const [type, encoded, ...rest] = value.split(' ');\n  if (rest.length > 0) return null;\n  if (!encoded) return null;\n  if (type !== 'Basic') return null;\n  if (!isBase64(encoded)) return null;\n  const decoded = new TextDecoder().decode(decodeBase64(encoded));\n  const split = decoded.split(':');\n  return [split[0], split.slice(1).join(':')];\n}\nundefined?.test(\"decodeBasicAuthorizationHeader\", ({ expect }) => {\n  // Test with valid Basic Authorization header\n  const username = \"user\";\n  const password = \"pass\";\n  const encoded = encodeBasicAuthorizationHeader(username, password);\n  expect(decodeBasicAuthorizationHeader(encoded)).toEqual([username, password]);\n\n  // Test with password containing colons\n  const complexPassword = \"pass:with:colons\";\n  const encodedComplex = encodeBasicAuthorizationHeader(username, complexPassword);\n  expect(decodeBasicAuthorizationHeader(encodedComplex)).toEqual([username, complexPassword]);\n\n  // Test with invalid headers\n  expect(decodeBasicAuthorizationHeader(\"NotBasic dXNlcjpwYXNz\")).toBe(null); // Wrong type\n  expect(decodeBasicAuthorizationHeader(\"Basic\")).toBe(null); // Missing encoded part\n  expect(decodeBasicAuthorizationHeader(\"Basic not-base64\")).toBe(null); // Not base64\n  expect(decodeBasicAuthorizationHeader(\"Basic dXNlcjpwYXNz extra\")).toBe(null); // Extra parts\n});\n\nexport function encodeBasicAuthorizationHeader(id: string, password: string): string {\n  if (id.includes(':')) throw new Error(\"Basic authorization header id cannot contain ':'\");\n  return `Basic ${encodeBase64(new TextEncoder().encode(`${id}:${password}`))}`;\n}\nundefined?.test(\"encodeBasicAuthorizationHeader\", ({ expect }) => {\n  // Test with simple username and password\n  const encoded = encodeBasicAuthorizationHeader(\"user\", \"pass\");\n  expect(encoded).toMatch(/^Basic [A-Za-z0-9+/=]+$/); // Should start with \"Basic \" followed by base64\n\n  // Test with empty password\n  const encodedEmptyPass = encodeBasicAuthorizationHeader(\"user\", \"\");\n  expect(encodedEmptyPass).toMatch(/^Basic [A-Za-z0-9+/=]+$/);\n\n  // Test with password containing special characters\n  const encodedSpecialChars = encodeBasicAuthorizationHeader(\"user\", \"p@ss!w0rd\");\n  expect(encodedSpecialChars).toMatch(/^Basic [A-Za-z0-9+/=]+$/);\n\n  // Test with username containing colon should throw\n  expect(() => encodeBasicAuthorizationHeader(\"user:name\", \"pass\")).toThrow();\n});\n"],"names":[],"mappings":";;;;;;;;;AAAA,SAAS,cAAc,cAAc,gBAAgB;;AAE9C,IAAM,eAAe;IAC1B,OAAO;QACL,MAAM;QACN,YAAY;IACd;IACA,QAAQ;QACN,MAAM;QACN,YAAY;IACd;IACA,OAAO;QACL,MAAM;QACN,YAAY;IACd;IACA,UAAU;QACR,MAAM;QACN,YAAY;IACd;IACA,SAAS;QACP,MAAM;QACN,YAAY;IACd;IACA,WAAW;QACT,MAAM;QACN,YAAY;IACd;IACA,QAAQ;QACN,MAAM;QACN,YAAY;IACd;IACA,SAAS;QACP,MAAM;QACN,YAAY;IACd;IACA,WAAW;QACT,MAAM;QACN,YAAY;IACd;AACF;AAGO,SAAS,+BAA+B,KAAA,EAAwC;IACrF,MAAM,CAAC,MAAM,SAAS,GAAG,IAAI,CAAA,GAAI,MAAM,KAAA,CAAM,GAAG;IAChD,IAAI,KAAK,MAAA,GAAS,EAAG,CAAA,OAAO;IAC5B,IAAI,CAAC,QAAS,CAAA,OAAO;IACrB,IAAI,SAAS,QAAS,CAAA,OAAO;IAC7B,IAAI,KAAC,mOAAA,EAAS,OAAO,EAAG,CAAA,OAAO;IAC/B,MAAM,UAAU,IAAI,YAAY,EAAE,MAAA,KAAO,uOAAA,EAAa,OAAO,CAAC;IAC9D,MAAM,QAAQ,QAAQ,KAAA,CAAM,GAAG;IAC/B,OAAO;QAAC,KAAA,CAAM,CAAC,CAAA;QAAG,MAAM,KAAA,CAAM,CAAC,EAAE,IAAA,CAAK,GAAG,CAAC;KAAA;AAC5C;AAoBO,SAAS,+BAA+B,EAAA,EAAY,QAAA,EAA0B;IACnF,IAAI,GAAG,QAAA,CAAS,GAAG,EAAG,CAAA,MAAM,IAAI,MAAM,kDAAkD;IACxF,OAAO,CAAA,MAAA,MAAS,uOAAA,EAAa,IAAI,YAAY,EAAE,MAAA,CAAO,GAAG,EAAE,CAAA,CAAA,EAAI,QAAQ,EAAE,CAAC,CAAC,EAAA;AAC7E"}},
    {"offset": {"line": 3470, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack-shared/src/utils/oauth.tsx"],"sourcesContent":["export const standardProviders = [\"google\", \"github\", \"microsoft\", \"spotify\", \"facebook\", \"discord\", \"gitlab\", \"bitbucket\", \"linkedin\", \"apple\", \"x\", \"twitch\"] as const;\n// No more shared providers should be added except for special cases\nexport const sharedProviders = [\"google\", \"github\", \"microsoft\", \"spotify\"] as const;\nexport const allProviders = standardProviders;\n\nexport type ProviderType = typeof allProviders[number];\nexport type StandardProviderType = typeof standardProviders[number];\nexport type SharedProviderType = typeof sharedProviders[number];\n"],"names":[],"mappings":";;;;;;;;;AAAO,IAAM,oBAAoB;IAAC;IAAU;IAAU;IAAa;IAAW;IAAY;IAAW;IAAU;IAAa;IAAY;IAAS;IAAK,QAAQ;CAAA;AAEvJ,IAAM,kBAAkB;IAAC;IAAU;IAAU;IAAa,SAAS;CAAA;AACnE,IAAM,eAAe"}},
    {"offset": {"line": 3506, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack-shared/src/utils/urls.tsx"],"sourcesContent":["import { generateSecureRandomString } from \"./crypto\";\nimport { templateIdentity } from \"./strings\";\n\nexport function createUrlIfValid(...args: ConstructorParameters<typeof URL>) {\n  try {\n    return new URL(...args);\n  } catch (e) {\n    return null;\n  }\n}\nundefined?.test(\"createUrlIfValid\", ({ expect }) => {\n  // Test with valid URLs\n  expect(createUrlIfValid(\"https://example.com\")).toBeInstanceOf(URL);\n  expect(createUrlIfValid(\"https://example.com/path?query=value#hash\")).toBeInstanceOf(URL);\n  expect(createUrlIfValid(\"/path\", \"https://example.com\")).toBeInstanceOf(URL);\n\n  // Test with invalid URLs\n  expect(createUrlIfValid(\"\")).toBeNull();\n  expect(createUrlIfValid(\"not a url\")).toBeNull();\n  expect(createUrlIfValid(\"http://\")).toBeNull();\n});\n\nexport function isValidUrl(url: string) {\n  return !!createUrlIfValid(url);\n}\nundefined?.test(\"isValidUrl\", ({ expect }) => {\n  // Test with valid URLs\n  expect(isValidUrl(\"https://example.com\")).toBe(true);\n  expect(isValidUrl(\"http://localhost:3000\")).toBe(true);\n  expect(isValidUrl(\"ftp://example.com\")).toBe(true);\n\n  // Test with invalid URLs\n  expect(isValidUrl(\"\")).toBe(false);\n  expect(isValidUrl(\"not a url\")).toBe(false);\n  expect(isValidUrl(\"http://\")).toBe(false);\n});\n\nexport function isValidHostname(hostname: string) {\n  // Basic validation\n  if (!hostname || hostname.startsWith('.') || hostname.endsWith('.') || hostname.includes('..')) {\n    return false;\n  }\n\n  const url = createUrlIfValid(`https://${hostname}`);\n  if (!url) return false;\n  return url.hostname === hostname;\n}\nundefined?.test(\"isValidHostname\", ({ expect }) => {\n  // Test with valid hostnames\n  expect(isValidHostname(\"example.com\")).toBe(true);\n  expect(isValidHostname(\"localhost\")).toBe(true);\n  expect(isValidHostname(\"sub.domain.example.com\")).toBe(true);\n  expect(isValidHostname(\"127.0.0.1\")).toBe(true);\n\n  // Test with invalid hostnames\n  expect(isValidHostname(\"\")).toBe(false);\n  expect(isValidHostname(\"example.com/path\")).toBe(false);\n  expect(isValidHostname(\"https://example.com\")).toBe(false);\n  expect(isValidHostname(\"example com\")).toBe(false);\n});\n\nexport function isValidHostnameWithWildcards(hostname: string) {\n  // Empty hostnames are invalid\n  if (!hostname) return false;\n\n  // Check if it contains wildcards\n  const hasWildcard = hostname.includes('*');\n\n  if (!hasWildcard) {\n    // If no wildcards, validate as a normal hostname\n    return isValidHostname(hostname);\n  }\n\n  // Basic validation checks that apply even with wildcards\n  // - Hostname cannot start or end with a dot\n  if (hostname.startsWith('.') || hostname.endsWith('.')) {\n    return false;\n  }\n\n  // - No consecutive dots\n  if (hostname.includes('..')) {\n    return false;\n  }\n\n  // For wildcard validation, check that non-wildcard parts contain valid characters\n  // Replace wildcards with a valid placeholder to check the rest\n  const testHostname = hostname.replace(/\\*+/g, 'wildcard');\n\n  // Check if the resulting string would be a valid hostname\n  if (!/^[a-zA-Z0-9.-]+$/.test(testHostname)) {\n    return false;\n  }\n\n  // Additional check: ensure the pattern makes sense\n  // Check each segment between wildcards\n  const segments = hostname.split(/\\*+/);\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    if (segment === '') continue; // Empty segments are OK (consecutive wildcards)\n\n    // First segment can't start with dot\n    if (i === 0 && segment.startsWith('.')) {\n      return false;\n    }\n\n    // Last segment can't end with dot\n    if (i === segments.length - 1 && segment.endsWith('.')) {\n      return false;\n    }\n\n    // No segment should have consecutive dots\n    if (segment.includes('..')) {\n      return false;\n    }\n  }\n\n  return true;\n}\nundefined?.test(\"isValidHostnameWithWildcards\", ({ expect }) => {\n  // Test with valid regular hostnames\n  expect(isValidHostnameWithWildcards(\"example.com\")).toBe(true);\n  expect(isValidHostnameWithWildcards(\"localhost\")).toBe(true);\n  expect(isValidHostnameWithWildcards(\"sub.domain.example.com\")).toBe(true);\n\n  // Test with valid wildcard hostnames\n  expect(isValidHostnameWithWildcards(\"*.example.com\")).toBe(true);\n  expect(isValidHostnameWithWildcards(\"a-*.example.com\")).toBe(true);\n  expect(isValidHostnameWithWildcards(\"*.*.org\")).toBe(true);\n  expect(isValidHostnameWithWildcards(\"**.example.com\")).toBe(true);\n  expect(isValidHostnameWithWildcards(\"sub.**.com\")).toBe(true);\n  expect(isValidHostnameWithWildcards(\"*-api.*.com\")).toBe(true);\n\n  // Test with invalid hostnames\n  expect(isValidHostnameWithWildcards(\"\")).toBe(false);\n  expect(isValidHostnameWithWildcards(\"example.com/path\")).toBe(false);\n  expect(isValidHostnameWithWildcards(\"https://example.com\")).toBe(false);\n  expect(isValidHostnameWithWildcards(\"example com\")).toBe(false);\n  expect(isValidHostnameWithWildcards(\".example.com\")).toBe(false);\n  expect(isValidHostnameWithWildcards(\"example.com.\")).toBe(false);\n  expect(isValidHostnameWithWildcards(\"example..com\")).toBe(false);\n  expect(isValidHostnameWithWildcards(\"*.example..com\")).toBe(false);\n});\n\nexport function matchHostnamePattern(pattern: string, hostname: string): boolean {\n  // If no wildcards, it's an exact match\n  if (!pattern.includes('*')) {\n    return pattern === hostname;\n  }\n\n  // Convert the pattern to a regex\n  // First, escape all regex special characters except *\n  let regexPattern = pattern.replace(/[.+?^${}()|[\\]\\\\]/g, '\\\\$&');\n\n  // Use a placeholder for ** to handle it separately from single *\n  const doubleWildcardPlaceholder = '\\x00DOUBLE_WILDCARD\\x00';\n  regexPattern = regexPattern.replace(/\\*\\*/g, doubleWildcardPlaceholder);\n\n  // Replace single * with a pattern that matches anything except dots\n  regexPattern = regexPattern.replace(/\\*/g, '[^.]*');\n\n  // Replace the double wildcard placeholder with a pattern that matches anything including dots\n  regexPattern = regexPattern.replace(new RegExp(doubleWildcardPlaceholder, 'g'), '.*');\n\n  // Anchor the pattern to match the entire hostname\n  regexPattern = '^' + regexPattern + '$';\n\n  try {\n    const regex = new RegExp(regexPattern);\n    return regex.test(hostname);\n  } catch {\n    return false;\n  }\n}\nundefined?.test(\"matchHostnamePattern\", ({ expect }) => {\n  // Test exact matches\n  expect(matchHostnamePattern(\"example.com\", \"example.com\")).toBe(true);\n  expect(matchHostnamePattern(\"example.com\", \"other.com\")).toBe(false);\n\n  // Test single wildcard matches\n  expect(matchHostnamePattern(\"*.example.com\", \"api.example.com\")).toBe(true);\n  expect(matchHostnamePattern(\"*.example.com\", \"www.example.com\")).toBe(true);\n  expect(matchHostnamePattern(\"*.example.com\", \"example.com\")).toBe(false);\n  expect(matchHostnamePattern(\"*.example.com\", \"api.v2.example.com\")).toBe(false);\n\n  // Test double wildcard matches\n  expect(matchHostnamePattern(\"**.example.com\", \"api.example.com\")).toBe(true);\n  expect(matchHostnamePattern(\"**.example.com\", \"api.v2.example.com\")).toBe(true);\n  expect(matchHostnamePattern(\"**.example.com\", \"a.b.c.example.com\")).toBe(true);\n  expect(matchHostnamePattern(\"**.example.com\", \"example.com\")).toBe(false);\n\n  // Test complex patterns\n  expect(matchHostnamePattern(\"api-*.example.com\", \"api-v1.example.com\")).toBe(true);\n  expect(matchHostnamePattern(\"api-*.example.com\", \"api-v2.example.com\")).toBe(true);\n  expect(matchHostnamePattern(\"api-*.example.com\", \"api.example.com\")).toBe(false);\n  expect(matchHostnamePattern(\"*.*.org\", \"mail.example.org\")).toBe(true);\n  expect(matchHostnamePattern(\"*.*.org\", \"example.org\")).toBe(false);\n});\n\nexport function isLocalhost(urlOrString: string | URL) {\n  const url = createUrlIfValid(urlOrString);\n  if (!url) return false;\n  if (url.hostname === \"localhost\" || url.hostname.endsWith(\".localhost\")) return true;\n  if (url.hostname.match(/^127\\.\\d+\\.\\d+\\.\\d+$/)) return true;\n  return false;\n}\nundefined?.test(\"isLocalhost\", ({ expect }) => {\n  // Test with localhost URLs\n  expect(isLocalhost(\"http://localhost\")).toBe(true);\n  expect(isLocalhost(\"https://localhost:8080\")).toBe(true);\n  expect(isLocalhost(\"http://sub.localhost\")).toBe(true);\n  expect(isLocalhost(\"http://127.0.0.1\")).toBe(true);\n  expect(isLocalhost(\"http://127.1.2.3\")).toBe(true);\n\n  // Test with non-localhost URLs\n  expect(isLocalhost(\"https://example.com\")).toBe(false);\n  expect(isLocalhost(\"http://192.168.1.1\")).toBe(false);\n  expect(isLocalhost(\"http://10.0.0.1\")).toBe(false);\n\n  // Test with URL objects\n  expect(isLocalhost(new URL(\"http://localhost\"))).toBe(true);\n  expect(isLocalhost(new URL(\"https://example.com\"))).toBe(false);\n\n  // Test with invalid URLs\n  expect(isLocalhost(\"not a url\")).toBe(false);\n  expect(isLocalhost(\"\")).toBe(false);\n});\n\nexport function isRelative(url: string) {\n  const randomDomain = `${generateSecureRandomString()}.stack-auth.example.com`;\n  const u = createUrlIfValid(url, `https://${randomDomain}`);\n  if (!u) return false;\n  if (u.host !== randomDomain) return false;\n  if (u.protocol !== \"https:\") return false;\n  return true;\n}\nundefined?.test(\"isRelative\", ({ expect }) => {\n  // We can't easily mock generateSecureRandomString in this context\n  // but we can still test the function's behavior\n\n  // Test with relative URLs\n  expect(isRelative(\"/\")).toBe(true);\n  expect(isRelative(\"/path\")).toBe(true);\n  expect(isRelative(\"/path?query=value#hash\")).toBe(true);\n\n  // Test with absolute URLs\n  expect(isRelative(\"https://example.com\")).toBe(false);\n  expect(isRelative(\"http://example.com\")).toBe(false);\n  expect(isRelative(\"//example.com\")).toBe(false);\n\n  // Note: The implementation treats empty strings and invalid URLs as relative\n  // This is because they can be resolved against a base URL\n  expect(isRelative(\"\")).toBe(true);\n  expect(isRelative(\"not a url\")).toBe(true);\n});\n\nexport function getRelativePart(url: URL) {\n  return url.pathname + url.search + url.hash;\n}\nundefined?.test(\"getRelativePart\", ({ expect }) => {\n  // Test with various URLs\n  expect(getRelativePart(new URL(\"https://example.com\"))).toBe(\"/\");\n  expect(getRelativePart(new URL(\"https://example.com/path\"))).toBe(\"/path\");\n  expect(getRelativePart(new URL(\"https://example.com/path?query=value\"))).toBe(\"/path?query=value\");\n  expect(getRelativePart(new URL(\"https://example.com/path#hash\"))).toBe(\"/path#hash\");\n  expect(getRelativePart(new URL(\"https://example.com/path?query=value#hash\"))).toBe(\"/path?query=value#hash\");\n\n  // Test with different domains but same paths\n  const url1 = new URL(\"https://example.com/path?query=value#hash\");\n  const url2 = new URL(\"https://different.com/path?query=value#hash\");\n  expect(getRelativePart(url1)).toBe(getRelativePart(url2));\n});\n\n/**\n * A template literal tag that returns a URL.\n *\n * Any values passed are encoded.\n */\nexport function url(strings: TemplateStringsArray | readonly string[], ...values: (string | number | boolean)[]): URL {\n  return new URL(urlString(strings, ...values));\n}\nundefined?.test(\"url\", ({ expect }) => {\n  // Test with no interpolation\n  expect(url`https://example.com`).toBeInstanceOf(URL);\n  expect(url`https://example.com`.href).toBe(\"https://example.com/\");\n\n  // Test with string interpolation\n  expect(url`https://example.com/${\"path\"}`).toBeInstanceOf(URL);\n  expect(url`https://example.com/${\"path\"}`.pathname).toBe(\"/path\");\n\n  // Test with number interpolation\n  expect(url`https://example.com/${42}`).toBeInstanceOf(URL);\n  expect(url`https://example.com/${42}`.pathname).toBe(\"/42\");\n\n  // Test with boolean interpolation\n  expect(url`https://example.com/${true}`).toBeInstanceOf(URL);\n  expect(url`https://example.com/${true}`.pathname).toBe(\"/true\");\n\n  // Test with special characters in interpolation\n  expect(url`https://example.com/${\"path with spaces\"}`).toBeInstanceOf(URL);\n  expect(url`https://example.com/${\"path with spaces\"}`.pathname).toBe(\"/path%20with%20spaces\");\n\n  // Test with multiple interpolations\n  expect(url`https://example.com/${\"path\"}?query=${\"value\"}`).toBeInstanceOf(URL);\n  expect(url`https://example.com/${\"path\"}?query=${\"value\"}`.pathname).toBe(\"/path\");\n  expect(url`https://example.com/${\"path\"}?query=${\"value\"}`.search).toBe(\"?query=value\");\n});\n\n\n/**\n * A template literal tag that returns a URL string.\n *\n * Any values passed are encoded.\n */\nexport function urlString(strings: TemplateStringsArray | readonly string[], ...values: (string | number | boolean)[]): string {\n  return templateIdentity(strings, ...values.map(encodeURIComponent));\n}\nundefined?.test(\"urlString\", ({ expect }) => {\n  // Test with no interpolation\n  expect(urlString`https://example.com`).toBe(\"https://example.com\");\n\n  // Test with string interpolation\n  expect(urlString`https://example.com/${\"path\"}`).toBe(\"https://example.com/path\");\n\n  // Test with number interpolation\n  expect(urlString`https://example.com/${42}`).toBe(\"https://example.com/42\");\n\n  // Test with boolean interpolation\n  expect(urlString`https://example.com/${true}`).toBe(\"https://example.com/true\");\n\n  // Test with special characters in interpolation\n  expect(urlString`https://example.com/${\"path with spaces\"}`).toBe(\"https://example.com/path%20with%20spaces\");\n  expect(urlString`https://example.com/${\"?&=\"}`).toBe(\"https://example.com/%3F%26%3D\");\n\n  // Test with multiple interpolations\n  expect(urlString`https://example.com/${\"path\"}?query=${\"value\"}`).toBe(\"https://example.com/path?query=value\");\n  expect(urlString`https://example.com/${\"path\"}?query=${\"value with spaces\"}`).toBe(\"https://example.com/path?query=value%20with%20spaces\");\n});\n\nexport function isChildUrl(parentUrl: URL, maybeChildUrl: URL) {\n  return parentUrl.origin === maybeChildUrl.origin\n    && isChildPath(parentUrl.pathname, maybeChildUrl.pathname)\n    && [...parentUrl.searchParams].every(([key, value]) => maybeChildUrl.searchParams.get(key) === value)\n    && (!parentUrl.hash || parentUrl.hash === maybeChildUrl.hash);\n}\nundefined?.test(\"isChildUrl\", ({ expect }) => {\n  // true\n  expect(isChildUrl(new URL(\"https://abc.com/\"), new URL(\"https://abc.com/\"))).toBe(true);\n  expect(isChildUrl(new URL(\"https://abc.com/\"), new URL(\"https://abc.com/path\"))).toBe(true);\n  expect(isChildUrl(new URL(\"https://abc.com/\"), new URL(\"https://abc.com/path?query=value\"))).toBe(true);\n  expect(isChildUrl(new URL(\"https://abc.com/\"), new URL(\"https://abc.com/path?query=value#hash\"))).toBe(true);\n\n  // false\n  expect(isChildUrl(new URL(\"https://abc.com\"), new URL(\"https://example.com\"))).toBe(false);\n  expect(isChildUrl(new URL(\"https://abc.com/\"), new URL(\"https://example.com/path\"))).toBe(false);\n  expect(isChildUrl(new URL(\"https://abc.com/\"), new URL(\"https://example.com/path?query=value\"))).toBe(false);\n  expect(isChildUrl(new URL(\"https://abc.com/\"), new URL(\"https://example.com/path?query=value#hash\"))).toBe(false);\n  expect(isChildUrl(new URL(\"https://example.com\"), new URL(\"https://abc.com/path?query=value#hash\"))).toBe(false);\n  expect(isChildUrl(new URL(\"https://example.com?query=value123\"), new URL(\"https://example.com/path?query=value#hash\"))).toBe(false);\n});\n\nexport function isChildPath(parentPath: string, maybeChildPath: string) {\n  parentPath = parentPath.endsWith(\"/\") ? parentPath : parentPath + \"/\";\n  maybeChildPath = maybeChildPath.endsWith(\"/\") ? maybeChildPath : maybeChildPath + \"/\";\n  return maybeChildPath.startsWith(parentPath);\n}\nundefined?.test(\"isSubPath\", ({ expect }) => {\n  expect(isChildPath(\"/\", \"/\")).toBe(true);\n  expect(isChildPath(\"/\", \"/path\")).toBe(true);\n  expect(isChildPath(\"/path\", \"/\")).toBe(false);\n  expect(isChildPath(\"/path\", \"/path\")).toBe(true);\n  expect(isChildPath(\"/path/\", \"/path\")).toBe(true);\n  expect(isChildPath(\"/path\", \"/path/\")).toBe(true);\n  expect(isChildPath(\"/path/\", \"/path/\")).toBe(true);\n  expect(isChildPath(\"/path\", \"/path/abc\")).toBe(true);\n  expect(isChildPath(\"/path/\", \"/path/abc\")).toBe(true);\n  expect(isChildPath(\"/path\", \"/path-abc\")).toBe(false);\n  expect(isChildPath(\"/path\", \"/path-abc/\")).toBe(false);\n  expect(isChildPath(\"/path/\", \"/path-abc\")).toBe(false);\n  expect(isChildPath(\"/path/\", \"/path-abc/\")).toBe(false);\n});\n"],"names":["url"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAAS,kCAAkC;AAC3C,SAAS,wBAAwB;;;AAE1B,SAAS,iBAAA,GAAoB,IAAA,EAAyC;IAC3E,IAAI;QACF,OAAO,IAAI,IAAI,GAAG,IAAI;IACxB,EAAA,OAAS,GAAG;QACV,OAAO;IACT;AACF;AAaO,SAAS,WAAWA,IAAAA,EAAa;IACtC,OAAO,CAAC,CAAC,iBAAiBA,IAAG;AAC/B;AAaO,SAAS,gBAAgB,QAAA,EAAkB;IAEhD,IAAI,CAAC,YAAY,SAAS,UAAA,CAAW,GAAG,KAAK,SAAS,QAAA,CAAS,GAAG,KAAK,SAAS,QAAA,CAAS,IAAI,GAAG;QAC9F,OAAO;IACT;IAEA,MAAMA,OAAM,iBAAiB,CAAA,QAAA,EAAW,QAAQ,EAAE;IAClD,IAAI,CAACA,KAAK,CAAA,OAAO;IACjB,OAAOA,KAAI,QAAA,KAAa;AAC1B;AAeO,SAAS,6BAA6B,QAAA,EAAkB;IAE7D,IAAI,CAAC,SAAU,CAAA,OAAO;IAGtB,MAAM,cAAc,SAAS,QAAA,CAAS,GAAG;IAEzC,IAAI,CAAC,aAAa;QAEhB,OAAO,gBAAgB,QAAQ;IACjC;IAIA,IAAI,SAAS,UAAA,CAAW,GAAG,KAAK,SAAS,QAAA,CAAS,GAAG,GAAG;QACtD,OAAO;IACT;IAGA,IAAI,SAAS,QAAA,CAAS,IAAI,GAAG;QAC3B,OAAO;IACT;IAIA,MAAM,eAAe,SAAS,OAAA,CAAQ,QAAQ,UAAU;IAGxD,IAAI,CAAC,mBAAmB,IAAA,CAAK,YAAY,GAAG;QAC1C,OAAO;IACT;IAIA,MAAM,WAAW,SAAS,KAAA,CAAM,KAAK;IACrC,IAAA,IAAS,IAAI,GAAG,IAAI,SAAS,MAAA,EAAQ,IAAK;QACxC,MAAM,UAAU,QAAA,CAAS,CAAC,CAAA;QAC1B,IAAI,YAAY,GAAI,CAAA;QAGpB,IAAI,MAAM,KAAK,QAAQ,UAAA,CAAW,GAAG,GAAG;YACtC,OAAO;QACT;QAGA,IAAI,MAAM,SAAS,MAAA,GAAS,KAAK,QAAQ,QAAA,CAAS,GAAG,GAAG;YACtD,OAAO;QACT;QAGA,IAAI,QAAQ,QAAA,CAAS,IAAI,GAAG;YAC1B,OAAO;QACT;IACF;IAEA,OAAO;AACT;AA0BO,SAAS,qBAAqB,OAAA,EAAiB,QAAA,EAA2B;IAE/E,IAAI,CAAC,QAAQ,QAAA,CAAS,GAAG,GAAG;QAC1B,OAAO,YAAY;IACrB;IAIA,IAAI,eAAe,QAAQ,OAAA,CAAQ,sBAAsB,MAAM;IAG/D,MAAM,4BAA4B;IAClC,eAAe,aAAa,OAAA,CAAQ,SAAS,yBAAyB;IAGtE,eAAe,aAAa,OAAA,CAAQ,OAAO,OAAO;IAGlD,eAAe,aAAa,OAAA,CAAQ,IAAI,OAAO,2BAA2B,GAAG,GAAG,IAAI;IAGpF,eAAe,MAAM,eAAe;IAEpC,IAAI;QACF,MAAM,QAAQ,IAAI,OAAO,YAAY;QACrC,OAAO,MAAM,IAAA,CAAK,QAAQ;IAC5B,EAAA,OAAQ;QACN,OAAO;IACT;AACF;AA0BO,SAAS,YAAY,WAAA,EAA2B;IACrD,MAAMA,OAAM,iBAAiB,WAAW;IACxC,IAAI,CAACA,KAAK,CAAA,OAAO;IACjB,IAAIA,KAAI,QAAA,KAAa,eAAeA,KAAI,QAAA,CAAS,QAAA,CAAS,YAAY,EAAG,CAAA,OAAO;IAChF,IAAIA,KAAI,QAAA,CAAS,KAAA,CAAM,sBAAsB,EAAG,CAAA,OAAO;IACvD,OAAO;AACT;AAuBO,SAAS,WAAWA,IAAAA,EAAa;IACtC,MAAM,eAAe,OAAG,sPAAA,CAA2B,CAAC,EAAA,uBAAA,CAAA;IACpD,MAAM,IAAI,iBAAiBA,MAAK,CAAA,QAAA,EAAW,YAAY,EAAE;IACzD,IAAI,CAAC,EAAG,CAAA,OAAO;IACf,IAAI,EAAE,IAAA,KAAS,aAAc,CAAA,OAAO;IACpC,IAAI,EAAE,QAAA,KAAa,SAAU,CAAA,OAAO;IACpC,OAAO;AACT;AAqBO,SAAS,gBAAgBA,IAAAA,EAAU;IACxC,OAAOA,KAAI,QAAA,GAAWA,KAAI,MAAA,GAASA,KAAI,IAAA;AACzC;AAoBO,SAAS,IAAI,OAAA,EAAA,GAAsD,MAAA,EAA4C;IACpH,OAAO,IAAI,IAAI,UAAU,SAAS,GAAG,MAAM,CAAC;AAC9C;AAkCO,SAAS,UAAU,OAAA,EAAA,GAAsD,MAAA,EAA+C;IAC7H,WAAO,6OAAA,EAAiB,SAAS,GAAG,OAAO,GAAA,CAAI,kBAAkB,CAAC;AACpE;AAuBO,SAAS,WAAW,SAAA,EAAgB,aAAA,EAAoB;IAC7D,OAAO,UAAU,MAAA,KAAW,cAAc,MAAA,IACrC,YAAY,UAAU,QAAA,EAAU,cAAc,QAAQ,KACtD,CAAC;WAAG,UAAU,YAAY;KAAA,CAAE,KAAA,CAAM,CAAC,CAAC,KAAK,KAAK,CAAA,GAAM,cAAc,YAAA,CAAa,GAAA,CAAI,GAAG,MAAM,KAAK,KAAA,CAChG,CAAC,UAAU,IAAA,IAAQ,UAAU,IAAA,KAAS,cAAc,IAAA;AAC5D;AAiBO,SAAS,YAAY,UAAA,EAAoB,cAAA,EAAwB;IACtE,aAAa,WAAW,QAAA,CAAS,GAAG,IAAI,aAAa,aAAa;IAClE,iBAAiB,eAAe,QAAA,CAAS,GAAG,IAAI,iBAAiB,iBAAiB;IAClF,OAAO,eAAe,UAAA,CAAW,UAAU;AAC7C"}},
    {"offset": {"line": 3644, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack-shared/src/schema-fields.ts"],"sourcesContent":["import * as yup from \"yup\";\nimport { KnownErrors } from \"./known-errors\";\nimport { isBase64 } from \"./utils/bytes\";\nimport { SUPPORTED_CURRENCIES, type Currency, type MoneyAmount } from \"./utils/currency-constants\";\nimport type { DayInterval, Interval } from \"./utils/dates\";\nimport { StackAssertionError, throwErr } from \"./utils/errors\";\nimport { decodeBasicAuthorizationHeader } from \"./utils/http\";\nimport { allProviders } from \"./utils/oauth\";\nimport { deepPlainClone, omit, typedFromEntries } from \"./utils/objects\";\nimport { deindent } from \"./utils/strings\";\nimport { isValidHostnameWithWildcards, isValidUrl } from \"./utils/urls\";\nimport { isUuid } from \"./utils/uuids\";\n\nconst MAX_IMAGE_SIZE_BASE64_BYTES = 1_000_000; // 1MB\n\ndeclare module \"yup\" {\n  // eslint-disable-next-line @typescript-eslint/consistent-type-definitions\n  interface StringSchema<TType, TContext, TDefault, TFlags> {\n    nonEmpty(message?: string): StringSchema<TType, TContext, TDefault, TFlags>,\n    empty(): StringSchema<TType, TContext, TDefault, TFlags>,\n  }\n\n  // eslint-disable-next-line @typescript-eslint/consistent-type-definitions\n  interface Schema<TType, TContext, TDefault, TFlags> {\n    hasNested<K extends keyof NonNullable<TType>>(path: K): boolean,\n    getNested<K extends keyof NonNullable<TType>>(path: K): yup.Schema<NonNullable<TType>[K], TContext, TDefault, TFlags>,\n\n    // the default types for concat kinda suck, so let's fix that\n    concat<U extends yup.AnySchema>(schema: U): yup.Schema<Omit<NonNullable<TType>, keyof yup.InferType<U>> & yup.InferType<U> | (TType & (null | undefined)), TContext, Omit<NonNullable<TDefault>, keyof U['__default']> & U['__default'] | (TDefault & (null | undefined)), TFlags>,\n  }\n\n  // eslint-disable-next-line @typescript-eslint/consistent-type-definitions\n  export interface CustomSchemaMetadata {\n    stackSchemaInfo?:\n    | {\n      type: \"object\" | \"array\" | \"string\" | \"number\" | \"boolean\" | \"date\" | \"mixed\" | \"never\",\n    }\n    | {\n      type: \"tuple\",\n      items: yup.AnySchema[],\n    }\n    | {\n      type: \"union\",\n      items: yup.AnySchema[],\n    }\n    | {\n      type: \"record\",\n      keySchema: yup.StringSchema<any>,\n      valueSchema: yup.AnySchema,\n    },\n  }\n}\n\n// eslint-disable-next-line no-restricted-syntax\nyup.addMethod(yup.string, \"nonEmpty\", function (message?: string) {\n  return this.test(\n    \"non-empty\",\n    message ?? (({ path }) => `${path} must not be empty`),\n    (value) => {\n      return value !== \"\";\n    }\n  );\n});\n\nyup.addMethod(yup.Schema, \"hasNested\", function (path: any) {\n  if (!path.match(/^[a-zA-Z0-9_$:-]*$/)) throw new StackAssertionError(`yupSchema.hasNested can currently only be used with alphanumeric keys, underscores, dollar signs, colons, and hyphens. Fix this in the future. Provided key: ${JSON.stringify(path)}`);\n  const schemaInfo = this.meta()?.stackSchemaInfo as any;\n  if (schemaInfo?.type === \"record\") {\n    return schemaInfo.keySchema.isValidSync(path);\n  } else if (schemaInfo?.type === \"union\") {\n    return schemaInfo.items.some((s: any) => s.hasNested(path));\n  } else {\n    try {\n      yup.reach(this, path);\n      return true as any;\n    } catch (e) {\n      if (e instanceof Error && e.message.includes(\"The schema does not contain the path\")) {\n        return false as any;\n      }\n      throw e;\n    }\n  }\n});\n\nyup.addMethod(yup.Schema, \"getNested\", function (path: any) {\n  if (!path.match(/^[a-zA-Z0-9_$:-]*$/)) throw new StackAssertionError(`yupSchema.getNested can currently only be used with alphanumeric keys, underscores, dollar signs, colons, and hyphens. Fix this in the future. Provided key: ${JSON.stringify(path)}`);\n\n  if (!this.hasNested(path as never)) throw new StackAssertionError(`Tried to call yupSchema.getNested, but key is not present in the schema. Provided key: ${path}`, { path, schema: this });\n\n  const schemaInfo = this.meta()?.stackSchemaInfo;\n  if (schemaInfo?.type === \"record\") {\n    return schemaInfo.valueSchema;\n  } else if (schemaInfo?.type === \"union\") {\n    const schemasWithNested = schemaInfo.items.filter((s: any) => s.hasNested(path));\n    return yupUnion(...schemasWithNested.map(s => s.getNested(path)));\n  } else {\n    return yup.reach(this, path) as any;\n  }\n});\n\nundefined?.test(\"hasNested\", ({ expect }) => {\n  expect(yupObject({ a: yupString() }).hasNested(\"a\")).toBe(true);\n  expect(yupObject({}).hasNested(\"a\" as never)).toBe(false);\n  expect(yupRecord(yupString(), yupString()).hasNested(\"a\")).toBe(true);\n  expect(yupRecord(yupString().oneOf([\"a\"]), yupString()).hasNested(\"b\")).toBe(false);\n  expect(yupUnion(yupString(), yupNumber()).hasNested(\"a\" as any)).toBe(false);\n  expect(yupUnion(yupString(), yupObject({ b: yupNumber() })).hasNested(\"a\" as never)).toBe(false);\n  expect(yupUnion(yupString(), yupObject({ a: yupNumber() })).hasNested(\"a\" as never)).toBe(true);\n});\nundefined?.test(\"getNested\", ({ expect }) => {\n  expect(yupObject({ a: yupNumber() }).getNested(\"a\").describe().type).toEqual(\"number\");\n  expect(() => yupObject({}).getNested(\"a\" as never)).toThrow();\n  expect(() => yupObject({ a: yupObject({ b: yupString() }) }).getNested(\"a.b\" as never)).toThrow();\n  expect(yupRecord(yupString().oneOf([\"a\"]), yupNumber()).getNested(\"a\").describe().type).toEqual(\"number\");\n  expect(() => yupRecord(yupString().oneOf([\"a\"]), yupString()).getNested(\"b\" as never)).toThrow();\n  expect(yupUnion(yupString(), yupObject({ a: yupNumber() })).getNested(\"a\" as never).describe().type).toEqual(\"mixed\");\n  expect(yupUnion(yupObject({ a: yupString() }), yupObject({ a: yupNumber() })).getNested(\"a\").describe().type).toEqual(\"mixed\");\n});\n\nexport async function yupValidate<S extends yup.ISchema<any>>(\n  schema: S,\n  obj: unknown,\n  options?: yup.ValidateOptions & { currentUserId?: string | null }\n): Promise<yup.InferType<S>> {\n  try {\n    return await schema.validate(obj, {\n      ...omit(options ?? {}, ['currentUserId']),\n      context: {\n        ...options?.context,\n        stackAllowUserIdMe: options?.currentUserId !== undefined,\n      },\n    });\n  } catch (error) {\n    if (error instanceof ReplaceFieldWithOwnUserId) {\n      const currentUserId = options?.currentUserId;\n      if (!currentUserId) throw new KnownErrors.CannotGetOwnUserWithoutUser();\n\n      // parse yup path\n      let pathRemaining = error.path;\n      const fieldPath = [];\n      while (pathRemaining.length > 0) {\n        if (pathRemaining.startsWith(\"[\")) {\n          const index = pathRemaining.indexOf(\"]\");\n          if (index < 0) throw new StackAssertionError(\"Invalid path\");\n          fieldPath.push(JSON.parse(pathRemaining.slice(1, index)));\n          pathRemaining = pathRemaining.slice(index + 1);\n        } else {\n          let dotIndex = pathRemaining.indexOf(\".\");\n          if (dotIndex === -1) dotIndex = pathRemaining.length;\n          fieldPath.push(pathRemaining.slice(0, dotIndex));\n          pathRemaining = pathRemaining.slice(dotIndex + 1);\n        }\n      }\n\n      const newObj = deepPlainClone(obj);\n      let it = newObj;\n      for (const field of fieldPath.slice(0, -1)) {\n        if (!Object.prototype.hasOwnProperty.call(it, field)) {\n          throw new StackAssertionError(`Segment ${field} of path ${error.path} not found in object`);\n        }\n        it = (it as any)[field];\n      }\n      (it as any)[fieldPath[fieldPath.length - 1]] = currentUserId;\n\n      return await yupValidate(schema, newObj, options);\n    }\n    throw error;\n  }\n}\n\nconst _idDescription = (identify: string) => `The unique identifier of the ${identify}`;\nconst _displayNameDescription = (identify: string) => `Human-readable ${identify} display name. This is not a unique identifier.`;\nconst _clientMetaDataDescription = (identify: string) => `Client metadata. Used as a data store, accessible from the client side. Do not store information that should not be exposed to the client.`;\nconst _clientReadOnlyMetaDataDescription = (identify: string) => `Client read-only, server-writable metadata. Used as a data store, accessible from the client side. Do not store information that should not be exposed to the client. The client can read this data, but cannot modify it. This is useful for things like subscription status.`;\nconst _profileImageUrlDescription = (identify: string) => `URL of the profile image for ${identify}. Can be a Base64 encoded image. Must be smaller than 100KB. Please compress and crop to a square before passing in.`;\nconst _serverMetaDataDescription = (identify: string) => `Server metadata. Used as a data store, only accessible from the server side. You can store secret information related to the ${identify} here.`;\nconst _atMillisDescription = (identify: string) => `(the number of milliseconds since epoch, January 1, 1970, UTC)`;\nconst _createdAtMillisDescription = (identify: string) => `The time the ${identify} was created ${_atMillisDescription(identify)}`;\nconst _signedUpAtMillisDescription = `The time the user signed up ${_atMillisDescription}`;\nconst _lastActiveAtMillisDescription = `The time the user was last active ${_atMillisDescription}`;\n\n\ndeclare const StackAdaptSentinel: unique symbol;\nexport type StackAdaptSentinel = typeof StackAdaptSentinel;\n\n// Built-in replacements\nexport function yupString<A extends string, B extends yup.Maybe<yup.AnyObject> = yup.AnyObject>(...args: Parameters<typeof yup.string<A, B>>) {\n  // eslint-disable-next-line no-restricted-syntax\n  return yup.string(...args).meta({ stackSchemaInfo: { type: \"string\" } });\n}\nexport function yupNumber<A extends number, B extends yup.Maybe<yup.AnyObject> = yup.AnyObject>(...args: Parameters<typeof yup.number<A, B>>) {\n  // eslint-disable-next-line no-restricted-syntax\n  return yup.number(...args).meta({ stackSchemaInfo: { type: \"number\" } });\n}\nexport function yupBoolean<A extends boolean, B extends yup.Maybe<yup.AnyObject> = yup.AnyObject>(...args: Parameters<typeof yup.boolean<A, B>>) {\n  // eslint-disable-next-line no-restricted-syntax\n  return yup.boolean(...args).meta({ stackSchemaInfo: { type: \"boolean\" } });\n}\n/**\n * @deprecated, use number of milliseconds since epoch instead\n */\nexport function yupDate<A extends Date, B extends yup.Maybe<yup.AnyObject> = yup.AnyObject>(...args: Parameters<typeof yup.date<A, B>>) {\n  // eslint-disable-next-line no-restricted-syntax\n  return yup.date(...args).meta({ stackSchemaInfo: { type: \"date\" } });\n}\nfunction _yupMixedInternal<A extends {}>(...args: Parameters<typeof yup.mixed<A>>) {\n  // eslint-disable-next-line no-restricted-syntax\n  return yup.mixed(...args);\n}\nexport function yupMixed<A extends {}>(...args: Parameters<typeof yup.mixed<A>>) {\n  return _yupMixedInternal(...args).meta({ stackSchemaInfo: { type: \"mixed\" } });\n}\nexport function yupArray<A extends yup.Maybe<yup.AnyObject> = yup.AnyObject, B = any>(...args: Parameters<typeof yup.array<A, B>>) {\n  // eslint-disable-next-line no-restricted-syntax\n  return yup.array(...args).meta({ stackSchemaInfo: { type: \"array\" } });\n}\nexport function yupTuple<T extends [unknown, ...unknown[]]>(schemas: { [K in keyof T]: yup.Schema<T[K]> }) {\n  if (schemas.length === 0) throw new Error('yupTuple must have at least one schema');\n  // eslint-disable-next-line no-restricted-syntax\n  return yup.tuple<T>(schemas as any).meta({ stackSchemaInfo: { type: \"tuple\", items: schemas } });\n}\nexport function yupObjectWithAutoDefault<A extends yup.Maybe<yup.AnyObject>, B extends yup.ObjectShape>(...args: Parameters<typeof yup.object<A, B>>) {\n  // eslint-disable-next-line no-restricted-syntax\n  const object = yup.object(...args).test(\n    'no-unknown-object-properties',\n    ({ path }) => `${path} contains unknown properties`,\n    (value: any, context) => {\n      if (context.options.context?.noUnknownPathPrefixes?.some((prefix: string) => context.path.startsWith(prefix))) {\n        if (context.schema.spec.noUnknown !== false) {\n          const availableKeys = new Set(Object.keys(context.schema.fields));\n          const unknownKeys = Object.keys(value ?? {}).filter(key => !availableKeys.has(key));\n          if (unknownKeys.length > 0) {\n            // TODO \"did you mean XYZ\"\n            return context.createError({\n              message: `${context.path || \"Object\"} contains unknown properties: ${unknownKeys.join(', ')}`,\n              path: context.path,\n              params: { unknownKeys, availableKeys },\n            });\n          }\n        }\n      }\n      return true;\n    },\n  ).meta({ stackSchemaInfo: { type: \"object\" } });\n  return object;\n}\nexport function yupObject<A extends yup.Maybe<yup.AnyObject>, B extends yup.ObjectShape>(...args: Parameters<typeof yup.object<A, B>>) {\n  // we don't want to update the type of `object` to have a default flag\n  const object = yupObjectWithAutoDefault(...args);\n  return object.default(undefined) as any as typeof object;\n}\n\nexport function yupNever(): yup.MixedSchema<never> {\n  return _yupMixedInternal().meta({ stackSchemaInfo: { type: \"never\" } }).test('never', 'This value should never be reached', () => false) as any;\n}\n\nexport function yupUnion<T extends yup.AnySchema[]>(...args: T): yup.MixedSchema<yup.InferType<T[number]>> {\n  if (args.length === 0) throw new Error('yupUnion must have at least one schema');\n\n  return _yupMixedInternal().meta({ stackSchemaInfo: { type: \"union\", items: args } }).test('is-one-of', 'Invalid value', async (value, context) => {\n    if (value == null) return true;\n    const errors = [];\n    for (const schema of args) {\n      try {\n        await yupValidate(schema, value, context.options);\n        return true;\n      } catch (e) {\n        errors.push(e);\n      }\n    }\n    return context.createError({\n      message: deindent`\n        ${context.path} is not matched by any of the provided schemas:\n          ${errors.map((e: any, i) => deindent`\n            Schema ${i}:\n              ${e.errors.join('\\n')}\n          `).join('\\n')}`,\n      path: context.path,\n    });\n  });\n}\n\nexport function yupRecord<K extends yup.StringSchema, T extends yup.AnySchema>(\n  keySchema: K,\n  valueSchema: T,\n): yup.MixedSchema<Record<yup.InferType<K> & string, yup.InferType<T>>> {\n  return yupObject().meta({ stackSchemaInfo: { type: \"record\", keySchema, valueSchema } }).unknown(true).test(\n    'record',\n    '${path} must be a record of valid values',\n    async function (value: unknown, context: yup.TestContext) {\n      if (value == null) return true;\n      const { path, createError } = this as any;\n      if (typeof value !== 'object') {\n        return createError({ message: `${path} must be an object` });\n      }\n\n      // Validate each property using the provided valueSchema\n      for (const key of Object.keys(value)) {\n        // Validate the key\n        await yupValidate(keySchema, key, context.options);\n\n        // Validate the value\n        try {\n          await yupValidate(valueSchema, (value as Record<string, unknown>)[key], {\n            ...context.options,\n            context: {\n              ...context.options.context,\n              path: path ? `${path}.${key}` : key,\n            },\n          });\n        } catch (e: any) {\n          return createError({\n            path: path ? `${path}.${key}` : key,\n            message: e.message,\n          });\n        }\n      }\n\n      return true;\n    },\n  ) as any;\n}\n\nexport function ensureObjectSchema<T extends yup.AnyObject>(schema: yup.Schema<T>): yup.ObjectSchema<T> & typeof schema {\n  if (!(schema instanceof yup.ObjectSchema)) throw new StackAssertionError(`assertObjectSchema: schema is not an ObjectSchema: ${schema.describe().type}`);\n  return schema as any;\n}\n\n// Common\nexport const adaptSchema = yupMixed<StackAdaptSentinel>();\n/**\n * Yup's URL schema does not recognize some URLs (including `http://localhost`) as a valid URL. This schema is a workaround for that.\n */\nexport const urlSchema = yupString().test({\n  name: 'no-spaces',\n  message: (params) => `${params.path} contains spaces`,\n  test: (value) => value == null || !value.includes(' ')\n}).test({\n  name: 'url',\n  message: (params) => `${params.path} is not a valid URL`,\n  test: (value) => value == null || isValidUrl(value)\n});\n/**\n * URL schema that supports wildcard patterns in hostnames (e.g., \"https://*.example.com\", \"http://*:8080\")\n */\nexport const wildcardUrlSchema = yupString().test({\n  name: 'no-spaces',\n  message: (params) => `${params.path} contains spaces`,\n  test: (value) => value == null || !value.includes(' ')\n}).test({\n  name: 'wildcard-url',\n  message: (params) => `${params.path} is not a valid URL or wildcard URL pattern`,\n  test: (value) => {\n    if (value == null) return true;\n\n    // If it doesn't contain wildcards, use the regular URL validation\n    if (!value.includes('*')) {\n      return isValidUrl(value);\n    }\n\n    // For wildcard URLs, validate the structure by replacing wildcards with placeholders\n    try {\n      const PLACEHOLDER = 'wildcard-placeholder';\n      // Replace wildcards with valid placeholders for URL parsing\n      const normalizedUrl = value.replace(/\\*/g, PLACEHOLDER);\n      const url = new URL(normalizedUrl);\n\n      // Only allow wildcards in the hostname; reject anywhere else\n      if (\n        url.username.includes(PLACEHOLDER) ||\n        url.password.includes(PLACEHOLDER) ||\n        url.pathname.includes(PLACEHOLDER) ||\n        url.search.includes(PLACEHOLDER) ||\n        url.hash.includes(PLACEHOLDER)\n      ) {\n        return false;\n      }\n\n      // Only http/https are acceptable\n      if (url.protocol !== 'http:' && url.protocol !== 'https:') {\n        return false;\n      }\n\n      // Extract original hostname pattern from the input\n      const hostPattern = url.hostname.split(PLACEHOLDER).join('*');\n\n      // Validate the wildcard hostname pattern using the existing function\n      return isValidHostnameWithWildcards(hostPattern);\n    } catch (e) {\n      return false;\n    }\n  }\n});\nexport const wildcardProtocolAndDomainSchema = wildcardUrlSchema.test({\n  name: 'is-protocol-and-domain',\n  message: (params) => `${params.path} must be a protocol and domain (with optional port) without any path, query parameters, or hash`,\n  test: (value) => {\n    if (value == null) return true;\n    try {\n      const PLACEHOLDER = 'wildcard-placeholder';\n      // Replace wildcards with valid placeholders for URL parsing\n      const normalized = value.replace(/\\*/g, PLACEHOLDER);\n      const url = new URL(normalized);\n      return url.protocol !== '' && url.hostname !== '' && url.pathname === '/' && url.search === '' && url.hash === '';\n    } catch (e) {\n      return false;\n    }\n  }\n});\nexport const jsonSchema = yupMixed().nullable().defined().transform((value) => JSON.parse(JSON.stringify(value)));\nexport const jsonStringSchema = yupString().test(\"json\", (params) => `${params.path} is not valid JSON`, (value) => {\n  if (value == null) return true;\n  try {\n    JSON.parse(value);\n    return true;\n  } catch (error) {\n    return false;\n  }\n});\nexport const jsonStringOrEmptySchema = yupString().test(\"json\", (params) => `${params.path} is not valid JSON`, (value) => {\n  if (!value) return true;\n  try {\n    JSON.parse(value);\n    return true;\n  } catch (error) {\n    return false;\n  }\n});\nexport const base64Schema = yupString().test(\"is-base64\", (params) => `${params.path} is not valid base64`, (value) => {\n  if (value == null) return true;\n  return isBase64(value);\n});\nexport const passwordSchema = yupString().max(70);\nexport const intervalSchema = yupTuple<Interval>([yupNumber().min(0).integer().defined(), yupString().oneOf(['millisecond', 'second', 'minute', 'hour', 'day', 'week', 'month', 'year']).defined()]);\nexport const dayIntervalSchema = yupTuple<DayInterval>([yupNumber().min(0).integer().defined(), yupString().oneOf(['day', 'week', 'month', 'year']).defined()]);\nexport const intervalOrNeverSchema = yupUnion(intervalSchema.defined(), yupString().oneOf(['never']).defined());\nexport const dayIntervalOrNeverSchema = yupUnion(dayIntervalSchema.defined(), yupString().oneOf(['never']).defined());\n/**\n * This schema is useful for fields where the user can specify the ID, such as price IDs. It is particularly common\n * for IDs in the config schema.\n */\nexport const userSpecifiedIdSchema = (idName: `${string}Id`) => yupString().max(63).matches(/^[a-zA-Z0-9_][a-zA-Z0-9_-]*$/, `${idName} must contain only letters, numbers, underscores, and hyphens, and not start with a hyphen`);\nexport const moneyAmountSchema = (currency: Currency) => yupString<MoneyAmount>().test('money-amount', 'Invalid money amount', (value, context) => {\n  if (value == null) return true;\n  const regex = /^([0-9]+)(\\.([0-9]+))?$/;\n  const match = value.match(regex);\n  if (!match) return context.createError({ message: 'Money amount must be in the format of <number> or <number>.<number>' });\n  const whole = match[1];\n  const decimals = match[3];\n  if (decimals && decimals.length > currency.decimals) return context.createError({ message: `Too many decimals; ${currency.code} only has ${currency.decimals} decimals` });\n  if (whole !== '0' && whole.startsWith('0')) return context.createError({ message: 'Money amount must not have leading zeros' });\n  return true;\n});\n\n\n/**\n * A stricter email schema that does some additional checks for UX input. (Some emails are allowed by the spec, for\n * example `test@localhost` or `abc@gmail`, but almost certainly a user input error.)\n *\n * Note that some users in the DB have an email that doesn't match this regex, so most of the time you should use\n * `emailSchema` instead until we do the DB migration.\n */\n// eslint-disable-next-line no-restricted-syntax\nexport const strictEmailSchema = (message: string | undefined) => yupString().email(message).max(256).matches(/^[^.]+(\\.[^.]+)*@.*\\.[^.][^.]+$/, message);\n// eslint-disable-next-line no-restricted-syntax\nexport const emailSchema = yupString().email();\n\nundefined?.test('strictEmailSchema', ({ expect }) => {\n  const validEmails = [\n    \"a@example.com\",\n    \"abc@example.com\",\n    \"a.b@example.com\",\n    \"throwaway.mail+token@example.com\",\n    \"email-alt-dash@demo-mail.com\",\n    \"test-account@weird-domain.net\",\n    \"%!~&+{}=|`#@domain.test\",\n    \"admin@a.longtldexample\",\n  ];\n  for (const email of validEmails) {\n    expect(strictEmailSchema(undefined).validateSync(email)).toBe(email);\n  }\n  const invalidEmails = [\n    \"test@localhost\",\n    \"test@gmail\",\n    \"test@gmail.com.a\",\n    \"test@gmail.a\",\n    \"test.@example.com\",\n    \"test..test@example.com\",\n    \".test@example.com\",\n  ];\n  for (const email of invalidEmails) {\n    expect(() => strictEmailSchema(undefined).validateSync(email)).toThrow();\n  }\n});\n\n// Request auth\nexport const clientOrHigherAuthTypeSchema = yupString().oneOf(['client', 'server', 'admin']).defined();\nexport const serverOrHigherAuthTypeSchema = yupString().oneOf(['server', 'admin']).defined();\nexport const adminAuthTypeSchema = yupString().oneOf(['admin']).defined();\n\n// Projects\nexport const projectIdSchema = yupString().test((v) => v === undefined || v === \"internal\" || isUuid(v)).meta({ openapiField: { description: _idDescription('project'), exampleValue: 'e0b52f4d-dece-408c-af49-d23061bb0f8d' } });\nexport const projectBranchIdSchema = yupString().nonEmpty().max(255).meta({ openapiField: { description: _idDescription('project branch'), exampleValue: 'main' } });\nexport const projectDisplayNameSchema = yupString().meta({ openapiField: { description: _displayNameDescription('project'), exampleValue: 'MyMusic' } });\nexport const projectLogoUrlSchema = urlSchema.max(MAX_IMAGE_SIZE_BASE64_BYTES).meta({ openapiField: { description: 'URL of the logo for the project. This is usually a close to 1:1 image of the company logo.', exampleValue: 'https://example.com/logo.png' } });\nexport const projectLogoFullUrlSchema = urlSchema.max(MAX_IMAGE_SIZE_BASE64_BYTES).meta({ openapiField: { description: 'URL of the full logo for the project. This is usually a vertical image with the logo and the company name.', exampleValue: 'https://example.com/full-logo.png' } });\nexport const projectLogoDarkModeUrlSchema = urlSchema.max(MAX_IMAGE_SIZE_BASE64_BYTES).meta({ openapiField: { description: 'URL of the dark mode logo for the project. This is usually a close to 1:1 image of the company logo optimized for dark backgrounds.', exampleValue: 'https://example.com/logo-dark.png' } });\nexport const projectLogoFullDarkModeUrlSchema = urlSchema.max(MAX_IMAGE_SIZE_BASE64_BYTES).meta({ openapiField: { description: 'URL of the dark mode full logo for the project. This is usually a vertical image with the logo and the company name optimized for dark backgrounds.', exampleValue: 'https://example.com/full-logo-dark.png' } });\nexport const projectDescriptionSchema = yupString().nullable().meta({ openapiField: { description: 'A human readable description of the project', exampleValue: 'A music streaming service' } });\nexport const projectCreatedAtMillisSchema = yupNumber().meta({ openapiField: { description: _createdAtMillisDescription('project'), exampleValue: 1630000000000 } });\nexport const projectIsProductionModeSchema = yupBoolean().meta({ openapiField: { description: 'Whether the project is in production mode', exampleValue: true } });\n// Project config\nexport const projectConfigIdSchema = yupString().meta({ openapiField: { description: _idDescription('project config'), exampleValue: 'd09201f0-54f5-40bd-89ff-6d1815ddad24' } });\nexport const projectAllowLocalhostSchema = yupBoolean().meta({ openapiField: { description: 'Whether localhost is allowed as a domain for this project. Should only be allowed in development mode', exampleValue: true } });\nexport const projectCreateTeamOnSignUpSchema = yupBoolean().meta({ openapiField: { description: 'Whether a team should be created for each user that signs up', exampleValue: true } });\nexport const projectMagicLinkEnabledSchema = yupBoolean().meta({ openapiField: { description: 'Whether magic link authentication is enabled for this project', exampleValue: true } });\nexport const projectPasskeyEnabledSchema = yupBoolean().meta({ openapiField: { description: 'Whether passkey authentication is enabled for this project', exampleValue: true } });\nexport const projectClientTeamCreationEnabledSchema = yupBoolean().meta({ openapiField: { description: 'Whether client users can create teams', exampleValue: true } });\nexport const projectClientUserDeletionEnabledSchema = yupBoolean().meta({ openapiField: { description: 'Whether client users can delete their own account from the client', exampleValue: true } });\nexport const projectSignUpEnabledSchema = yupBoolean().meta({ openapiField: { description: 'Whether users can sign up new accounts, or whether they are only allowed to sign in to existing accounts. Regardless of this option, the server API can always create new users with the `POST /users` endpoint.', exampleValue: true } });\nexport const projectCredentialEnabledSchema = yupBoolean().meta({ openapiField: { description: 'Whether email password authentication is enabled for this project', exampleValue: true } });\n// Project OAuth config\nexport const oauthIdSchema = yupString().oneOf(allProviders).meta({ openapiField: { description: `OAuth provider ID, one of ${allProviders.map(x => `\\`${x}\\``).join(', ')}`, exampleValue: 'google' } });\nexport const oauthEnabledSchema = yupBoolean().meta({ openapiField: { description: 'Whether the OAuth provider is enabled. If an provider is first enabled, then disabled, it will be shown in the list but with enabled=false', exampleValue: true } });\nexport const oauthTypeSchema = yupString().oneOf(['shared', 'standard']).meta({ openapiField: { description: 'OAuth provider type, one of shared, standard. \"shared\" uses Stack shared OAuth keys and it is only meant for development. \"standard\" uses your own OAuth keys and will show your logo and company name when signing in with the provider.', exampleValue: 'standard' } });\nexport const oauthClientIdSchema = yupString().meta({ openapiField: { description: 'OAuth client ID. Needs to be specified when using type=\"standard\"', exampleValue: 'google-oauth-client-id' } });\nexport const oauthClientSecretSchema = yupString().meta({ openapiField: { description: 'OAuth client secret. Needs to be specified when using type=\"standard\"', exampleValue: 'google-oauth-client-secret' } });\nexport const oauthFacebookConfigIdSchema = yupString().meta({ openapiField: { description: 'The configuration id for Facebook business login (for things like ads and marketing). This is only required if you are using the standard OAuth with Facebook and you are using Facebook business login.' } });\nexport const oauthMicrosoftTenantIdSchema = yupString().meta({ openapiField: { description: 'The Microsoft tenant id for Microsoft directory. This is only required if you are using the standard OAuth with Microsoft and you have an Azure AD tenant.' } });\nexport const oauthAccountMergeStrategySchema = yupString().oneOf(['link_method', 'raise_error', 'allow_duplicates']).meta({ openapiField: { description: 'Determines how to handle OAuth logins that match an existing user by email. `link_method` adds the OAuth method to the existing user. `raise_error` rejects the login with an error. `allow_duplicates` creates a new user.', exampleValue: 'link_method' } });\n// Project email config\nexport const emailTypeSchema = yupString().oneOf(['shared', 'standard']).meta({ openapiField: { description: 'Email provider type, one of shared, standard. \"shared\" uses Stack shared email provider and it is only meant for development. \"standard\" uses your own email server and will have your email address as the sender.', exampleValue: 'standard' } });\nexport const emailSenderNameSchema = yupString().meta({ openapiField: { description: 'Email sender name. Needs to be specified when using type=\"standard\"', exampleValue: 'Stack' } });\nexport const emailHostSchema = yupString().meta({ openapiField: { description: 'Email host. Needs to be specified when using type=\"standard\"', exampleValue: 'smtp.your-domain.com' } });\nexport const emailPortSchema = yupNumber().min(0).max(65535).meta({ openapiField: { description: 'Email port. Needs to be specified when using type=\"standard\"', exampleValue: 587 } });\nexport const emailUsernameSchema = yupString().meta({ openapiField: { description: 'Email username. Needs to be specified when using type=\"standard\"', exampleValue: 'smtp-email' } });\nexport const emailSenderEmailSchema = emailSchema.meta({ openapiField: { description: 'Email sender email. Needs to be specified when using type=\"standard\"', exampleValue: 'example@your-domain.com' } });\nexport const emailPasswordSchema = passwordSchema.meta({ openapiField: { description: 'Email password. Needs to be specified when using type=\"standard\"', exampleValue: 'your-email-password' } });\n// Project domain config\nexport const handlerPathSchema = yupString().test('is-handler-path', 'Handler path must start with /', (value) => value?.startsWith('/')).meta({ openapiField: { description: 'Handler path. If you did not setup a custom handler path, it should be \"/handler\" by default. It needs to start with /', exampleValue: '/handler' } });\n// Project email theme config\nexport const emailThemeSchema = yupString().meta({ openapiField: { description: 'Email theme id for the project. Determines the visual style of emails sent by the project.' } });\nexport const emailThemeListSchema = yupRecord(\n  yupString().uuid(),\n  yupObject({\n    displayName: yupString().meta({ openapiField: { description: 'Email theme name', exampleValue: 'Default Light' } }).defined(),\n    tsxSource: yupString().meta({ openapiField: { description: 'Email theme source code tsx component' } }).defined(),\n  })\n).meta({ openapiField: { description: 'Record of email theme IDs to their display name and source code' } });\nexport const templateThemeIdSchema = yupMixed<string | false>().test((v: any) => v === undefined || v === false || v === null || (typeof v === 'string' && isUuid(v))).meta({ openapiField: { description: 'Email theme id for the template' } }).optional();\nexport const emailTemplateListSchema = yupRecord(\n  yupString().uuid(),\n  yupObject({\n    displayName: yupString().meta({ openapiField: { description: 'Email template name', exampleValue: 'Email Verification' } }).defined(),\n    tsxSource: yupString().meta({ openapiField: { description: 'Email template source code tsx component' } }).defined(),\n    // themeId can be one of three values:\n    // 1. A valid theme id\n    // 2. false, which means the template uses no theme\n    // 3. undefined/not given, which means the template uses the project's active theme\n    themeId: templateThemeIdSchema,\n  })\n).meta({ openapiField: { description: 'Record of email template IDs to their display name and source code' } });\n\n// Payments\nexport const customerTypeSchema = yupString().oneOf(['user', 'team', 'custom']);\nconst validateHasAtLeastOneSupportedCurrency = (value: Record<string, unknown> | null, context: any) => {\n  if (!value) return true;\n  const currencies = Object.keys(value).filter(key => SUPPORTED_CURRENCIES.some(c => c.code === key));\n  if (currencies.length === 0) {\n    return context.createError({ message: \"At least one currency is required\" });\n  }\n  return true;\n};\nexport const productPriceSchema = yupObject({\n  ...typedFromEntries(SUPPORTED_CURRENCIES.map(currency => [currency.code, moneyAmountSchema(currency).optional()])),\n  interval: dayIntervalSchema.optional(),\n  serverOnly: yupBoolean(),\n  freeTrial: dayIntervalSchema.optional(),\n}).test(\"at-least-one-currency\", (value, context) => validateHasAtLeastOneSupportedCurrency(value, context));\nexport const priceOrIncludeByDefaultSchema = yupUnion(\n  yupString().oneOf(['include-by-default']).meta({ openapiField: { description: 'Makes this item free and includes it by default for all customers.', exampleValue: 'include-by-default' } }),\n  yupRecord(\n    userSpecifiedIdSchema(\"priceId\"),\n    productPriceSchema,\n  ),\n);\nexport const productSchema = yupObject({\n  displayName: yupString(),\n  catalogId: userSpecifiedIdSchema(\"catalogId\").optional().meta({ openapiField: { description: 'The ID of the catalog this product belongs to. Within a catalog, all products are mutually exclusive unless they are an add-on to another product in the catalog.', exampleValue: 'catalog-id' } }),\n  isAddOnTo: yupUnion(\n    yupBoolean().isFalse(),\n    yupRecord(\n      userSpecifiedIdSchema(\"productId\"),\n      yupBoolean().isTrue().defined(),\n    ),\n  ).optional().meta({ openapiField: { description: 'The products that this product is an add-on to. If this is set, the customer must already have one of the products in the record to be able to purchase this product.', exampleValue: { \"product-id\": true } } }),\n  customerType: customerTypeSchema.defined(),\n  freeTrial: dayIntervalSchema.optional(),\n  serverOnly: yupBoolean(),\n  stackable: yupBoolean(),\n  prices: priceOrIncludeByDefaultSchema.defined(),\n  includedItems: yupRecord(\n    userSpecifiedIdSchema(\"itemId\"),\n    yupObject({\n      quantity: yupNumber().defined(),\n      repeat: dayIntervalOrNeverSchema.optional(),\n      expires: yupString().oneOf(['never', 'when-purchase-expires', 'when-repeated']).optional(),\n    }),\n  ),\n});\n\nconst productMetadataExample = { featureFlag: true, source: 'marketing-campaign' } as const;\n\nexport const productClientMetadataSchema = jsonSchema.meta({ openapiField: { description: _clientMetaDataDescription('product'), exampleValue: productMetadataExample } });\nexport const productClientReadOnlyMetadataSchema = jsonSchema.meta({ openapiField: { description: _clientReadOnlyMetaDataDescription('product'), exampleValue: productMetadataExample } });\nexport const productServerMetadataSchema = jsonSchema.meta({ openapiField: { description: _serverMetaDataDescription('product'), exampleValue: productMetadataExample } });\n\nexport const productSchemaWithMetadata = productSchema.concat(yupObject({\n  clientMetadata: productClientMetadataSchema.optional(),\n  clientReadOnlyMetadata: productClientReadOnlyMetadataSchema.optional(),\n  serverMetadata: productServerMetadataSchema.optional(),\n}));\n\nexport const inlineProductSchema = yupObject({\n  display_name: yupString().defined(),\n  customer_type: customerTypeSchema.defined(),\n  free_trial: dayIntervalSchema.optional(),\n  server_only: yupBoolean().default(true),\n  stackable: yupBoolean().default(false),\n  prices: yupRecord(\n    userSpecifiedIdSchema(\"priceId\"),\n    yupObject({\n      ...typedFromEntries(SUPPORTED_CURRENCIES.map(currency => [currency.code, moneyAmountSchema(currency).optional()])),\n      interval: dayIntervalSchema.optional(),\n      free_trial: dayIntervalSchema.optional(),\n    }).test(\"at-least-one-currency\", (value, context) => validateHasAtLeastOneSupportedCurrency(value, context)),\n  ),\n  included_items: yupRecord(\n    userSpecifiedIdSchema(\"itemId\"),\n    yupObject({\n      quantity: yupNumber(),\n      repeat: dayIntervalOrNeverSchema.optional(),\n      expires: yupString().oneOf(['never', 'when-purchase-expires', 'when-repeated']).optional(),\n    }),\n  ),\n  client_metadata: productClientMetadataSchema.optional(),\n  client_read_only_metadata: productClientReadOnlyMetadataSchema.optional(),\n  server_metadata: productServerMetadataSchema.optional(),\n});\n\n// Users\nexport class ReplaceFieldWithOwnUserId extends Error {\n  constructor(public readonly path: string) {\n    super(`This error should be caught by whoever validated the schema, and the field in the path '${path}' should be replaced with the current user's id. This is a workaround to yup not providing access to the context inside the transform function.`);\n  }\n}\nconst userIdMeSentinelUuid = \"cad564fd-f81b-43f4-b390-98abf3fcc17e\";\nexport const userIdOrMeSchema = yupString().uuid().transform(v => {\n  if (v === \"me\") return userIdMeSentinelUuid;\n  else return v;\n}).test((v, context) => {\n  if (!(\"stackAllowUserIdMe\" in (context.options.context ?? {}))) throw new StackAssertionError('userIdOrMeSchema is not allowed in this context. Make sure you\\'re using yupValidate from schema-fields.ts to validate, instead of schema.validate(...).');\n  if (!context.options.context?.stackAllowUserIdMe) throw new StackAssertionError('userIdOrMeSchema is not allowed in this context. Make sure you\\'re passing in the currentUserId option in yupValidate.');\n  if (v === userIdMeSentinelUuid) throw new ReplaceFieldWithOwnUserId(context.path);\n  return true;\n}).meta({ openapiField: { description: 'The ID of the user, or the special value `me` for the currently authenticated user', exampleValue: '3241a285-8329-4d69-8f3d-316e08cf140c' } });\nexport const userIdSchema = yupString().uuid().meta({ openapiField: { description: _idDescription('user'), exampleValue: '3241a285-8329-4d69-8f3d-316e08cf140c' } });\nexport const primaryEmailSchema = emailSchema.meta({ openapiField: { description: 'Primary email', exampleValue: 'johndoe@example.com' } });\nexport const primaryEmailAuthEnabledSchema = yupBoolean().meta({ openapiField: { description: 'Whether the primary email is used for authentication. If this is set to `false`, the user will not be able to sign in with the primary email with password or OTP', exampleValue: true } });\nexport const primaryEmailVerifiedSchema = yupBoolean().meta({ openapiField: { description: 'Whether the primary email has been verified to belong to this user', exampleValue: true } });\nexport const userDisplayNameSchema = yupString().nullable().max(256).meta({ openapiField: { description: _displayNameDescription('user'), exampleValue: 'John Doe' } });\nexport const selectedTeamIdSchema = yupString().uuid().meta({ openapiField: { description: 'ID of the team currently selected by the user', exampleValue: 'team-id' } });\nexport const profileImageUrlSchema = urlSchema.max(MAX_IMAGE_SIZE_BASE64_BYTES).meta({ openapiField: { description: _profileImageUrlDescription('user'), exampleValue: 'https://example.com/image.jpg' } });\nexport const signedUpAtMillisSchema = yupNumber().meta({ openapiField: { description: _signedUpAtMillisDescription, exampleValue: 1630000000000 } });\nexport const userClientMetadataSchema = jsonSchema.meta({ openapiField: { description: _clientMetaDataDescription('user'), exampleValue: { key: 'value' } } });\nexport const userClientReadOnlyMetadataSchema = jsonSchema.meta({ openapiField: { description: _clientReadOnlyMetaDataDescription('user'), exampleValue: { key: 'value' } } });\nexport const userServerMetadataSchema = jsonSchema.meta({ openapiField: { description: _serverMetaDataDescription('user'), exampleValue: { key: 'value' } } });\nexport const userOAuthProviderSchema = yupObject({\n  id: yupString().defined(),\n  type: yupString().oneOf(allProviders).defined(),\n  provider_user_id: yupString().defined(),\n});\nexport const userLastActiveAtMillisSchema = yupNumber().nullable().meta({ openapiField: { description: _lastActiveAtMillisDescription, exampleValue: 1630000000000 } });\nexport const userPasskeyAuthEnabledSchema = yupBoolean().meta({ openapiField: { hidden: true, description: 'Whether the user has passkeys enabled', exampleValue: false } });\nexport const userOtpAuthEnabledSchema = yupBoolean().meta({ openapiField: { hidden: true, description: 'Whether the user has OTP/magic link enabled. ', exampleValue: true } });\nexport const userOtpAuthEnabledMutationSchema = yupBoolean().meta({ openapiField: { hidden: true, description: 'Whether the user has OTP/magic link enabled. Note that only accounts with verified emails can sign-in with OTP.', exampleValue: true } });\nexport const userHasPasswordSchema = yupBoolean().meta({ openapiField: { hidden: true, description: 'Whether the user has a password set. If the user does not have a password set, they will not be able to sign in with email/password.', exampleValue: true } });\nexport const userPasswordMutationSchema = passwordSchema.nullable().meta({ openapiField: { description: 'Sets the user\\'s password. Doing so revokes all current sessions.', exampleValue: 'my-new-password' } }).max(70);\nexport const userPasswordHashMutationSchema = yupString()\n  .nonEmpty()\n  .meta({ openapiField: { description: 'If `password` is not given, sets the user\\'s password hash to the given string in Modular Crypt Format (ex.: `$2a$10$VIhIOofSMqGdGlL4wzE//e.77dAQGqNtF/1dT7bqCrVtQuInWy2qi`). Doing so revokes all current sessions.' } });  // we don't set an exampleValue here because it's exclusive with the password field and having both would break the generated example\nexport const userTotpSecretMutationSchema = base64Schema.nullable().meta({ openapiField: { description: 'Enables 2FA and sets a TOTP secret for the user. Set to null to disable 2FA.', exampleValue: 'dG90cC1zZWNyZXQ=' } });\n\n// Auth\nexport const accessTokenPayloadSchema = yupObject({\n  sub: yupString().defined(),\n  exp: yupNumber().optional(),\n  iss: yupString().defined(),\n  aud: yupString().defined(),\n  project_id: yupString().defined(),\n  branch_id: yupString().defined(),\n  refresh_token_id: yupString().defined(),\n  role: yupString().oneOf([\"authenticated\"]).defined(),\n  name: yupString().defined().nullable(),\n  email: yupString().defined().nullable(),\n  email_verified: yupBoolean().defined(),\n  selected_team_id: yupString().defined().nullable(),\n  is_anonymous: yupBoolean().defined(),\n});\nexport const signInEmailSchema = strictEmailSchema(undefined).meta({ openapiField: { description: 'The email to sign in with.', exampleValue: 'johndoe@example.com' } });\nexport const emailOtpSignInCallbackUrlSchema = urlSchema.meta({ openapiField: { description: 'The base callback URL to construct the magic link from. A query parameter `code` with the verification code will be appended to it. The page should then make a request to the `/auth/otp/sign-in` endpoint.', exampleValue: 'https://example.com/handler/magic-link-callback' } });\nexport const emailVerificationCallbackUrlSchema = urlSchema.meta({ openapiField: { description: 'The base callback URL to construct a verification link for the verification e-mail. A query parameter `code` with the verification code will be appended to it. The page should then make a request to the `/contact-channels/verify` endpoint.', exampleValue: 'https://example.com/handler/email-verification' } });\nexport const accessTokenResponseSchema = yupString().meta({ openapiField: { description: 'Short-lived access token that can be used to authenticate the user', exampleValue: 'eyJhmMiJB2TO...diI4QT' } });\nexport const refreshTokenResponseSchema = yupString().meta({ openapiField: { description: 'Long-lived refresh token that can be used to obtain a new access token', exampleValue: 'i8ns3aq2...14y' } });\nexport const signInResponseSchema = yupObject({\n  refresh_token: refreshTokenResponseSchema.defined(),\n  access_token: accessTokenResponseSchema.defined(),\n  is_new_user: yupBoolean().meta({ openapiField: { description: 'Whether the user is a new user', exampleValue: true } }).defined(),\n  user_id: userIdSchema.defined(),\n});\n\n// Permissions\nexport const teamSystemPermissions = [\n  '$update_team',\n  '$delete_team',\n  '$read_members',\n  '$remove_members',\n  '$invite_members',\n  '$manage_api_keys',\n] as const;\nexport const permissionDefinitionIdSchema = yupString()\n  .matches(/^\\$?[a-z0-9_:]+$/, 'Only lowercase letters, numbers, \":\", \"_\" and optional \"$\" at the beginning are allowed')\n  .test('is-system-permission', 'System permissions must start with a dollar sign', (value, ctx) => {\n    if (!value) return true;\n    if (value.startsWith('$') && !teamSystemPermissions.includes(value as any)) {\n      return ctx.createError({ message: 'Invalid system permission' });\n    }\n    return true;\n  })\n  .meta({ openapiField: { description: `The permission ID used to uniquely identify a permission. Can either be a custom permission with lowercase letters, numbers, \\`:\\`, and \\`_\\` characters, or one of the system permissions: ${teamSystemPermissions.map(x => `\\`${x}\\``).join(', ')}`, exampleValue: 'read_secret_info' } });\nexport const customPermissionDefinitionIdSchema = yupString()\n  .matches(/^[a-z0-9_:]+$/, 'Only lowercase letters, numbers, \":\", \"_\" are allowed')\n  .meta({ openapiField: { description: 'The permission ID used to uniquely identify a permission. Can only contain lowercase letters, numbers, \":\", and \"_\" characters', exampleValue: 'read_secret_info' } });\nexport const teamPermissionDescriptionSchema = yupString().meta({ openapiField: { description: 'A human-readable description of the permission', exampleValue: 'Read secret information' } });\nexport const containedPermissionIdsSchema = yupArray(permissionDefinitionIdSchema.defined()).meta({ openapiField: { description: 'The IDs of the permissions that are contained in this permission', exampleValue: ['read_public_info'] } });\n\n// Teams\nexport const teamIdSchema = yupString().uuid().meta({ openapiField: { description: _idDescription('team'), exampleValue: 'ad962777-8244-496a-b6a2-e0c6a449c79e' } });\nexport const teamDisplayNameSchema = yupString().meta({ openapiField: { description: _displayNameDescription('team'), exampleValue: 'My Team' } });\nexport const teamProfileImageUrlSchema = urlSchema.max(1000000).meta({ openapiField: { description: _profileImageUrlDescription('team'), exampleValue: 'https://example.com/image.jpg' } });\nexport const teamClientMetadataSchema = jsonSchema.meta({ openapiField: { description: _clientMetaDataDescription('team'), exampleValue: { key: 'value' } } });\nexport const teamClientReadOnlyMetadataSchema = jsonSchema.meta({ openapiField: { description: _clientReadOnlyMetaDataDescription('team'), exampleValue: { key: 'value' } } });\nexport const teamServerMetadataSchema = jsonSchema.meta({ openapiField: { description: _serverMetaDataDescription('team'), exampleValue: { key: 'value' } } });\nexport const teamCreatedAtMillisSchema = yupNumber().meta({ openapiField: { description: _createdAtMillisDescription('team'), exampleValue: 1630000000000 } });\nexport const teamInvitationEmailSchema = emailSchema.meta({ openapiField: { description: 'The email of the user to invite.', exampleValue: 'johndoe@example.com' } });\nexport const teamInvitationCallbackUrlSchema = urlSchema.meta({ openapiField: { description: 'The base callback URL to construct an invite link with. A query parameter `code` with the verification code will be appended to it. The page should then make a request to the `/team-invitations/accept` endpoint.', exampleValue: 'https://example.com/handler/team-invitation' } });\nexport const teamCreatorUserIdSchema = userIdOrMeSchema.meta({ openapiField: { description: 'The ID of the creator of the team. If not specified, the user will not be added to the team. Can be either \"me\" or the ID of the user. Only used on the client side.', exampleValue: 'me' } });\n\n// Team member profiles\nexport const teamMemberDisplayNameSchema = yupString().meta({ openapiField: { description: _displayNameDescription('team member') + ' Note that this is separate from the display_name of the user.', exampleValue: 'John Doe' } });\nexport const teamMemberProfileImageUrlSchema = urlSchema.max(1000000).meta({ openapiField: { description: _profileImageUrlDescription('team member'), exampleValue: 'https://example.com/image.jpg' } });\n\n// Contact channels\nexport const contactChannelIdSchema = yupString().uuid().meta({ openapiField: { description: _idDescription('contact channel'), exampleValue: 'b3d396b8-c574-4c80-97b3-50031675ceb2' } });\nexport const contactChannelTypeSchema = yupString().oneOf(['email']).meta({ openapiField: { description: `The type of the contact channel. Currently only \"email\" is supported.`, exampleValue: 'email' } });\nexport const contactChannelValueSchema = yupString().when('type', {\n  is: 'email',\n  then: (schema) => schema.email(),\n}).meta({ openapiField: { description: 'The value of the contact channel. For email, this should be a valid email address.', exampleValue: 'johndoe@example.com' } });\nexport const contactChannelUsedForAuthSchema = yupBoolean().meta({ openapiField: { description: 'Whether the contact channel is used for authentication. If this is set to `true`, the user will be able to sign in with the contact channel with password or OTP.', exampleValue: true } });\nexport const contactChannelIsVerifiedSchema = yupBoolean().meta({ openapiField: { description: 'Whether the contact channel has been verified. If this is set to `true`, the contact channel has been verified to belong to the user.', exampleValue: true } });\nexport const contactChannelIsPrimarySchema = yupBoolean().meta({ openapiField: { description: 'Whether the contact channel is the primary contact channel. If this is set to `true`, it will be used for authentication and notifications by default.', exampleValue: true } });\n\n// OAuth providers\nexport const oauthProviderIdSchema = yupString().uuid().meta({ openapiField: { description: _idDescription('OAuth provider'), exampleValue: 'b3d396b8-c574-4c80-97b3-50031675ceb2' } });\nexport const oauthProviderEmailSchema = emailSchema.meta({ openapiField: { description: 'Email of the OAuth provider. This is used to display and identify the OAuth provider in the UI.', exampleValue: 'test@gmail.com' } });\nexport const oauthProviderTypeSchema = yupString().oneOf(allProviders).meta({ openapiField: { description: `OAuth provider type, one of ${allProviders.map(x => `\\`${x}\\``).join(', ')}`, exampleValue: 'google' } });\nexport const oauthProviderAllowSignInSchema = yupBoolean().meta({ openapiField: { description: 'Whether the user can use this OAuth provider to sign in. Only one OAuth provider per type can have this set to `true`.', exampleValue: true } });\nexport const oauthProviderAllowConnectedAccountsSchema = yupBoolean().meta({ openapiField: { description: 'Whether the user can use this OAuth provider as connected account. Multiple OAuth providers per type can have this set to `true`.', exampleValue: true } });\nexport const oauthProviderAccountIdSchema = yupString().meta({ openapiField: { description: 'Account ID of the OAuth provider. This uniquely identifies the account on the provider side.', exampleValue: 'google-account-id-12345' } });\nexport const oauthProviderProviderConfigIdSchema = yupString().meta({ openapiField: { description: 'Provider config ID of the OAuth provider. This uniquely identifies the provider config on config.json file', exampleValue: 'google' } });\n\n// Headers\nexport const basicAuthorizationHeaderSchema = yupString().test('is-basic-authorization-header', 'Authorization header must be in the format \"Basic <base64>\"', (value) => {\n  if (!value) return true;\n  return decodeBasicAuthorizationHeader(value) !== null;\n});\n\n// Neon integration\nexport const neonAuthorizationHeaderSchema = basicAuthorizationHeaderSchema.test('is-authorization-header', 'Invalid client_id:client_secret values; did you use the correct values for the integration?', (value) => {\n  if (!value) return true;\n  const [clientId, clientSecret] = decodeBasicAuthorizationHeader(value) ?? throwErr(`Authz header invalid? This should've been validated by basicAuthorizationHeaderSchema: ${value}`);\n  for (const neonClientConfig of JSON.parse(process.env.STACK_INTEGRATION_CLIENTS_CONFIG || '[]')) {\n    if (clientId === neonClientConfig.client_id && clientSecret === neonClientConfig.client_secret) return true;\n  }\n  return false;\n});\n\n// Utils\nexport function yupDefinedWhen<S extends yup.AnyObject>(\n  schema: S,\n  triggers: Record<string, any>,\n): S {\n  const entries = Object.entries(triggers);\n  return schema.when(entries.map(([key]) => key), {\n    is: (...values: any[]) => entries.every(([key, value], index) => value === values[index]),\n    then: (schema: S) => schema.defined(),\n    otherwise: (schema: S) => schema.optional()\n  });\n}\n\nexport function yupDefinedAndNonEmptyWhen<S extends yup.StringSchema>(\n  schema: S,\n  triggers: Record<string, any>,\n): S {\n  const entries = Object.entries(triggers);\n  return schema.when(entries.map(([key]) => key), {\n    is: (...values: any[]) => entries.every(([key, value], index) => value === values[index]),\n    then: (schema: S) => schema.defined().nonEmpty(),\n    otherwise: (schema: S) => schema.optional()\n  });\n}\n"],"names":["object","schema"],"mappings":"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"}},
    {"offset": {"line": 5180, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack-shared/src/utils/locks.tsx"],"sourcesContent":["import { Semaphore } from 'async-mutex';\n\ntype LockCallback<T> = () => Promise<T>;\n\nexport class ReadWriteLock {\n  private semaphore: Semaphore;\n  private readers: number;\n  private readersMutex: Semaphore;\n\n  constructor() {\n    this.semaphore = new Semaphore(1); // Semaphore with 1 permit\n    this.readers = 0; // Track the number of readers\n    this.readersMutex = new Semaphore(1); // Protect access to `readers` count\n  }\n\n  async withReadLock<T>(callback: LockCallback<T>): Promise<T> {\n    await this._acquireReadLock();\n    try {\n      return await callback();\n    } finally {\n      await this._releaseReadLock();\n    }\n  }\n\n  async withWriteLock<T>(callback: LockCallback<T>): Promise<T> {\n    await this._acquireWriteLock();\n    try {\n      return await callback();\n    } finally {\n      await this._releaseWriteLock();\n    }\n  }\n\n  private async _acquireReadLock(): Promise<void> {\n    // Increment the readers count\n    await this.readersMutex.acquire();\n    try {\n      this.readers += 1;\n      // If this is the first reader, block writers\n      if (this.readers === 1) {\n        await this.semaphore.acquire();\n      }\n    } finally {\n      this.readersMutex.release();\n    }\n  }\n\n  private async _releaseReadLock(): Promise<void> {\n    // Decrement the readers count\n    await this.readersMutex.acquire();\n    try {\n      this.readers -= 1;\n      // If this was the last reader, release the writer block\n      if (this.readers === 0) {\n        this.semaphore.release();\n      }\n    } finally {\n      this.readersMutex.release();\n    }\n  }\n\n  private async _acquireWriteLock(): Promise<void> {\n    // Writers acquire the main semaphore exclusively\n    await this.semaphore.acquire();\n  }\n\n  private async _releaseWriteLock(): Promise<void> {\n    // Writers release the main semaphore\n    this.semaphore.release();\n  }\n}\n"],"names":[],"mappings":";;;;;AAAA,SAAS,iBAAiB;;AAInB,IAAM,gBAAN,MAAoB;IAKzB,aAAc;QACZ,IAAA,CAAK,SAAA,GAAY,IAAI,4LAAA,CAAU,CAAC;QAChC,IAAA,CAAK,OAAA,GAAU;QACf,IAAA,CAAK,YAAA,GAAe,IAAI,4LAAA,CAAU,CAAC;IACrC;IAEA,MAAM,aAAgB,QAAA,EAAuC;QAC3D,MAAM,IAAA,CAAK,gBAAA,CAAiB;QAC5B,IAAI;YACF,OAAO,MAAM,SAAS;QACxB,SAAE;YACA,MAAM,IAAA,CAAK,gBAAA,CAAiB;QAC9B;IACF;IAEA,MAAM,cAAiB,QAAA,EAAuC;QAC5D,MAAM,IAAA,CAAK,iBAAA,CAAkB;QAC7B,IAAI;YACF,OAAO,MAAM,SAAS;QACxB,SAAE;YACA,MAAM,IAAA,CAAK,iBAAA,CAAkB;QAC/B;IACF;IAEA,MAAc,mBAAkC;QAE9C,MAAM,IAAA,CAAK,YAAA,CAAa,OAAA,CAAQ;QAChC,IAAI;YACF,IAAA,CAAK,OAAA,IAAW;YAEhB,IAAI,IAAA,CAAK,OAAA,KAAY,GAAG;gBACtB,MAAM,IAAA,CAAK,SAAA,CAAU,OAAA,CAAQ;YAC/B;QACF,SAAE;YACA,IAAA,CAAK,YAAA,CAAa,OAAA,CAAQ;QAC5B;IACF;IAEA,MAAc,mBAAkC;QAE9C,MAAM,IAAA,CAAK,YAAA,CAAa,OAAA,CAAQ;QAChC,IAAI;YACF,IAAA,CAAK,OAAA,IAAW;YAEhB,IAAI,IAAA,CAAK,OAAA,KAAY,GAAG;gBACtB,IAAA,CAAK,SAAA,CAAU,OAAA,CAAQ;YACzB;QACF,SAAE;YACA,IAAA,CAAK,YAAA,CAAa,OAAA,CAAQ;QAC5B;IACF;IAEA,MAAc,oBAAmC;QAE/C,MAAM,IAAA,CAAK,SAAA,CAAU,OAAA,CAAQ;IAC/B;IAEA,MAAc,oBAAmC;QAE/C,IAAA,CAAK,SAAA,CAAU,OAAA,CAAQ;IACzB;AACF"}},
    {"offset": {"line": 5244, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack-shared/src/utils/stores.tsx"],"sourcesContent":["import { ReadWriteLock } from \"./locks\";\nimport { ReactPromise, pending, rejected, resolved } from \"./promises\";\nimport { AsyncResult, Result } from \"./results\";\nimport { generateUuid } from \"./uuids\";\n\nexport type ReadonlyStore<T> = {\n  get(): T,\n  onChange(callback: (value: T, oldValue: T | undefined) => void): { unsubscribe: () => void },\n  onceChange(callback: (value: T, oldValue: T | undefined) => void): { unsubscribe: () => void },\n};\n\nexport type AsyncStoreStateChangeCallback<T> = (args: { state: AsyncResult<T>, oldState: AsyncResult<T>, lastOkValue: T | undefined }) => void;\n\nexport type ReadonlyAsyncStore<T> = {\n  isAvailable(): boolean,\n  get(): AsyncResult<T, unknown, void>,\n  getOrWait(): ReactPromise<T>,\n  onChange(callback: (value: T, oldValue: T | undefined) => void): { unsubscribe: () => void },\n  onceChange(callback: (value: T, oldValue: T | undefined) => void): { unsubscribe: () => void },\n  onStateChange(callback: AsyncStoreStateChangeCallback<T>): { unsubscribe: () => void },\n  onceStateChange(callback: AsyncStoreStateChangeCallback<T>): { unsubscribe: () => void },\n};\n\nexport class Store<T> implements ReadonlyStore<T> {\n  private readonly _callbacks: Map<string, ((value: T, oldValue: T | undefined) => void)> = new Map();\n\n  constructor(\n    private _value: T\n  ) {}\n\n  get(): T {\n    return this._value;\n  }\n\n  set(value: T): void {\n    const oldValue = this._value;\n    this._value = value;\n    this._callbacks.forEach((callback) => callback(value, oldValue));\n  }\n\n  update(updater: (value: T) => T): T {\n    const value = updater(this._value);\n    this.set(value);\n    return value;\n  }\n\n  onChange(callback: (value: T, oldValue: T | undefined) => void): { unsubscribe: () => void } {\n    const uuid = generateUuid();\n    this._callbacks.set(uuid, callback);\n    return {\n      unsubscribe: () => {\n        this._callbacks.delete(uuid);\n      },\n    };\n  }\n\n  onceChange(callback: (value: T, oldValue: T | undefined) => void): { unsubscribe: () => void } {\n    const { unsubscribe } = this.onChange((...args) => {\n      unsubscribe();\n      callback(...args);\n    });\n    return { unsubscribe };\n  }\n}\n\nexport const storeLock = new ReadWriteLock();\n\n\nexport class AsyncStore<T> implements ReadonlyAsyncStore<T> {\n  private _isAvailable: boolean;\n  private _mostRecentOkValue: T | undefined = undefined;\n\n  private _isRejected = false;\n  private _rejectionError: unknown;\n  private readonly _waitingRejectFunctions = new Map<string, ((error: unknown) => void)>();\n\n  private readonly _callbacks: Map<string, AsyncStoreStateChangeCallback<T>> = new Map();\n\n  private _updateCounter = 0;\n  private _lastSuccessfulUpdate = -1;\n\n  constructor(...args: [] | [T]) {\n    if (args.length === 0) {\n      this._isAvailable = false;\n    } else {\n      this._isAvailable = true;\n      this._mostRecentOkValue = args[0];\n    }\n  }\n\n  isAvailable(): boolean {\n    return this._isAvailable;\n  }\n\n  isRejected(): boolean {\n    return this._isRejected;\n  }\n\n  get() {\n    if (this.isRejected()) {\n      return AsyncResult.error(this._rejectionError);\n    } else if (this.isAvailable()) {\n      return AsyncResult.ok(this._mostRecentOkValue as T);\n    } else {\n      return AsyncResult.pending();\n    }\n  }\n\n  getOrWait(): ReactPromise<T> {\n    const uuid = generateUuid();\n    if (this.isRejected()) {\n      return rejected(this._rejectionError);\n    } else if (this.isAvailable()) {\n      return resolved(this._mostRecentOkValue as T);\n    }\n    const promise = new Promise<T>((resolve, reject) => {\n      this.onceChange((value) => {\n        resolve(value);\n      });\n      this._waitingRejectFunctions.set(uuid, reject);\n    });\n    const withFinally = promise.finally(() => {\n      this._waitingRejectFunctions.delete(uuid);\n    });\n    return pending(withFinally);\n  }\n\n  _setIfLatest(result: Result<T>, curCounter: number) {\n    const oldState = this.get();\n    const oldValue = this._mostRecentOkValue;\n    if (curCounter > this._lastSuccessfulUpdate) {\n      switch (result.status) {\n        case \"ok\": {\n          if (!this._isAvailable || this._isRejected || this._mostRecentOkValue !== result.data) {\n            this._lastSuccessfulUpdate = curCounter;\n            this._isAvailable = true;\n            this._isRejected = false;\n            this._mostRecentOkValue = result.data;\n            this._rejectionError = undefined;\n            this._callbacks.forEach((callback) => callback({\n              state: this.get(),\n              oldState,\n              lastOkValue: oldValue,\n            }));\n            return true;\n          }\n          return false;\n        }\n        case \"error\": {\n          this._lastSuccessfulUpdate = curCounter;\n          this._isAvailable = false;\n          this._isRejected = true;\n          this._rejectionError = result.error;\n          this._waitingRejectFunctions.forEach((reject) => reject(result.error));\n          this._callbacks.forEach((callback) => callback({\n            state: this.get(),\n            oldState,\n            lastOkValue: oldValue,\n          }));\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  set(value: T): void {\n    this._setIfLatest(Result.ok(value), ++this._updateCounter);\n  }\n\n  update(updater: (value: T | undefined) => T): T {\n    const value = updater(this._mostRecentOkValue);\n    this.set(value);\n    return value;\n  }\n\n  async setAsync(promise: Promise<T>): Promise<boolean> {\n    return await storeLock.withReadLock(async () => {\n      const curCounter = ++this._updateCounter;\n      const result = await Result.fromPromise(promise);\n      return this._setIfLatest(result, curCounter);\n    });\n  }\n\n  setUnavailable(): void {\n    this._lastSuccessfulUpdate = ++this._updateCounter;\n    this._mostRecentOkValue = undefined;\n    this._isAvailable = false;\n    this._isRejected = false;\n    this._rejectionError = undefined;\n  }\n\n  setRejected(error: unknown): void {\n    this._setIfLatest(Result.error(error), ++this._updateCounter);\n  }\n\n  map<U>(mapper: (value: T) => U): AsyncStore<U> {\n    const store = new AsyncStore<U>();\n    this.onChange((value) => {\n      store.set(mapper(value));\n    });\n    return store;\n  }\n\n  onChange(callback: (value: T, oldValue: T | undefined) => void): { unsubscribe: () => void } {\n    return this.onStateChange(({ state, lastOkValue }) => {\n      if (state.status === \"ok\") {\n        callback(state.data, lastOkValue);\n      }\n    });\n  }\n\n  onStateChange(callback: AsyncStoreStateChangeCallback<T>): { unsubscribe: () => void } {\n    const uuid = generateUuid();\n    this._callbacks.set(uuid, callback);\n    return {\n      unsubscribe: () => {\n        this._callbacks.delete(uuid);\n      },\n    };\n  }\n\n  onceChange(callback: (value: T, oldValue: T | undefined) => void): { unsubscribe: () => void } {\n    const { unsubscribe } = this.onChange((...args) => {\n      unsubscribe();\n      callback(...args);\n    });\n    return { unsubscribe };\n  }\n\n  onceStateChange(callback: AsyncStoreStateChangeCallback<T>): { unsubscribe: () => void } {\n    const { unsubscribe } = this.onStateChange((...args) => {\n      unsubscribe();\n      callback(...args);\n    });\n    return { unsubscribe };\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5460, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack-shared/src/sessions.ts"],"sourcesContent":["import * as jose from 'jose';\nimport { InferType } from 'yup';\nimport { accessTokenPayloadSchema } from './schema-fields';\nimport { StackAssertionError, throwErr } from \"./utils/errors\";\nimport { Store } from \"./utils/stores\";\n\n\nexport type AccessTokenPayload = InferType<typeof accessTokenPayloadSchema>;\n\nfunction decodeAccessTokenIfValid(token: string): AccessTokenPayload | null {\n  try {\n    const payload = jose.decodeJwt(token);\n    return accessTokenPayloadSchema.validateSync(payload);\n  } catch (e) {\n    return null;\n  }\n}\n\nexport class AccessToken {\n  static createIfValid(token: string): AccessToken | null {\n    const payload = decodeAccessTokenIfValid(token);\n    if (!payload) return null;\n    return new AccessToken(token);\n  }\n\n  private constructor(\n    public readonly token: string,\n  ) {\n    if (token === \"undefined\") {\n      throw new StackAssertionError(\"Access token is the string 'undefined'; it's unlikely this is the correct value. They're supposed to be unguessable!\");\n    }\n  }\n\n  get payload() {\n    return decodeAccessTokenIfValid(this.token) ?? throwErr(\"Invalid access token in payload (should've been validated in createIfValid)\", { token: this.token });\n  }\n\n  get expiresAt(): Date {\n    const { exp } = this.payload;\n    if (exp === undefined) return new Date(8640000000000000);  // max date value\n    return new Date(exp * 1000);\n  }\n\n  /**\n   * @returns The number of milliseconds until the access token expires, or 0 if it has already expired.\n   */\n  get expiresInMillis(): number {\n    return Math.max(0, this.expiresAt.getTime() - Date.now());\n  }\n\n  isExpired(): boolean {\n    return this.expiresInMillis <= 0;\n  }\n}\n\nexport class RefreshToken {\n  constructor(\n    public readonly token: string,\n  ) {\n    if (token === \"undefined\") {\n      throw new StackAssertionError(\"Refresh token is the string 'undefined'; it's unlikely this is the correct value. They're supposed to be unguessable!\");\n    }\n  }\n}\n\n/**\n * An InternalSession represents a user's session, which may or may not be valid. It may contain an access token, a refresh token, or both.\n *\n * A session never changes which user or session it belongs to, but the tokens in it may change over time.\n */\nexport class InternalSession {\n  /**\n  * Each session has a session key that depends on the tokens inside. If the session has a refresh token, the session key depends only on the refresh token. If the session does not have a refresh token, the session key depends only on the access token.\n  *\n  * Multiple Session objects may have the same session key, which implies that they represent the same session by the same user. Furthermore, a session's key never changes over the lifetime of a session object.\n  *\n  * This is useful for caching and indexing sessions.\n  */\n  public readonly sessionKey: string;\n\n  /**\n   * An access token that is not known to be invalid (ie. may be valid, but may have expired).\n   */\n  private _accessToken: Store<AccessToken | null>;\n  private readonly _refreshToken: RefreshToken | null;\n\n  /**\n   * Whether the session as a whole is known to be invalid (ie. both access and refresh tokens are invalid). Used as a cache to avoid making multiple requests to the server (sessions never go back to being valid after being invalidated).\n   *\n   * It is possible for the access token to be invalid but the refresh token to be valid, in which case the session is\n   * still valid (just needs a refresh). It is also possible for the access token to be valid but the refresh token to\n   * be invalid, in which case the session is also valid (eg. if the refresh token is null because the user only passed\n   * in an access token, eg. in a server-side request handler).\n   */\n  private _knownToBeInvalid = new Store<boolean>(false);\n\n  private _refreshPromise: Promise<AccessToken | null> | null = null;\n\n  constructor(private readonly _options: {\n    refreshAccessTokenCallback(refreshToken: RefreshToken): Promise<AccessToken | null>,\n    refreshToken: string | null,\n    accessToken?: string | null,\n  }) {\n    this._accessToken = new Store(_options.accessToken ? AccessToken.createIfValid(_options.accessToken) : null);\n    this._refreshToken = _options.refreshToken ? new RefreshToken(_options.refreshToken) : null;\n    if (_options.accessToken === null && _options.refreshToken === null) {\n      // this session is already invalid\n      this._knownToBeInvalid.set(true);\n    }\n    this.sessionKey = InternalSession.calculateSessionKey({ accessToken: _options.accessToken ?? null, refreshToken: _options.refreshToken });\n  }\n\n  static calculateSessionKey(ofTokens: { refreshToken: string | null, accessToken?: string | null }): string {\n    if (ofTokens.refreshToken) {\n      return `refresh-${ofTokens.refreshToken}`;\n    } else if (ofTokens.accessToken) {\n      return `access-${ofTokens.accessToken}`;\n    } else {\n      return \"not-logged-in\";\n    }\n  }\n\n  isKnownToBeInvalid() {\n    return this._knownToBeInvalid.get();\n  }\n\n  /**\n   * Marks the session object as invalid, meaning that the refresh and access tokens can no longer be used.\n   */\n  markInvalid() {\n    this._accessToken.set(null);\n    this._knownToBeInvalid.set(true);\n  }\n\n  onInvalidate(callback: () => void): { unsubscribe: () => void } {\n    return this._knownToBeInvalid.onChange(() => callback());\n  }\n\n  /**\n   * Returns the access token if it is found in the cache and not expired yet, or null otherwise. Never fetches new tokens.\n   */\n  getAccessTokenIfNotExpiredYet(minMillisUntilExpiration: number): AccessToken | null {\n    if (minMillisUntilExpiration > 60_000) {\n      throw new Error(`Required access token expiry ${minMillisUntilExpiration}ms is too long; access tokens are too short to be used for more than 60s`);\n    }\n\n    const accessToken = this._getPotentiallyInvalidAccessTokenIfAvailable();\n    if (!accessToken || accessToken.expiresInMillis < minMillisUntilExpiration) return null;\n    return accessToken;\n  }\n\n  /**\n   * Returns the access token if it is found in the cache, fetching it otherwise.\n   *\n   * This is usually the function you want to call to get an access token. Either set `minMillisUntilExpiration` to a reasonable value, or catch errors that occur if it expires, and call `markAccessTokenExpired` to mark the token as expired if so (after which a call to this function will always refetch the token).\n   *\n   * @returns null if the session is known to be invalid, cached tokens if they exist in the cache and the access token hasn't expired yet (the refresh token might still be invalid), or new tokens otherwise.\n   */\n  async getOrFetchLikelyValidTokens(minMillisUntilExpiration: number): Promise<{ accessToken: AccessToken, refreshToken: RefreshToken | null } | null> {\n    const accessToken = this.getAccessTokenIfNotExpiredYet(minMillisUntilExpiration);\n    if (!accessToken) {\n      const newTokens = await this.fetchNewTokens();\n      const expiresInMillis = newTokens?.accessToken.expiresInMillis;\n      if (expiresInMillis && expiresInMillis < minMillisUntilExpiration) {\n        throw new StackAssertionError(`Required access token expiry ${minMillisUntilExpiration}ms is too long; access tokens are too short when they're generated (${expiresInMillis}ms)`);\n      }\n      return newTokens;\n    }\n    return { accessToken, refreshToken: this._refreshToken };\n  }\n\n  /**\n   * Fetches new tokens that are, at the time of fetching, guaranteed to be valid.\n   *\n   * The newly generated tokens are short-lived, so it's good practice not to rely on their validity (if possible). However, this function is useful in some cases where you only want to pass access tokens to a service, and you want to make sure said access token has the longest possible lifetime.\n   *\n   * In most cases, you should prefer `getOrFetchLikelyValidTokens`.\n   *\n   * @returns null if the session is known to be invalid, or new tokens otherwise (which, at the time of fetching, are guaranteed to be valid).\n   */\n  async fetchNewTokens(): Promise<{ accessToken: AccessToken, refreshToken: RefreshToken | null } | null> {\n    const accessToken = await this._getNewlyFetchedAccessToken();\n    return accessToken ? { accessToken, refreshToken: this._refreshToken } : null;\n  }\n\n  markAccessTokenExpired(accessToken: AccessToken) {\n    // TODO we don't need this anymore, since we now check the expiry by ourselves\n    if (this._accessToken.get() === accessToken) {\n      this._accessToken.set(null);\n    }\n  }\n\n  /**\n   * Note that a callback invocation with `null` does not mean the session has been invalidated; the access token may just have expired. Use `onInvalidate` to detect invalidation.\n   */\n  onAccessTokenChange(callback: (newAccessToken: AccessToken | null) => void): { unsubscribe: () => void } {\n    return this._accessToken.onChange(callback);\n  }\n\n  /**\n   * @returns An access token, which may be expired or expire soon, or null if it is known to be invalid.\n   */\n  private _getPotentiallyInvalidAccessTokenIfAvailable(): AccessToken | null {\n    if (!this._refreshToken) return null;\n    if (this.isKnownToBeInvalid()) return null;\n\n    const accessToken = this._accessToken.get();\n    if (accessToken && !accessToken.isExpired()) return accessToken;\n\n    return null;\n  }\n\n  /**\n   * You should prefer `_getOrFetchPotentiallyInvalidAccessToken` in almost all cases.\n   *\n   * @returns A newly fetched access token (never read from cache), or null if the session either does not represent a user or the session is invalid.\n   */\n  private async _getNewlyFetchedAccessToken(): Promise<AccessToken | null> {\n    if (!this._refreshToken) return null;\n    if (this._knownToBeInvalid.get()) return null;\n\n    if (!this._refreshPromise) {\n      this._refreshAndSetRefreshPromise(this._refreshToken);\n    }\n    return await this._refreshPromise;\n  }\n\n  private _refreshAndSetRefreshPromise(refreshToken: RefreshToken) {\n    let refreshPromise: Promise<AccessToken | null> = this._options.refreshAccessTokenCallback(refreshToken).then((accessToken) => {\n      if (refreshPromise === this._refreshPromise) {\n        this._refreshPromise = null;\n        this._accessToken.set(accessToken);\n        if (!accessToken) {\n          this.markInvalid();\n        }\n      }\n      return accessToken;\n    });\n    this._refreshPromise = refreshPromise;\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;AAAA,YAAY,UAAU;AAEtB,SAAS,gCAAgC;AACzC,SAAS,qBAAqB,gBAAgB;AAC9C,SAAS,aAAa;;;;;AAKtB,SAAS,yBAAyB,KAAA,EAA0C;IAC1E,IAAI;QACF,MAAM,UAAe,iNAAA,CAAU,KAAK;QACpC,OAAO,qPAAA,CAAyB,YAAA,CAAa,OAAO;IACtD,EAAA,OAAS,GAAG;QACV,OAAO;IACT;AACF;AAEO,IAAM,cAAN,MAAM,aAAY;IAOf,YACU,KAAA,CAChB;QADgB,IAAA,CAAA,KAAA,GAAA;QAEhB,IAAI,UAAU,aAAa;YACzB,MAAM,IAAI,+OAAA,CAAoB,sHAAsH;QACtJ;IACF;IAZA,OAAO,cAAc,KAAA,EAAmC;QACtD,MAAM,UAAU,yBAAyB,KAAK;QAC9C,IAAI,CAAC,QAAS,CAAA,OAAO;QACrB,OAAO,IAAI,aAAY,KAAK;IAC9B;IAUA,IAAI,UAAU;QACZ,OAAO,yBAAyB,IAAA,CAAK,KAAK,SAAK,oOAAA,EAAS,+EAA+E;YAAE,OAAO,IAAA,CAAK,KAAA;QAAM,CAAC;IAC9J;IAEA,IAAI,YAAkB;QACpB,MAAM,EAAE,GAAA,CAAI,CAAA,GAAI,IAAA,CAAK,OAAA;QACrB,IAAI,QAAQ,KAAA,EAAW,CAAA,OAAO,aAAA,GAAA,IAAI,KAAK,MAAgB;QACvD,OAAO,IAAI,KAAK,MAAM,GAAI;IAC5B;IAAA;;GAAA,GAKA,IAAI,kBAA0B;QAC5B,OAAO,KAAK,GAAA,CAAI,GAAG,IAAA,CAAK,SAAA,CAAU,OAAA,CAAQ,IAAI,KAAK,GAAA,CAAI,CAAC;IAC1D;IAEA,YAAqB;QACnB,OAAO,IAAA,CAAK,eAAA,IAAmB;IACjC;AACF;AAEO,IAAM,eAAN,MAAmB;IACxB,YACkB,KAAA,CAChB;QADgB,IAAA,CAAA,KAAA,GAAA;QAEhB,IAAI,UAAU,aAAa;YACzB,MAAM,IAAI,+OAAA,CAAoB,uHAAuH;QACvJ;IACF;AACF;AAOO,IAAM,kBAAN,MAAM,iBAAgB;IA4B3B,YAA6B,QAAA,CAI1B;QAJ0B,IAAA,CAAA,QAAA,GAAA;QAJ7B;;;;;;;KAAA,GAAA,IAAA,CAAQ,iBAAA,GAAoB,IAAI,iOAAA,CAAe,KAAK;QAEpD,IAAA,CAAQ,eAAA,GAAsD;QAO5D,IAAA,CAAK,YAAA,GAAe,IAAI,iOAAA,CAAM,SAAS,WAAA,GAAc,YAAY,aAAA,CAAc,SAAS,WAAW,IAAI,IAAI;QAC3G,IAAA,CAAK,aAAA,GAAgB,SAAS,YAAA,GAAe,IAAI,aAAa,SAAS,YAAY,IAAI;QACvF,IAAI,SAAS,WAAA,KAAgB,QAAQ,SAAS,YAAA,KAAiB,MAAM;YAEnE,IAAA,CAAK,iBAAA,CAAkB,GAAA,CAAI,IAAI;QACjC;QACA,IAAA,CAAK,UAAA,GAAa,iBAAgB,mBAAA,CAAoB;YAAE,aAAa,SAAS,WAAA,IAAe;YAAM,cAAc,SAAS,YAAA;QAAa,CAAC;IAC1I;IAEA,OAAO,oBAAoB,QAAA,EAAgF;QACzG,IAAI,SAAS,YAAA,EAAc;YACzB,OAAO,CAAA,QAAA,EAAW,SAAS,YAAY,EAAA;QACzC,OAAA,IAAW,SAAS,WAAA,EAAa;YAC/B,OAAO,CAAA,OAAA,EAAU,SAAS,WAAW,EAAA;QACvC,OAAO;YACL,OAAO;QACT;IACF;IAEA,qBAAqB;QACnB,OAAO,IAAA,CAAK,iBAAA,CAAkB,GAAA,CAAI;IACpC;IAAA;;GAAA,GAKA,cAAc;QACZ,IAAA,CAAK,YAAA,CAAa,GAAA,CAAI,IAAI;QAC1B,IAAA,CAAK,iBAAA,CAAkB,GAAA,CAAI,IAAI;IACjC;IAEA,aAAa,QAAA,EAAmD;QAC9D,OAAO,IAAA,CAAK,iBAAA,CAAkB,QAAA,CAAS,IAAM,SAAS,CAAC;IACzD;IAAA;;GAAA,GAKA,8BAA8B,wBAAA,EAAsD;QAClF,IAAI,2BAA2B,KAAQ;YACrC,MAAM,IAAI,MAAM,CAAA,6BAAA,EAAgC,wBAAwB,CAAA,wEAAA,CAA0E;QACpJ;QAEA,MAAM,cAAc,IAAA,CAAK,4CAAA,CAA6C;QACtE,IAAI,CAAC,eAAe,YAAY,eAAA,GAAkB,yBAA0B,CAAA,OAAO;QACnF,OAAO;IACT;IAAA;;;;;;GAAA,GASA,MAAM,4BAA4B,wBAAA,EAAmH;QACnJ,MAAM,cAAc,IAAA,CAAK,6BAAA,CAA8B,wBAAwB;QAC/E,IAAI,CAAC,aAAa;YAChB,MAAM,YAAY,MAAM,IAAA,CAAK,cAAA,CAAe;YAC5C,MAAM,kBAAkB,WAAW,YAAY;YAC/C,IAAI,mBAAmB,kBAAkB,0BAA0B;gBACjE,MAAM,IAAI,+OAAA,CAAoB,CAAA,6BAAA,EAAgC,wBAAwB,CAAA,oEAAA,EAAuE,eAAe,CAAA,GAAA,CAAK;YACnL;YACA,OAAO;QACT;QACA,OAAO;YAAE;YAAa,cAAc,IAAA,CAAK,aAAA;QAAc;IACzD;IAAA;;;;;;;;GAAA,GAWA,MAAM,iBAAkG;QACtG,MAAM,cAAc,MAAM,IAAA,CAAK,2BAAA,CAA4B;QAC3D,OAAO,cAAc;YAAE;YAAa,cAAc,IAAA,CAAK,aAAA;QAAc,IAAI;IAC3E;IAEA,uBAAuB,WAAA,EAA0B;QAE/C,IAAI,IAAA,CAAK,YAAA,CAAa,GAAA,CAAI,MAAM,aAAa;YAC3C,IAAA,CAAK,YAAA,CAAa,GAAA,CAAI,IAAI;QAC5B;IACF;IAAA;;GAAA,GAKA,oBAAoB,QAAA,EAAqF;QACvG,OAAO,IAAA,CAAK,YAAA,CAAa,QAAA,CAAS,QAAQ;IAC5C;IAAA;;GAAA,GAKQ,+CAAmE;QACzE,IAAI,CAAC,IAAA,CAAK,aAAA,CAAe,CAAA,OAAO;QAChC,IAAI,IAAA,CAAK,kBAAA,CAAmB,EAAG,CAAA,OAAO;QAEtC,MAAM,cAAc,IAAA,CAAK,YAAA,CAAa,GAAA,CAAI;QAC1C,IAAI,eAAe,CAAC,YAAY,SAAA,CAAU,EAAG,CAAA,OAAO;QAEpD,OAAO;IACT;IAAA;;;;GAAA,GAOA,MAAc,8BAA2D;QACvE,IAAI,CAAC,IAAA,CAAK,aAAA,CAAe,CAAA,OAAO;QAChC,IAAI,IAAA,CAAK,iBAAA,CAAkB,GAAA,CAAI,EAAG,CAAA,OAAO;QAEzC,IAAI,CAAC,IAAA,CAAK,eAAA,EAAiB;YACzB,IAAA,CAAK,4BAAA,CAA6B,IAAA,CAAK,aAAa;QACtD;QACA,OAAO,MAAM,IAAA,CAAK,eAAA;IACpB;IAEQ,6BAA6B,YAAA,EAA4B;QAC/D,IAAI,iBAA8C,IAAA,CAAK,QAAA,CAAS,0BAAA,CAA2B,YAAY,EAAE,IAAA,CAAK,CAAC,gBAAgB;YAC7H,IAAI,mBAAmB,IAAA,CAAK,eAAA,EAAiB;gBAC3C,IAAA,CAAK,eAAA,GAAkB;gBACvB,IAAA,CAAK,YAAA,CAAa,GAAA,CAAI,WAAW;gBACjC,IAAI,CAAC,aAAa;oBAChB,IAAA,CAAK,WAAA,CAAY;gBACnB;YACF;YACA,OAAO;QACT,CAAC;QACD,IAAA,CAAK,eAAA,GAAkB;IACzB;AACF"}},
    {"offset": {"line": 5664, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack-shared/src/interface/client-interface.ts"],"sourcesContent":["import * as oauth from 'oauth4webapi';\n\nimport * as yup from 'yup';\nimport { KnownError, KnownErrors } from '../known-errors';\nimport { inlineProductSchema } from '../schema-fields';\nimport { AccessToken, InternalSession, RefreshToken } from '../sessions';\nimport { generateSecureRandomString } from '../utils/crypto';\nimport { StackAssertionError, throwErr } from '../utils/errors';\nimport { globalVar } from '../utils/globals';\nimport { HTTP_METHODS, HttpMethod } from '../utils/http';\nimport { ReadonlyJson } from '../utils/json';\nimport { filterUndefined, filterUndefinedOrNull } from '../utils/objects';\nimport { AuthenticationResponseJSON, PublicKeyCredentialCreationOptionsJSON, PublicKeyCredentialRequestOptionsJSON, RegistrationResponseJSON } from '../utils/passkey';\nimport { wait } from '../utils/promises';\nimport { Result } from \"../utils/results\";\nimport { deindent } from '../utils/strings';\nimport { urlString } from '../utils/urls';\nimport { ConnectedAccountAccessTokenCrud } from './crud/connected-accounts';\nimport { ContactChannelsCrud } from './crud/contact-channels';\nimport { CurrentUserCrud } from './crud/current-user';\nimport { ItemCrud } from './crud/items';\nimport { NotificationPreferenceCrud } from './crud/notification-preferences';\nimport { OAuthProviderCrud } from './crud/oauth-providers';\nimport { CustomerProductsListResponse, ListCustomerProductsOptions } from './crud/products';\nimport { TeamApiKeysCrud, UserApiKeysCrud, teamApiKeysCreateInputSchema, teamApiKeysCreateOutputSchema, userApiKeysCreateInputSchema, userApiKeysCreateOutputSchema } from './crud/project-api-keys';\nimport { ProjectPermissionsCrud } from './crud/project-permissions';\nimport { AdminUserProjectsCrud, ClientProjectsCrud } from './crud/projects';\nimport { SessionsCrud } from './crud/sessions';\nimport { TeamInvitationCrud } from './crud/team-invitation';\nimport { TeamMemberProfilesCrud } from './crud/team-member-profiles';\nimport { TeamPermissionsCrud } from './crud/team-permissions';\nimport { TeamsCrud } from './crud/teams';\n\nexport type ClientInterfaceOptions = {\n  clientVersion: string,\n  // This is a function instead of a string because it might be different based on the environment (for example client vs server)\n  getBaseUrl: () => string,\n  extraRequestHeaders: Record<string, string>,\n  projectId: string,\n  prepareRequest?: () => Promise<void>,\n} & ({\n  publishableClientKey: string,\n} | {\n  projectOwnerSession: InternalSession,\n});\n\nexport class StackClientInterface {\n  private pendingNetworkDiagnostics?: ReturnType<StackClientInterface[\"_runNetworkDiagnosticsInner\"]>;\n\n  constructor(public readonly options: ClientInterfaceOptions) {\n    // nothing here\n  }\n\n  get projectId() {\n    return this.options.projectId;\n  }\n\n  getApiUrl() {\n    return this.options.getBaseUrl() + \"/api/v1\";\n  }\n\n  public async runNetworkDiagnostics(session?: InternalSession | null, requestType?: \"client\" | \"server\" | \"admin\") {\n    if (this.pendingNetworkDiagnostics) {\n      return await this.pendingNetworkDiagnostics;\n    }\n\n    this.pendingNetworkDiagnostics = this._runNetworkDiagnosticsInner(session, requestType);\n    try {\n      return await this.pendingNetworkDiagnostics;\n    } finally {\n      this.pendingNetworkDiagnostics = undefined;\n    }\n  }\n\n  private async _runNetworkDiagnosticsInner(session?: InternalSession | null, requestType?: \"client\" | \"server\" | \"admin\") {\n    const tryRequest = async (cb: () => Promise<void>) => {\n      try {\n        await cb();\n        return \"OK\";\n      } catch (e) {\n        return `${e}`;\n      }\n    };\n    const cfTrace = await tryRequest(async () => {\n      const res = await fetch(\"https://1.1.1.1/cdn-cgi/trace\");\n      if (!res.ok) {\n        throw new Error(`${res.status} ${res.statusText}: ${await res.text()}`);\n      }\n    });\n    const baseUrlBackend = await tryRequest(async () => {\n      const res = await fetch(new URL(\"/health\", this.getApiUrl()));\n      if (!res.ok) {\n        throw new Error(`${res.status} ${res.statusText}: ${await res.text()}`);\n      }\n    });\n    const prodDashboard = await tryRequest(async () => {\n      const res = await fetch(\"https://app.stack-auth.com/health\");\n      if (!res.ok) {\n        throw new Error(`${res.status} ${res.statusText}: ${await res.text()}`);\n      }\n    });\n    const prodBackend = await tryRequest(async () => {\n      const res = await fetch(\"https://api.stack-auth.com/health\");\n      if (!res.ok) {\n        throw new Error(`${res.status} ${res.statusText}: ${await res.text()}`);\n      }\n    });\n    return {\n      \"navigator?.onLine\": globalVar.navigator?.onLine,\n      cfTrace,\n      baseUrlBackend,\n      prodDashboard,\n      prodBackend,\n    };\n  }\n\n  protected async _createNetworkError(cause: Error, session?: InternalSession | null, requestType?: \"client\" | \"server\" | \"admin\") {\n    return new Error(deindent`\n      Stack Auth is unable to connect to the server. Please check your internet connection and try again.\n\n      If the problem persists, please contact support and provide a screenshot of your entire browser console.\n\n      ${cause}\n\n      ${JSON.stringify(await this.runNetworkDiagnostics(session, requestType), null, 2)}\n    `, { cause: cause });\n  }\n\n  protected async _networkRetry<T>(cb: () => Promise<Result<T, any>>, session?: InternalSession | null, requestType?: \"client\" | \"server\" | \"admin\"): Promise<T> {\n    const retriedResult = await Result.retry(\n      cb,\n      5,\n      { exponentialDelayBase: 1000 },\n    );\n\n    // try to diagnose the error for the user\n    if (retriedResult.status === \"error\") {\n      if (globalVar.navigator && globalVar.navigator.onLine === false) {\n        throw new Error(\"You are offline. Please check your internet connection and try again. (window.navigator.onLine is false)\", { cause: retriedResult.error });\n      }\n      throw await this._createNetworkError(retriedResult.error, session, requestType);\n    }\n    return retriedResult.data;\n  }\n\n  protected async _networkRetryException<T>(cb: () => Promise<T>, session?: InternalSession | null, requestType?: \"client\" | \"server\" | \"admin\"): Promise<T> {\n    return await this._networkRetry(async () => await Result.fromThrowingAsync(cb), session, requestType);\n  }\n\n  public async fetchNewAccessToken(refreshToken: RefreshToken) {\n    if (!('publishableClientKey' in this.options)) {\n      // TODO support it\n      throw new Error(\"Admin session token is currently not supported for fetching new access token. Did you try to log in on a StackApp initiated with the admin session?\");\n    }\n\n    const as = {\n      issuer: this.options.getBaseUrl(),\n      algorithm: 'oauth2',\n      token_endpoint: this.getApiUrl() + '/auth/oauth/token',\n    };\n    const client: oauth.Client = {\n      client_id: this.projectId,\n      client_secret: this.options.publishableClientKey,\n      token_endpoint_auth_method: 'client_secret_post',\n    };\n\n    const response = await this._networkRetryException(async () => {\n      const rawResponse = await oauth.refreshTokenGrantRequest(\n        as,\n        client,\n        refreshToken.token,\n      );\n\n      const response = await this._processResponse(rawResponse);\n\n      if (response.status === \"error\") {\n        const error = response.error;\n        if (KnownErrors.RefreshTokenError.isInstance(error)) {\n          return null;\n        }\n        throw error;\n      }\n\n      if (!response.data.ok) {\n        const body = await response.data.text();\n        throw new Error(`Failed to send refresh token request: ${response.status} ${body}`);\n      }\n\n      return response.data;\n    });\n    if (!response) return null;\n\n    const result = await oauth.processRefreshTokenResponse(as, client, response);\n    if (oauth.isOAuth2Error(result)) {\n      // TODO Handle OAuth 2.0 response body error\n      throw new StackAssertionError(\"OAuth error\", { result });\n    }\n\n    if (!result.access_token) {\n      throw new StackAssertionError(\"Access token not found in token endpoint response, this is weird!\");\n    }\n\n    return AccessToken.createIfValid(result.access_token) ?? throwErr(\"Access token in fetchNewAccessToken is invalid, looks like the backend is returning an invalid token!\", { result });\n  }\n\n  public async sendClientRequest(\n    path: string,\n    requestOptions: RequestInit,\n    session: InternalSession | null,\n    requestType: \"client\" | \"server\" | \"admin\" = \"client\",\n  ) {\n    session ??= this.createSession({\n      refreshToken: null,\n    });\n\n\n    return await this._networkRetry(\n      () => this.sendClientRequestInner(path, requestOptions, session!, requestType),\n      session,\n      requestType,\n    );\n  }\n\n  public createSession(options: Omit<ConstructorParameters<typeof InternalSession>[0], \"refreshAccessTokenCallback\">): InternalSession {\n    const session = new InternalSession({\n      refreshAccessTokenCallback: async (refreshToken) => await this.fetchNewAccessToken(refreshToken),\n      ...options,\n    });\n    return session;\n  }\n\n  protected async sendClientRequestAndCatchKnownError<E extends typeof KnownErrors[keyof KnownErrors]>(\n    path: string,\n    requestOptions: RequestInit,\n    tokenStoreOrNull: InternalSession | null,\n    errorsToCatch: readonly E[],\n  ): Promise<Result<\n    Response & {\n      usedTokens: {\n        accessToken: AccessToken,\n        refreshToken: RefreshToken | null,\n      } | null,\n    },\n    InstanceType<E>\n  >> {\n    try {\n      return Result.ok(await this.sendClientRequest(path, requestOptions, tokenStoreOrNull));\n    } catch (e) {\n      for (const errorType of errorsToCatch) {\n        if (errorType.isInstance(e)) {\n          return Result.error(e as InstanceType<E>);\n        }\n      }\n      throw e;\n    }\n  }\n\n  private async sendClientRequestInner(\n    path: string,\n    options: RequestInit,\n    session: InternalSession,\n    requestType: \"client\" | \"server\" | \"admin\",\n  ): Promise<Result<Response & {\n    usedTokens: {\n      accessToken: AccessToken,\n      refreshToken: RefreshToken | null,\n    } | null,\n  }>> {\n    /**\n     * `tokenObj === null` means the session is invalid/not logged in\n     */\n    let tokenObj = await session.getOrFetchLikelyValidTokens(20_000);\n\n    let adminSession = \"projectOwnerSession\" in this.options ? this.options.projectOwnerSession : null;\n    let adminTokenObj = adminSession ? await adminSession.getOrFetchLikelyValidTokens(20_000) : null;\n\n    // all requests should be dynamic to prevent Next.js caching\n    await this.options.prepareRequest?.();\n\n    let url = this.getApiUrl() + path;\n    if (url.endsWith(\"/\")) {\n      url = url.slice(0, -1);\n    }\n    const params: RequestInit = {\n      /**\n       * This fetch may be cross-origin, in which case we don't want to send cookies of the\n       * original origin (this is the default behavior of `credentials`).\n       *\n       * To help debugging, also omit cookies on same-origin, so we don't accidentally\n       * implement reliance on cookies anywhere.\n       *\n       * However, Cloudflare Workers don't actually support `credentials`, so we only set it\n       * if Cloudflare-exclusive globals are not detected. https://github.com/cloudflare/workers-sdk/issues/2514\n       */\n      ...(\"WebSocketPair\" in globalVar ? {} : {\n        credentials: \"omit\",\n      }),\n      ...options,\n      headers: {\n        \"X-Stack-Override-Error-Status\": \"true\",\n        \"X-Stack-Project-Id\": this.projectId,\n        \"X-Stack-Access-Type\": requestType,\n        \"X-Stack-Client-Version\": this.options.clientVersion,\n        ...(tokenObj ? {\n          \"X-Stack-Access-Token\": tokenObj.accessToken.token,\n        } : {}),\n        ...(tokenObj?.refreshToken ? {\n          \"X-Stack-Refresh-Token\": tokenObj.refreshToken.token,\n        } : {}),\n        \"X-Stack-Allow-Anonymous-User\": \"true\",\n        ...('publishableClientKey' in this.options ? {\n          \"X-Stack-Publishable-Client-Key\": this.options.publishableClientKey,\n        } : {}),\n        ...(adminTokenObj ? {\n          \"X-Stack-Admin-Access-Token\": adminTokenObj.accessToken.token,\n        } : {}),\n        /**\n         * Next.js until v15 would cache fetch requests by default, and forcefully disabling it was nearly impossible.\n         *\n         * This header is used to change the cache key and hence always disable it, because we do our own caching.\n         *\n         * When we drop support for Next.js <15, we may be able to remove this header, but please make sure that this is\n         * the case (I haven't actually tested.)\n         */\n        \"X-Stack-Random-Nonce\": generateSecureRandomString(),\n        // don't show a warning when proxying the API through ngrok (only relevant if the API url is an ngrok site)\n        'ngrok-skip-browser-warning': 'true',\n        ...this.options.extraRequestHeaders,\n        ...options.headers,\n      },\n      /**\n       * Cloudflare Workers does not support cache, so don't pass it there\n       */\n      ...(\"WebSocketPair\" in globalVar ? {} : {\n        cache: \"no-store\",\n      }),\n    };\n\n    let rawRes;\n    try {\n      rawRes = await fetch(url, params);\n    } catch (e) {\n      if (e instanceof TypeError) {\n        // Likely to be a network error. Retry if the request is idempotent, throw network error otherwise.\n        if (HTTP_METHODS[(params.method ?? \"GET\") as HttpMethod].idempotent) {\n          return Result.error(e);\n        } else {\n          throw await this._createNetworkError(e, session, requestType);\n        }\n      }\n      throw e;\n    }\n\n    const processedRes = await this._processResponse(rawRes);\n    if (processedRes.status === \"error\") {\n      // If the access token is invalid, reset it and retry\n      if (KnownErrors.InvalidAccessToken.isInstance(processedRes.error)) {\n        if (!tokenObj) {\n          throw new StackAssertionError(\"Received invalid access token, but session is not logged in\", { tokenObj, processedRes });\n        }\n        session.markAccessTokenExpired(tokenObj.accessToken);\n        return Result.error(processedRes.error);\n      }\n\n      // Same for the admin access token\n      // TODO HACK: Some of the backend hasn't been ported to use the new error codes, so if we have project owner tokens we need to check for ApiKeyNotFound too. Once the migration to smartRouteHandlers is complete, we can check for InvalidAdminAccessToken only.\n      if (adminSession && (KnownErrors.InvalidAdminAccessToken.isInstance(processedRes.error) || KnownErrors.ApiKeyNotFound.isInstance(processedRes.error))) {\n        if (!adminTokenObj) {\n          throw new StackAssertionError(\"Received invalid admin access token, but admin session is not logged in\", { adminTokenObj, processedRes });\n        }\n        adminSession.markAccessTokenExpired(adminTokenObj.accessToken);\n        return Result.error(processedRes.error);\n      }\n\n      // Known errors are client side errors, so except for the ones above they should not be retried\n      // Hence, throw instead of returning an error\n      throw processedRes.error;\n    }\n\n\n    const res = Object.assign(processedRes.data, {\n      usedTokens: tokenObj,\n    });\n    if (res.ok) {\n      return Result.ok(res);\n    } else if (res.status === 429) {\n      // Rate limited, so retry if we can\n      const retryAfter = res.headers.get(\"Retry-After\");\n      if (retryAfter !== null) {\n        console.log(`Rate limited while sending request to ${url}. Will retry after ${retryAfter} seconds...`);\n        await wait(Number(retryAfter) * 1000);\n        return Result.error(new Error(`Rate limited, retrying after ${retryAfter} seconds`));\n      }\n      console.log(`Rate limited while sending request to ${url}, no retry-after header received. Retrying...`);\n      return Result.error(new Error(\"Rate limited, no retry-after header received\"));\n    } else {\n      const error = await res.text();\n\n      const errorObj = new StackAssertionError(`Failed to send request to ${url}: ${res.status} ${error}`, { request: params, res, path });\n\n      if (res.status === 508 && error.includes(\"INFINITE_LOOP_DETECTED\")) {\n        // Some Vercel deployments seem to have an odd infinite loop bug. In that case, retry.\n        // See: https://github.com/stack-auth/stack-auth/issues/319\n        return Result.error(errorObj);\n      }\n\n      // Do not retry, throw error instead of returning one\n      throw errorObj;\n    }\n  }\n\n  private async _processResponse(rawRes: Response): Promise<Result<Response, KnownError>> {\n    let res = rawRes;\n    if (rawRes.headers.has(\"x-stack-actual-status\")) {\n      const actualStatus = Number(rawRes.headers.get(\"x-stack-actual-status\"));\n      res = new Response(rawRes.body, {\n        status: actualStatus,\n        statusText: rawRes.statusText,\n        headers: rawRes.headers,\n      });\n    }\n\n    // Handle known errors\n    if (res.headers.has(\"x-stack-known-error\")) {\n      const errorJson = await res.json();\n      if (res.headers.get(\"x-stack-known-error\") !== errorJson.code) {\n        throw new StackAssertionError(\"Mismatch between x-stack-known-error header and error code in body; the server's response is invalid\");\n      }\n      const error = KnownError.fromJson(errorJson);\n      return Result.error(error);\n    }\n\n    return Result.ok(res);\n  }\n\n  public async checkFeatureSupport(options: { featureName?: string } & ReadonlyJson): Promise<never> {\n    const res = await this.sendClientRequest(\"/check-feature-support\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(options),\n    }, null);\n\n    throw new StackAssertionError(await res.text());\n  }\n\n  async sendForgotPasswordEmail(\n    email: string,\n    callbackUrl: string,\n  ): Promise<Result<undefined, KnownErrors[\"UserNotFound\"]>> {\n    const res = await this.sendClientRequestAndCatchKnownError(\n      \"/auth/password/send-reset-code\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          email,\n          callback_url: callbackUrl,\n        }),\n      },\n      null,\n      [KnownErrors.UserNotFound],\n    );\n\n    if (res.status === \"error\") {\n      return Result.error(res.error);\n    } else {\n      return Result.ok(undefined);\n    }\n  }\n\n  async sendVerificationEmail(\n    email: string,\n    callbackUrl: string,\n    session: InternalSession\n  ): Promise<KnownErrors[\"EmailAlreadyVerified\"] | undefined> {\n    const res = await this.sendClientRequestAndCatchKnownError(\n      \"/contact-channels/send-verification-code\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          email,\n          callback_url: callbackUrl,\n        }),\n      },\n      session,\n      [KnownErrors.EmailAlreadyVerified]\n    );\n\n    if (res.status === \"error\") {\n      return res.error;\n    }\n  }\n\n  async sendMagicLinkEmail(\n    email: string,\n    callbackUrl: string,\n  ): Promise<Result<{ nonce: string }, KnownErrors[\"RedirectUrlNotWhitelisted\"]>> {\n    const res = await this.sendClientRequestAndCatchKnownError(\n      \"/auth/otp/send-sign-in-code\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          email,\n          callback_url: callbackUrl,\n        }),\n      },\n      null,\n      [KnownErrors.RedirectUrlNotWhitelisted]\n    );\n\n    if (res.status === \"error\") {\n      return Result.error(res.error);\n    } else {\n      return Result.ok(await res.data.json());\n    }\n  }\n\n  async resetPassword(\n    options: { code: string } & ({ password: string } | { onlyVerifyCode: true })\n  ): Promise<Result<undefined, KnownErrors[\"VerificationCodeError\"]>> {\n    const res = await this.sendClientRequestAndCatchKnownError(\n      \"onlyVerifyCode\" in options ? \"/auth/password/reset/check-code\" : \"/auth/password/reset\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          code: options.code,\n          ...(\"password\" in options ? { password: options.password } : {}),\n        }),\n      },\n      null,\n      [KnownErrors.VerificationCodeError]\n    );\n\n    if (res.status === \"error\") {\n      return Result.error(res.error);\n    } else {\n      return Result.ok(undefined);\n    }\n  }\n\n  async updatePassword(\n    options: { oldPassword: string, newPassword: string },\n    session: InternalSession\n  ): Promise<KnownErrors[\"PasswordConfirmationMismatch\"] | KnownErrors[\"PasswordRequirementsNotMet\"] | undefined> {\n    const res = await this.sendClientRequestAndCatchKnownError(\n      \"/auth/password/update\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          old_password: options.oldPassword,\n          new_password: options.newPassword,\n        }),\n      },\n      session,\n      [KnownErrors.PasswordConfirmationMismatch, KnownErrors.PasswordRequirementsNotMet]\n    );\n\n    if (res.status === \"error\") {\n      return res.error;\n    }\n  }\n\n  async setPassword(\n    options: { password: string },\n    session: InternalSession\n  ): Promise<KnownErrors[\"PasswordRequirementsNotMet\"] | undefined> {\n    const res = await this.sendClientRequestAndCatchKnownError(\n      \"/auth/password/set\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(options),\n      },\n      session,\n      [KnownErrors.PasswordRequirementsNotMet]\n    );\n\n    if (res.status === \"error\") {\n      return res.error;\n    }\n  }\n\n  async verifyPasswordResetCode(code: string): Promise<Result<undefined, KnownErrors[\"VerificationCodeError\"]>> {\n    const res = await this.resetPassword({ code, onlyVerifyCode: true });\n    if (res.status === \"error\") {\n      return Result.error(res.error);\n    } else {\n      return Result.ok(undefined);\n    }\n  }\n\n  async verifyEmail(code: string): Promise<Result<undefined, KnownErrors[\"VerificationCodeError\"]>> {\n    const res = await this.sendClientRequestAndCatchKnownError(\n      \"/contact-channels/verify\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          code,\n        }),\n      },\n      null,\n      [KnownErrors.VerificationCodeError]\n    );\n\n    if (res.status === \"error\") {\n      return Result.error(res.error);\n    } else {\n      return Result.ok(undefined);\n    }\n  }\n\n  async initiatePasskeyRegistration(\n    options: {},\n    session: InternalSession\n  ): Promise<Result<{ options_json: PublicKeyCredentialCreationOptionsJSON, code: string }, KnownErrors[]>> {\n    const res = await this.sendClientRequestAndCatchKnownError(\n      \"/auth/passkey/initiate-passkey-registration\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(options),\n      },\n      session,\n      []\n    );\n\n    if (res.status === \"error\") {\n      return Result.error(res.error);\n    }\n\n    return Result.ok(await res.data.json());\n  }\n\n  async registerPasskey(\n    options: { credential: RegistrationResponseJSON, code: string },\n    session: InternalSession\n  ): Promise<Result<undefined, KnownErrors[\"PasskeyRegistrationFailed\"]>> {\n    const res = await this.sendClientRequestAndCatchKnownError(\n      \"/auth/passkey/register\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(options),\n      },\n      session,\n      [KnownErrors.PasskeyRegistrationFailed]\n    );\n    if (res.status === \"error\") {\n      return Result.error(res.error);\n    }\n    return Result.ok(undefined);\n  }\n\n  async initiatePasskeyAuthentication(\n    options: {\n    },\n    session: InternalSession\n  ): Promise<Result<{ options_json: PublicKeyCredentialRequestOptionsJSON, code: string }, KnownErrors[]>> {\n    const res = await this.sendClientRequestAndCatchKnownError(\n      \"/auth/passkey/initiate-passkey-authentication\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(options),\n      },\n      session,\n      []\n    );\n\n    if (res.status === \"error\") {\n      return Result.error(res.error);\n    }\n\n    return Result.ok(await res.data.json());\n  }\n\n  async sendTeamInvitation(options: {\n    email: string,\n    teamId: string,\n    callbackUrl: string,\n    session: InternalSession,\n  }): Promise<void> {\n    await this.sendClientRequest(\n      \"/team-invitations/send-code\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          email: options.email,\n          team_id: options.teamId,\n          callback_url: options.callbackUrl,\n        }),\n      },\n      options.session,\n    );\n  }\n\n  async acceptTeamInvitation<T extends 'use' | 'details' | 'check'>(options: {\n    code: string,\n    session: InternalSession,\n    type: T,\n  }): Promise<Result<T extends 'details' ? { team_display_name: string } : undefined, KnownErrors[\"VerificationCodeError\"]>> {\n    const res = await this.sendClientRequestAndCatchKnownError(\n      options.type === 'check' ?\n        \"/team-invitations/accept/check-code\" :\n        options.type === 'details' ?\n          \"/team-invitations/accept/details\" :\n          \"/team-invitations/accept\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          code: options.code,\n        }),\n      },\n      options.session,\n      [KnownErrors.VerificationCodeError]\n    );\n\n    if (res.status === \"error\") {\n      return Result.error(res.error);\n    } else {\n      return Result.ok(await res.data.json());\n    }\n  }\n\n  async totpMfa(\n    attemptCode: string,\n    totp: string,\n    session: InternalSession\n  ) {\n    const res = await this.sendClientRequest(\"/auth/mfa/sign-in\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({\n        code: attemptCode,\n        type: \"totp\",\n        totp: totp,\n      }),\n    }, session);\n\n    const result = await res.json();\n    return {\n      accessToken: result.access_token,\n      refreshToken: result.refresh_token,\n      newUser: result.is_new_user,\n    };\n  }\n\n  async signInWithCredential(\n    email: string,\n    password: string,\n    session: InternalSession\n  ): Promise<Result<{ accessToken: string, refreshToken: string }, KnownErrors[\"EmailPasswordMismatch\"]>> {\n    const res = await this.sendClientRequestAndCatchKnownError(\n      \"/auth/password/sign-in\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          email,\n          password,\n        }),\n      },\n      session,\n      [KnownErrors.EmailPasswordMismatch]\n    );\n\n    if (res.status === \"error\") {\n      return Result.error(res.error);\n    }\n\n    const result = await res.data.json();\n    return Result.ok({\n      accessToken: result.access_token,\n      refreshToken: result.refresh_token,\n    });\n  }\n\n  async signUpWithCredential(\n    email: string,\n    password: string,\n    emailVerificationRedirectUrl: string | undefined,\n    session: InternalSession,\n  ): Promise<Result<{ accessToken: string, refreshToken: string }, KnownErrors[\"UserWithEmailAlreadyExists\"] | KnownErrors[\"PasswordRequirementsNotMet\"]>> {\n    const res = await this.sendClientRequestAndCatchKnownError(\n      \"/auth/password/sign-up\",\n      {\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        method: \"POST\",\n        body: JSON.stringify({\n          email,\n          password,\n          verification_callback_url: emailVerificationRedirectUrl,\n        }),\n      },\n      session,\n      [KnownErrors.UserWithEmailAlreadyExists, KnownErrors.PasswordRequirementsNotMet]\n    );\n\n    if (res.status === \"error\") {\n      return Result.error(res.error);\n    }\n\n    const result = await res.data.json();\n    return Result.ok({\n      accessToken: result.access_token,\n      refreshToken: result.refresh_token,\n    });\n  }\n\n  async signUpAnonymously(session: InternalSession): Promise<Result<{ accessToken: string, refreshToken: string }, never>> {\n    const res = await this.sendClientRequestAndCatchKnownError(\n      \"/auth/anonymous/sign-up\",\n      {\n        method: \"POST\",\n      },\n      session,\n      [],\n    );\n\n    if (res.status === \"error\") {\n      return Result.error(res.error);\n    }\n\n    const result = await res.data.json();\n    return Result.ok({\n      accessToken: result.access_token,\n      refreshToken: result.refresh_token,\n    });\n  }\n\n  async signInWithMagicLink(code: string, session: InternalSession): Promise<Result<{ newUser: boolean, accessToken: string, refreshToken: string }, KnownErrors[\"VerificationCodeError\"]>> {\n    const res = await this.sendClientRequestAndCatchKnownError(\n      \"/auth/otp/sign-in\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          code,\n        }),\n      },\n      session,\n      [KnownErrors.VerificationCodeError]\n    );\n\n    if (res.status === \"error\") {\n      return Result.error(res.error);\n    }\n\n    const result = await res.data.json();\n    return Result.ok({\n      accessToken: result.access_token,\n      refreshToken: result.refresh_token,\n      newUser: result.is_new_user,\n    });\n  }\n\n  async signInWithMfa(totp: string, code: string, session: InternalSession): Promise<Result<{ newUser: boolean, accessToken: string, refreshToken: string }, KnownErrors[\"VerificationCodeError\"]>> {\n    const res = await this.sendClientRequestAndCatchKnownError(\n      \"/auth/mfa/sign-in\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          type: \"totp\",\n          totp,\n          code,\n        }),\n      },\n      session,\n      [KnownErrors.VerificationCodeError]\n    );\n\n    if (res.status === \"error\") {\n      return Result.error(res.error);\n    }\n\n    const result = await res.data.json();\n    return Result.ok({\n      accessToken: result.access_token,\n      refreshToken: result.refresh_token,\n      newUser: result.is_new_user,\n    });\n  }\n\n  async signInWithPasskey(body: { authentication_response: AuthenticationResponseJSON, code: string }, session: InternalSession): Promise<Result<{accessToken: string, refreshToken: string }, KnownErrors[\"PasskeyAuthenticationFailed\"]>> {\n    const res = await this.sendClientRequestAndCatchKnownError(\n      \"/auth/passkey/sign-in\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(body),\n      },\n      session,\n      [KnownErrors.PasskeyAuthenticationFailed]\n    );\n\n    if (res.status === \"error\") {\n      return Result.error(res.error);\n    }\n\n    const result = await res.data.json();\n    return Result.ok({\n      accessToken: result.access_token,\n      refreshToken: result.refresh_token,\n    });\n  }\n\n  async getOAuthUrl(\n    options: {\n      provider: string,\n      redirectUrl: string,\n      errorRedirectUrl: string,\n      afterCallbackRedirectUrl?: string,\n      codeChallenge: string,\n      state: string,\n      type: \"authenticate\" | \"link\",\n      providerScope?: string,\n      session: InternalSession,\n    }\n  ): Promise<string> {\n    const updatedRedirectUrl = new URL(options.redirectUrl);\n    for (const key of [\"code\", \"state\"]) {\n      if (updatedRedirectUrl.searchParams.has(key)) {\n        console.warn(\"Redirect URL already contains \" + key + \" parameter, removing it as it will be overwritten by the OAuth callback\");\n      }\n      updatedRedirectUrl.searchParams.delete(key);\n    }\n\n    if (!('publishableClientKey' in this.options)) {\n      // TODO fix\n      throw new Error(\"Admin session token is currently not supported for OAuth\");\n    }\n    const url = new URL(this.getApiUrl() + \"/auth/oauth/authorize/\" + options.provider.toLowerCase());\n    url.searchParams.set(\"client_id\", this.projectId);\n    url.searchParams.set(\"client_secret\", this.options.publishableClientKey);\n    url.searchParams.set(\"redirect_uri\", updatedRedirectUrl.toString());\n    url.searchParams.set(\"scope\", \"legacy\");\n    url.searchParams.set(\"state\", options.state);\n    url.searchParams.set(\"grant_type\", \"authorization_code\");\n    url.searchParams.set(\"code_challenge\", options.codeChallenge);\n    url.searchParams.set(\"code_challenge_method\", \"S256\");\n    url.searchParams.set(\"response_type\", \"code\");\n    url.searchParams.set(\"type\", options.type);\n    url.searchParams.set(\"error_redirect_url\", options.errorRedirectUrl);\n\n    const tokens = await options.session.getOrFetchLikelyValidTokens(20_000);\n    if (tokens) {\n      url.searchParams.set(\"token\", tokens.accessToken.token);\n    }\n\n    if (options.afterCallbackRedirectUrl) {\n      url.searchParams.set(\"after_callback_redirect_url\", options.afterCallbackRedirectUrl);\n    }\n    if (options.providerScope) {\n      url.searchParams.set(\"provider_scope\", options.providerScope);\n    }\n\n    return url.toString();\n  }\n\n  async callOAuthCallback(options: {\n    oauthParams: URLSearchParams,\n    redirectUri: string,\n    codeVerifier: string,\n    state: string,\n  }): Promise<{ newUser: boolean, afterCallbackRedirectUrl?: string, accessToken: string, refreshToken: string }> {\n    if (!('publishableClientKey' in this.options)) {\n      // TODO fix\n      throw new Error(\"Admin session token is currently not supported for OAuth\");\n    }\n    const as = {\n      issuer: this.options.getBaseUrl(),\n      algorithm: 'oauth2',\n      token_endpoint: this.getApiUrl() + '/auth/oauth/token',\n    };\n    const client: oauth.Client = {\n      client_id: this.projectId,\n      client_secret: this.options.publishableClientKey,\n      token_endpoint_auth_method: 'client_secret_post',\n    };\n    const params = await this._networkRetryException(\n      async () => oauth.validateAuthResponse(as, client, options.oauthParams, options.state),\n    );\n    if (oauth.isOAuth2Error(params)) {\n      throw new StackAssertionError(\"Error validating outer OAuth response\", { params }); // Handle OAuth 2.0 redirect error\n    }\n    const response = await oauth.authorizationCodeGrantRequest(\n      as,\n      client,\n      params,\n      options.redirectUri,\n      options.codeVerifier,\n    );\n\n    const result = await oauth.processAuthorizationCodeOAuth2Response(as, client, response);\n    if (oauth.isOAuth2Error(result)) {\n      if (\"code\" in result && result.code === \"MULTI_FACTOR_AUTHENTICATION_REQUIRED\") {\n        throw new KnownErrors.MultiFactorAuthenticationRequired((result as any).details.attempt_code);\n      }\n      // TODO Handle OAuth 2.0 response body error\n      throw new StackAssertionError(\"Outer OAuth error during authorization code response\", { result });\n    }\n    return {\n      newUser: result.is_new_user as boolean,\n      afterCallbackRedirectUrl: result.after_callback_redirect_url as string | undefined,\n      accessToken: result.access_token,\n      refreshToken: result.refresh_token ?? throwErr(\"Refresh token not found in outer OAuth response\"),\n    };\n  }\n\n  async signOut(session: InternalSession): Promise<void> {\n    const tokenObj = await session.getOrFetchLikelyValidTokens(20_000);\n    if (tokenObj) {\n      const resOrError = await this.sendClientRequestAndCatchKnownError(\n        \"/auth/sessions/current\",\n        {\n          method: \"DELETE\",\n          headers: {\n            \"Content-Type\": \"application/json\"\n          },\n          body: JSON.stringify({}),\n        },\n        session,\n        [KnownErrors.RefreshTokenError]\n      );\n      if (resOrError.status === \"error\") {\n        if (KnownErrors.RefreshTokenError.isInstance(resOrError.error)) {\n          // refresh token was already invalid, just continue like nothing happened\n        } else {\n          // this should never happen\n          throw new StackAssertionError(\"Unexpected error\", { error: resOrError.error });\n        }\n      } else {\n        // user was signed out successfully, all good\n      }\n    }\n    session.markInvalid();\n  }\n\n  async getClientUserByToken(session: InternalSession): Promise<CurrentUserCrud[\"Client\"][\"Read\"] | null> {\n    const responseOrError = await this.sendClientRequestAndCatchKnownError(\n      \"/users/me\",\n      {},\n      session,\n      [KnownErrors.CannotGetOwnUserWithoutUser],\n    );\n    if (responseOrError.status === \"error\") {\n      if (KnownErrors.CannotGetOwnUserWithoutUser.isInstance(responseOrError.error)) {\n        return null;\n      } else {\n        throw new StackAssertionError(\"Unexpected uncaught error\", { cause: responseOrError.error });\n      }\n    }\n    const response = responseOrError.data;\n    const user: CurrentUserCrud[\"Client\"][\"Read\"] = await response.json();\n    if (!(user as any)) throw new StackAssertionError(\"User endpoint returned null; this should never happen\");\n    return user;\n  }\n\n  async listTeamInvitations(\n    options: {\n      teamId: string,\n    },\n    session: InternalSession,\n  ): Promise<TeamInvitationCrud['Client']['Read'][]> {\n    const response = await this.sendClientRequest(\n      \"/team-invitations?\" + new URLSearchParams({ team_id: options.teamId }),\n      {},\n      session,\n    );\n    const result = await response.json() as TeamInvitationCrud['Client']['List'];\n    return result.items;\n  }\n\n  async revokeTeamInvitation(\n    invitationId: string,\n    teamId: string,\n    session: InternalSession,\n  ) {\n    await this.sendClientRequest(\n      `/team-invitations/${invitationId}?team_id=${teamId}`,\n      { method: \"DELETE\" },\n      session,\n    );\n  }\n\n  async listTeamMemberProfiles(\n    options: {\n      teamId?: string,\n      userId?: string,\n    },\n    session: InternalSession,\n  ): Promise<TeamMemberProfilesCrud['Client']['Read'][]> {\n    const response = await this.sendClientRequest(\n      \"/team-member-profiles?\" + new URLSearchParams(filterUndefined({\n        team_id: options.teamId,\n        user_id: options.userId,\n      })),\n      {},\n      session,\n    );\n    const result = await response.json() as TeamMemberProfilesCrud['Client']['List'];\n    return result.items;\n  }\n\n  async getTeamMemberProfile(\n    options: {\n      teamId: string,\n      userId: string,\n    },\n    session: InternalSession,\n  ): Promise<TeamMemberProfilesCrud['Client']['Read']> {\n    const response = await this.sendClientRequest(\n      `/team-member-profiles/${options.teamId}/${options.userId}`,\n      {},\n      session,\n    );\n    return await response.json();\n  }\n\n  async leaveTeam(\n    teamId: string,\n    session: InternalSession,\n  ) {\n    await this.sendClientRequest(\n      `/team-memberships/${teamId}/me`,\n      {\n        method: \"DELETE\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({}),\n      },\n      session,\n    );\n  }\n\n  async updateTeamMemberProfile(\n    options: {\n      teamId: string,\n      userId: string,\n      profile: TeamMemberProfilesCrud['Client']['Update'],\n    },\n    session: InternalSession,\n  ) {\n    await this.sendClientRequest(\n      `/team-member-profiles/${options.teamId}/${options.userId}`,\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(options.profile),\n      },\n      session,\n    );\n  }\n\n  async updateTeam(\n    options: {\n      teamId: string,\n      data: TeamsCrud['Client']['Update'],\n    },\n    session: InternalSession,\n  ) {\n    await this.sendClientRequest(\n      `/teams/${options.teamId}`,\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(options.data),\n      },\n      session,\n    );\n  }\n\n  async listCurrentUserTeamPermissions(\n    options: {\n      teamId: string,\n      recursive: boolean,\n    },\n    session: InternalSession\n  ): Promise<TeamPermissionsCrud['Client']['Read'][]> {\n    const response = await this.sendClientRequest(\n      `/team-permissions?team_id=${options.teamId}&user_id=me&recursive=${options.recursive}`,\n      {},\n      session,\n    );\n    const result = await response.json() as TeamPermissionsCrud['Client']['List'];\n    return result.items;\n  }\n\n  async listCurrentUserProjectPermissions(\n    options: {\n      recursive: boolean,\n    },\n    session: InternalSession\n  ): Promise<ProjectPermissionsCrud['Client']['Read'][]> {\n    const response = await this.sendClientRequest(\n      `/project-permissions?user_id=me&recursive=${options.recursive}`,\n      {},\n      session,\n    );\n    const result = await response.json() as ProjectPermissionsCrud['Client']['List'];\n    return result.items;\n  }\n\n  async listCurrentUserTeams(session: InternalSession): Promise<TeamsCrud[\"Client\"][\"Read\"][]> {\n    const response = await this.sendClientRequest(\n      \"/teams?user_id=me\",\n      {},\n      session,\n    );\n    const result = await response.json() as TeamsCrud[\"Client\"][\"List\"];\n    return result.items;\n  }\n\n  async getClientProject(): Promise<Result<ClientProjectsCrud['Client']['Read'], KnownErrors[\"ProjectNotFound\"]>> {\n    const responseOrError = await this.sendClientRequestAndCatchKnownError(\"/projects/current\", {}, null, [KnownErrors.ProjectNotFound]);\n    if (responseOrError.status === \"error\") {\n      return Result.error(responseOrError.error);\n    }\n    const response = responseOrError.data;\n    const project: ClientProjectsCrud['Client']['Read'] = await response.json();\n    return Result.ok(project);\n  }\n\n  async updateClientUser(update: CurrentUserCrud[\"Client\"][\"Update\"], session: InternalSession) {\n    await this.sendClientRequest(\n      \"/users/me\",\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(update),\n      },\n      session,\n    );\n  }\n\n  async listProjects(session: InternalSession): Promise<AdminUserProjectsCrud['Client']['Read'][]> {\n    const response = await this.sendClientRequest(\"/internal/projects\", {}, session);\n    if (!response.ok) {\n      throw new Error(\"Failed to list projects: \" + response.status + \" \" + (await response.text()));\n    }\n\n    const json = await response.json() as AdminUserProjectsCrud['Client']['List'];\n    return json.items;\n  }\n\n  async createProject(\n    project: AdminUserProjectsCrud['Client']['Create'],\n    session: InternalSession,\n  ): Promise<AdminUserProjectsCrud['Client']['Read']> {\n    const fetchResponse = await this.sendClientRequest(\n      \"/internal/projects\",\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(project),\n      },\n      session,\n    );\n    if (!fetchResponse.ok) {\n      throw new Error(\"Failed to create project: \" + fetchResponse.status + \" \" + (await fetchResponse.text()));\n    }\n\n    const json = await fetchResponse.json();\n    return json;\n  }\n\n  async createProviderAccessToken(\n    provider: string,\n    scope: string,\n    session: InternalSession,\n  ): Promise<ConnectedAccountAccessTokenCrud['Client']['Read']> {\n    const response = await this.sendClientRequest(\n      `/connected-accounts/me/${provider}/access-token`,\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({ scope }),\n      },\n      session,\n    );\n    return await response.json();\n  }\n\n  async createClientTeam(\n    data: TeamsCrud['Client']['Create'],\n    session: InternalSession,\n  ): Promise<TeamsCrud['Client']['Read']> {\n    const response = await this.sendClientRequest(\n      \"/teams\",\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(data),\n      },\n      session,\n    );\n    return await response.json();\n  }\n\n  async deleteTeam(\n    teamId: string,\n    session: InternalSession,\n  ) {\n    await this.sendClientRequest(\n      `/teams/${teamId}`,\n      {\n        method: \"DELETE\",\n      },\n      session,\n    );\n  }\n\n  async deleteCurrentUser(session: InternalSession) {\n    await this.sendClientRequest(\n      \"/users/me\",\n      {\n        method: \"DELETE\",\n      },\n      session,\n    );\n  }\n\n  async createClientContactChannel(\n    data: ContactChannelsCrud['Client']['Create'],\n    session: InternalSession,\n  ): Promise<ContactChannelsCrud['Client']['Read']> {\n    const response = await this.sendClientRequest(\n      \"/contact-channels\",\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(data),\n      },\n      session,\n    );\n    return await response.json();\n  }\n\n  async updateClientContactChannel(\n    id: string,\n    data: ContactChannelsCrud['Client']['Update'],\n    session: InternalSession,\n  ): Promise<ContactChannelsCrud['Client']['Read']> {\n    const response = await this.sendClientRequest(\n      `/contact-channels/me/${id}`,\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(data),\n      },\n      session,\n    );\n    return await response.json();\n  }\n\n  async deleteClientContactChannel(\n    id: string,\n    session: InternalSession,\n  ): Promise<void> {\n    await this.sendClientRequest(\n      `/contact-channels/me/${id}`,\n      {\n        method: \"DELETE\",\n      },\n      session,\n    );\n  }\n\n  async deleteSession(\n    sessionId: string,\n    session: InternalSession,\n  ): Promise<void> {\n    await this.sendClientRequest(\n      `/auth/sessions/${sessionId}?user_id=me`,\n      {\n        method: \"DELETE\",\n      },\n      session,\n    );\n  }\n\n  async listSessions(\n    session: InternalSession,\n  ): Promise<SessionsCrud['Client']['List']> {\n    const response = await this.sendClientRequest(\n      \"/auth/sessions?user_id=me\",\n      {\n        method: \"GET\",\n      },\n      session,\n    );\n    return await response.json();\n  }\n\n\n  async listClientContactChannels(\n    session: InternalSession,\n  ): Promise<ContactChannelsCrud['Client']['Read'][]> {\n    const response = await this.sendClientRequest(\n      \"/contact-channels?user_id=me\",\n      {\n        method: \"GET\",\n      },\n      session,\n    );\n    const json = await response.json() as ContactChannelsCrud['Client']['List'];\n    return json.items;\n  }\n\n  async sendCurrentUserContactChannelVerificationEmail(\n    contactChannelId: string,\n    callbackUrl: string,\n    session: InternalSession,\n  ): Promise<Result<undefined, KnownErrors[\"EmailAlreadyVerified\"]>> {\n    const responseOrError = await this.sendClientRequestAndCatchKnownError(\n      `/contact-channels/me/${contactChannelId}/send-verification-code`,\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({ callback_url: callbackUrl }),\n      },\n      session,\n      [KnownErrors.EmailAlreadyVerified]\n    );\n\n    if (responseOrError.status === \"error\") {\n      return Result.error(responseOrError.error);\n    }\n    return Result.ok(undefined);\n  }\n\n  async cliLogin(\n    loginCode: string,\n    refreshToken: string,\n    session: InternalSession\n  ): Promise<Result<undefined, KnownErrors[\"SchemaError\"]>> {\n    const responseOrError = await this.sendClientRequestAndCatchKnownError(\n      \"/auth/cli/complete\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          login_code: loginCode,\n          refresh_token: refreshToken,\n        }),\n      },\n      session,\n      [KnownErrors.SchemaError]\n    );\n\n    if (responseOrError.status === \"error\") {\n      return Result.error(responseOrError.error);\n    }\n    return Result.ok(undefined);\n  }\n\n  private async _getApiKeyRequestInfo(options: { user_id: string | null } | { team_id: string }) {\n    if (\"user_id\" in options && \"team_id\" in options) {\n      throw new StackAssertionError(\"Cannot specify both user_id and team_id in _getApiKeyRequestInfo\");\n    }\n\n    return {\n      endpoint: \"team_id\" in options ? \"/team-api-keys\" : \"/user-api-keys\",\n      queryParams: new URLSearchParams(filterUndefinedOrNull(options)),\n    };\n  }\n\n  // API Keys CRUD operations\n  listProjectApiKeys(options: { user_id: string }, session: InternalSession | null, requestType: \"client\" | \"server\" | \"admin\"): Promise<UserApiKeysCrud['Client']['Read'][]>;\n  listProjectApiKeys(options: { team_id: string }, session: InternalSession | null, requestType: \"client\" | \"server\" | \"admin\"): Promise<TeamApiKeysCrud['Client']['Read'][]>;\n  listProjectApiKeys(options: { user_id: string } | { team_id: string }, session: InternalSession | null, requestType: \"client\" | \"server\" | \"admin\"): Promise<(UserApiKeysCrud['Client']['Read'] | TeamApiKeysCrud['Client']['Read'])[]>;\n  async listProjectApiKeys(\n    options: { user_id: string } | { team_id: string },\n    session: InternalSession | null,\n    requestType: \"client\" | \"server\" | \"admin\",\n  ): Promise<(UserApiKeysCrud['Client']['Read'] | TeamApiKeysCrud['Client']['Read'])[]> {\n    const sendRequest = (requestType === \"client\" ? this.sendClientRequest : (this as any).sendServerRequest as never).bind(this);\n    const { endpoint, queryParams } = await this._getApiKeyRequestInfo(options);\n\n    const response = await sendRequest(\n      `${endpoint}?${queryParams.toString()}`,\n      {\n        method: \"GET\",\n      },\n      session,\n      requestType,\n    );\n    const json = await response.json();\n    return json.items;\n  }\n\n  createProjectApiKey(data: yup.InferType<typeof userApiKeysCreateInputSchema>, session: InternalSession | null, requestType: \"client\" | \"server\" | \"admin\"): Promise<yup.InferType<typeof userApiKeysCreateOutputSchema>>;\n  createProjectApiKey(data: yup.InferType<typeof teamApiKeysCreateInputSchema>, session: InternalSession | null, requestType: \"client\" | \"server\" | \"admin\"): Promise<yup.InferType<typeof teamApiKeysCreateOutputSchema>>;\n  createProjectApiKey(data: yup.InferType<typeof userApiKeysCreateInputSchema> | yup.InferType<typeof teamApiKeysCreateInputSchema>, session: InternalSession | null, requestType: \"client\" | \"server\" | \"admin\"): Promise<yup.InferType<typeof userApiKeysCreateOutputSchema> | yup.InferType<typeof teamApiKeysCreateOutputSchema>>;\n  async createProjectApiKey(\n    data: yup.InferType<typeof userApiKeysCreateInputSchema> | yup.InferType<typeof teamApiKeysCreateInputSchema>,\n    session: InternalSession | null,\n    requestType: \"client\" | \"server\" | \"admin\",\n  ): Promise<yup.InferType<typeof userApiKeysCreateOutputSchema> | yup.InferType<typeof teamApiKeysCreateOutputSchema>> {\n    const sendRequest = (requestType === \"client\" ? this.sendClientRequest : (this as any).sendServerRequest as never).bind(this);\n    const { endpoint } = await this._getApiKeyRequestInfo(data);\n\n    const response = await sendRequest(\n      `${endpoint}`,\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(data),\n      },\n      session,\n      requestType,\n    );\n    return await response.json();\n  }\n\n  getProjectApiKey(options: { user_id: string | null }, keyId: string, session: InternalSession | null, requestType: \"client\" | \"server\" | \"admin\"): Promise<UserApiKeysCrud['Client']['Read']>;\n  getProjectApiKey(options: { team_id: string }, keyId: string, session: InternalSession | null, requestType: \"client\" | \"server\" | \"admin\"): Promise<TeamApiKeysCrud['Client']['Read']>;\n  getProjectApiKey(options: { user_id: string | null } | { team_id: string }, keyId: string, session: InternalSession | null, requestType: \"client\" | \"server\" | \"admin\"): Promise<UserApiKeysCrud['Client']['Read'] | TeamApiKeysCrud['Client']['Read']>;\n  async getProjectApiKey(\n    options: { user_id: string | null } | { team_id: string },\n    keyId: string,\n    session: InternalSession | null,\n    requestType: \"client\" | \"server\" | \"admin\",\n  ): Promise<UserApiKeysCrud['Client']['Read'] | TeamApiKeysCrud['Client']['Read']> {\n    const sendRequest = (requestType === \"client\" ? this.sendClientRequest : (this as any).sendServerRequest as never).bind(this);\n    const { endpoint, queryParams } = await this._getApiKeyRequestInfo(options);\n\n    const response = await sendRequest(\n      `${endpoint}/${keyId}?${queryParams.toString()}`,\n      {\n        method: \"GET\",\n      },\n      session,\n      requestType,\n    );\n    return await response.json();\n  }\n\n  updateProjectApiKey(options: { user_id: string }, keyId: string, data: UserApiKeysCrud['Client']['Update'], session: InternalSession | null, requestType: \"client\" | \"server\" | \"admin\"): Promise<UserApiKeysCrud['Client']['Read']>;\n  updateProjectApiKey(options: { team_id: string }, keyId: string, data: TeamApiKeysCrud['Client']['Update'], session: InternalSession | null, requestType: \"client\" | \"server\" | \"admin\"): Promise<TeamApiKeysCrud['Client']['Read']>;\n  updateProjectApiKey(options: { user_id: string } | { team_id: string }, keyId: string, data: UserApiKeysCrud['Client']['Update'] | TeamApiKeysCrud['Client']['Update'], session: InternalSession | null, requestType: \"client\" | \"server\" | \"admin\"): Promise<UserApiKeysCrud['Client']['Read'] | TeamApiKeysCrud['Client']['Read']>;\n  async updateProjectApiKey(\n    options: { user_id: string } | { team_id: string },\n    keyId: string,\n    data: UserApiKeysCrud['Client']['Update'] | TeamApiKeysCrud['Client']['Update'],\n    session: InternalSession | null,\n    requestType: \"client\" | \"server\" | \"admin\",\n  ): Promise<UserApiKeysCrud['Client']['Read'] | TeamApiKeysCrud['Client']['Read']> {\n    const sendRequest = (requestType === \"client\" ? this.sendClientRequest : (this as any).sendServerRequest as never).bind(this);\n    const { endpoint, queryParams } = await this._getApiKeyRequestInfo(options);\n\n    const response = await sendRequest(\n      `${endpoint}/${keyId}?${queryParams.toString()}`,\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(data),\n      },\n      session,\n      requestType,\n    );\n    return await response.json();\n  }\n\n  checkProjectApiKey(type: \"user\", apiKey: string, session: InternalSession | null, requestType: \"client\" | \"server\" | \"admin\"): Promise<UserApiKeysCrud['Client']['Read'] | null>;\n  checkProjectApiKey(type: \"team\", apiKey: string, session: InternalSession | null, requestType: \"client\" | \"server\" | \"admin\"): Promise<TeamApiKeysCrud['Client']['Read'] | null>;\n  checkProjectApiKey(type: \"user\" | \"team\", apiKey: string, session: InternalSession | null, requestType: \"client\" | \"server\" | \"admin\"): Promise<UserApiKeysCrud['Client']['Read'] | TeamApiKeysCrud['Client']['Read'] | null>;\n  async checkProjectApiKey(type: \"user\" | \"team\", apiKey: string, session: InternalSession | null, requestType: \"client\" | \"server\" | \"admin\"): Promise<UserApiKeysCrud['Client']['Read'] | TeamApiKeysCrud['Client']['Read'] | null> {\n    const sendRequest = (requestType === \"client\" ? this.sendClientRequestAndCatchKnownError : (this as any).sendServerRequestAndCatchKnownError as never).bind(this);\n    const result = await sendRequest(\n      `/${type}-api-keys/check`,\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({ api_key: apiKey }),\n      },\n      session,\n      [KnownErrors.ApiKeyNotValid]\n    );\n    if (result.status === \"error\") {\n      return null;\n    }\n    return await result.data.json();\n  }\n\n  async listNotificationCategories(\n    session: InternalSession,\n  ): Promise<NotificationPreferenceCrud['Client']['Read'][]> {\n    const response = await this.sendClientRequest(\n      `/emails/notification-preference/me`,\n      {},\n      session,\n    );\n    const result = await response.json() as NotificationPreferenceCrud['Client']['List'];\n    return result.items;\n  }\n\n  async setNotificationsEnabled(\n    notificationCategoryId: string,\n    enabled: boolean,\n    session: InternalSession,\n  ): Promise<void> {\n    await this.sendClientRequest(\n      `/emails/notification-preference/me/${notificationCategoryId}`,\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          enabled,\n        }),\n      },\n      session,\n    );\n  }\n\n  async getOAuthProvider(\n    userId: string,\n    providerId: string,\n    session: InternalSession,\n  ): Promise<OAuthProviderCrud['Client']['Read']> {\n    const response = await this.sendClientRequest(\n      `/oauth-providers/${userId}/${providerId}`,\n      {\n        method: \"GET\",\n      },\n      session,\n    );\n    return await response.json();\n  }\n\n  async updateOAuthProvider(\n    userId: string,\n    providerId: string,\n    data: OAuthProviderCrud['Client']['Update'],\n    session: InternalSession,\n  ): Promise<OAuthProviderCrud['Client']['Read']> {\n    const response = await this.sendClientRequest(\n      `/oauth-providers/${userId}/${providerId}`,\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(data),\n      },\n      session,\n    );\n    return await response.json();\n  }\n\n  async listOAuthProviders(\n    options: {\n      user_id?: string,\n    } = {},\n    session: InternalSession,\n  ): Promise<OAuthProviderCrud['Client']['Read'][]> {\n    const queryParams = new URLSearchParams(filterUndefined(options));\n    const response = await this.sendClientRequest(\n      `/oauth-providers${queryParams.toString() ? `?${queryParams.toString()}` : ''}`,\n      {\n        method: \"GET\",\n      },\n      session,\n    );\n    const result = await response.json();\n    return result.items;\n  }\n\n  async deleteOAuthProvider(\n    userId: string,\n    providerId: string,\n    session: InternalSession,\n  ): Promise<void> {\n    const response = await this.sendClientRequest(\n      `/oauth-providers/${userId}/${providerId}`,\n      {\n        method: \"DELETE\",\n      },\n      session,\n    );\n    return await response.json();\n  }\n\n  async getItem(\n    options: (\n      { itemId: string, userId: string } |\n      { itemId: string, teamId: string } |\n      { itemId: string, customCustomerId: string }\n    ),\n    session: InternalSession | null,\n  ): Promise<ItemCrud['Client']['Read']> {\n    let customerType: \"user\" | \"team\" | \"custom\";\n    let customerId: string;\n    if (\"userId\" in options) {\n      customerType = \"user\";\n      customerId = options.userId;\n    } else if (\"teamId\" in options) {\n      customerType = \"team\";\n      customerId = options.teamId;\n    } else if (\"customCustomerId\" in options) {\n      customerType = \"custom\";\n      customerId = options.customCustomerId;\n    } else {\n      throw new StackAssertionError(\"getItem requires one of userId, teamId, or customCustomerId\");\n    }\n\n    const response = await this.sendClientRequest(\n      urlString`/payments/items/${customerType}/${customerId}/${options.itemId}`,\n      {},\n      session,\n    );\n    return await response.json();\n  }\n\n  async listProducts(\n    options: ListCustomerProductsOptions,\n    session: InternalSession | null,\n  ): Promise<CustomerProductsListResponse> {\n    const queryParams = new URLSearchParams(filterUndefined({\n      cursor: options.cursor,\n      limit: options.limit !== undefined ? options.limit.toString() : undefined,\n    }));\n    const path = urlString`/payments/products/${options.customer_type}/${options.customer_id}`;\n    const response = await this.sendClientRequest(\n      `${path}${queryParams.toString() ? `?${queryParams.toString()}` : ''}`,\n      {},\n      session,\n    );\n    return await response.json();\n  }\n\n  async createCheckoutUrl(\n    customer_type: \"user\" | \"team\" | \"custom\",\n    customer_id: string,\n    productIdOrInline: string | yup.InferType<typeof inlineProductSchema>,\n    session: InternalSession | null,\n    returnUrl?: string,\n  ): Promise<string> {\n    const productBody = typeof productIdOrInline === \"string\" ?\n      { product_id: productIdOrInline } :\n      { inline_product: productIdOrInline };\n    const response = await this.sendClientRequest(\n      \"/payments/purchases/create-purchase-url\",\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({ customer_type, customer_id, ...productBody, return_url: returnUrl }),\n      },\n      session\n    );\n    const { url } = await response.json() as { url: string };\n    return url;\n  }\n\n  async transferProject(internalProjectSession: InternalSession, projectIdToTransfer: string, newTeamId: string): Promise<void> {\n    if (this.options.projectId !== \"internal\") {\n      throw new StackAssertionError(\"StackClientInterface.transferProject() is only available for internal projects (please specify the project ID in the constructor)\");\n    }\n    await this.sendClientRequest(\n      \"/internal/projects/transfer\",\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          project_id: projectIdToTransfer,\n          new_team_id: newTeamId,\n        }),\n      },\n      internalProjectSession,\n    );\n  }\n}\n"],"names":["response"],"mappings":"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"}},
    {"offset": {"line": 6877, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack-shared/src/interface/server-interface.ts"],"sourcesContent":["import * as yup from \"yup\";\nimport { decryptValue, encryptValue, hashKey } from \"../helpers/vault/client-side\";\nimport { KnownErrors } from \"../known-errors\";\nimport { inlineProductSchema } from \"../schema-fields\";\nimport { AccessToken, InternalSession, RefreshToken } from \"../sessions\";\nimport { StackAssertionError } from \"../utils/errors\";\nimport { filterUndefined } from \"../utils/objects\";\nimport { Result } from \"../utils/results\";\nimport { urlString } from \"../utils/urls\";\nimport {\n  ClientInterfaceOptions,\n  StackClientInterface\n} from \"./client-interface\";\nimport { ConnectedAccountAccessTokenCrud } from \"./crud/connected-accounts\";\nimport { ContactChannelsCrud } from \"./crud/contact-channels\";\nimport { CurrentUserCrud } from \"./crud/current-user\";\nimport { ItemCrud } from \"./crud/items\";\nimport { NotificationPreferenceCrud } from \"./crud/notification-preferences\";\nimport { OAuthProviderCrud } from \"./crud/oauth-providers\";\nimport { ProjectPermissionsCrud } from \"./crud/project-permissions\";\nimport { SessionsCrud } from \"./crud/sessions\";\nimport { TeamInvitationCrud } from \"./crud/team-invitation\";\nimport { TeamMemberProfilesCrud } from \"./crud/team-member-profiles\";\nimport { TeamMembershipsCrud } from \"./crud/team-memberships\";\nimport { TeamPermissionsCrud } from \"./crud/team-permissions\";\nimport { TeamsCrud } from \"./crud/teams\";\nimport { UsersCrud } from \"./crud/users\";\n\nexport type ServerAuthApplicationOptions = (\n  & ClientInterfaceOptions\n  & (\n    | {\n      readonly secretServerKey: string,\n    }\n    | {\n      readonly projectOwnerSession: InternalSession,\n    }\n  )\n);\n\nexport class StackServerInterface extends StackClientInterface {\n  constructor(public override options: ServerAuthApplicationOptions) {\n    super(options);\n  }\n\n  protected async sendServerRequest(path: string, options: RequestInit, session: InternalSession | null, requestType: \"server\" | \"admin\" = \"server\") {\n    return await this.sendClientRequest(\n      path,\n      {\n        ...options,\n        headers: {\n          \"x-stack-secret-server-key\": \"secretServerKey\" in this.options ? this.options.secretServerKey : \"\",\n          ...options.headers,\n        },\n      },\n      session,\n      requestType,\n    );\n  }\n\n  protected async sendServerRequestAndCatchKnownError<E extends typeof KnownErrors[keyof KnownErrors]>(\n    path: string,\n    requestOptions: RequestInit,\n    tokenStoreOrNull: InternalSession | null,\n    errorsToCatch: readonly E[],\n  ): Promise<Result<\n    Response & {\n      usedTokens: {\n        accessToken: AccessToken,\n        refreshToken: RefreshToken | null,\n      } | null,\n    },\n    InstanceType<E>\n  >> {\n    try {\n      return Result.ok(await this.sendServerRequest(path, requestOptions, tokenStoreOrNull));\n    } catch (e) {\n      for (const errorType of errorsToCatch) {\n        if (errorType.isInstance(e)) {\n          return Result.error(e as InstanceType<E>);\n        }\n      }\n      throw e;\n    }\n  }\n\n  async createServerUser(data: UsersCrud['Server']['Create']): Promise<UsersCrud['Server']['Read']> {\n    const response = await this.sendServerRequest(\n      \"/users\",\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(data),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async getServerUserByToken(session: InternalSession): Promise<CurrentUserCrud['Server']['Read'] | null> {\n    const responseOrError = await this.sendServerRequestAndCatchKnownError(\n      \"/users/me\",\n      {},\n      session,\n      [KnownErrors.CannotGetOwnUserWithoutUser],\n    );\n    if (responseOrError.status === \"error\") {\n      if (KnownErrors.CannotGetOwnUserWithoutUser.isInstance(responseOrError.error)) {\n        return null;\n      } else {\n        throw new StackAssertionError(\"Unexpected uncaught error\", { cause: responseOrError.error });\n      }\n    }\n    const response = responseOrError.data;\n    const user: CurrentUserCrud['Server']['Read'] = await response.json();\n    if (!(user as any)) throw new StackAssertionError(\"User endpoint returned null; this should never happen\");\n    return user;\n  }\n\n  async getServerUserById(userId: string): Promise<Result<UsersCrud['Server']['Read']>> {\n    const responseOrError = await this.sendServerRequestAndCatchKnownError(\n      urlString`/users/${userId}`,\n      {},\n      null,\n      [KnownErrors.UserNotFound],\n    );\n    if (responseOrError.status === \"error\") {\n      return Result.error(responseOrError.error);\n    }\n    const user: UsersCrud['Server']['Read'] = await responseOrError.data.json();\n    return Result.ok(user);\n  }\n\n  async listServerTeamInvitations(options: {\n    teamId: string,\n  }): Promise<TeamInvitationCrud['Server']['Read'][]> {\n    const response = await this.sendServerRequest(\n      urlString`/team-invitations?team_id=${options.teamId}`,\n      {},\n      null,\n    );\n    const result = await response.json() as TeamInvitationCrud['Server']['List'];\n    return result.items;\n  }\n\n  async revokeServerTeamInvitation(invitationId: string, teamId: string) {\n    await this.sendServerRequest(\n      urlString`/team-invitations/${invitationId}?team_id=${teamId}`,\n      { method: \"DELETE\" },\n      null,\n    );\n  }\n\n  async listServerTeamMemberProfiles(\n    options: {\n      teamId: string,\n    },\n  ): Promise<TeamMemberProfilesCrud['Server']['Read'][]> {\n    const response = await this.sendServerRequest(\n      urlString`/team-member-profiles?team_id=${options.teamId}`,\n      {},\n      null,\n    );\n    const result = await response.json() as TeamMemberProfilesCrud['Server']['List'];\n    return result.items;\n  }\n\n  async getServerTeamMemberProfile(\n    options: {\n      teamId: string,\n      userId: string,\n    },\n  ): Promise<TeamMemberProfilesCrud['Client']['Read']> {\n    const response = await this.sendServerRequest(\n      urlString`/team-member-profiles/${options.teamId}/${options.userId}`,\n      {},\n      null,\n    );\n    return await response.json();\n  }\n\n  async listServerTeamPermissions(\n    options: {\n      userId?: string,\n      teamId?: string,\n      recursive: boolean,\n    },\n    session: InternalSession | null,\n  ): Promise<TeamPermissionsCrud['Server']['Read'][]> {\n    const response = await this.sendServerRequest(\n      `/team-permissions?${new URLSearchParams(filterUndefined({\n        user_id: options.userId,\n        team_id: options.teamId,\n        recursive: options.recursive.toString(),\n      }))}`,\n      {},\n      session,\n    );\n    const result = await response.json() as TeamPermissionsCrud['Server']['List'];\n    return result.items;\n  }\n\n  async listServerProjectPermissions(\n    options: {\n      userId?: string,\n      recursive: boolean,\n    },\n    session: InternalSession | null,\n  ): Promise<ProjectPermissionsCrud['Server']['Read'][]> {\n    const response = await this.sendServerRequest(\n      `/project-permissions?${new URLSearchParams(filterUndefined({\n        user_id: options.userId,\n        recursive: options.recursive.toString(),\n      }))}`,\n      {},\n      session,\n    );\n    const result = await response.json() as ProjectPermissionsCrud['Server']['List'];\n    return result.items;\n  }\n\n  async listServerUsers(options: {\n    cursor?: string,\n    limit?: number,\n    orderBy?: 'signedUpAt',\n    desc?: boolean,\n    query?: string,\n    includeAnonymous?: boolean,\n  }): Promise<UsersCrud['Server']['List']> {\n    const searchParams = new URLSearchParams(filterUndefined({\n      cursor: options.cursor,\n      limit: options.limit?.toString(),\n      desc: options.desc?.toString(),\n      ...options.orderBy ? {\n        order_by: {\n          signedUpAt: \"signed_up_at\",\n        }[options.orderBy],\n      } : {},\n      ...options.query ? {\n        query: options.query,\n      } : {},\n      ...options.includeAnonymous ? {\n        include_anonymous: 'true',\n      } : {},\n    }));\n    const response = await this.sendServerRequest(\"/users?\" + searchParams.toString(), {}, null);\n    return await response.json();\n  }\n\n  async listServerTeams(options?: {\n    userId?: string,\n  }): Promise<TeamsCrud['Server']['Read'][]> {\n    const response = await this.sendServerRequest(\n      `/teams?${new URLSearchParams(filterUndefined({\n        user_id: options?.userId,\n      }))}`,\n      {},\n      null\n    );\n    const result = await response.json() as TeamsCrud['Server']['List'];\n    return result.items;\n  }\n\n  async getServerTeam(teamId: string): Promise<TeamsCrud['Server']['Read']> {\n    const response = await this.sendServerRequest(\n      `/teams/${teamId}`,\n      {},\n      null\n    );\n    return await response.json();\n  }\n\n  async listServerTeamUsers(teamId: string): Promise<UsersCrud['Server']['Read'][]> {\n    const response = await this.sendServerRequest(`/users?team_id=${teamId}`, {}, null);\n    const result = await response.json() as UsersCrud['Server']['List'];\n    return result.items;\n  }\n\n  /* when passing a session, the user will be added to the team */\n  async createServerTeam(data: TeamsCrud['Server']['Create']): Promise<TeamsCrud['Server']['Read']> {\n    const response = await this.sendServerRequest(\n      \"/teams\",\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(data),\n      },\n      null\n    );\n    return await response.json();\n  }\n\n  async updateServerTeam(teamId: string, data: TeamsCrud['Server']['Update']): Promise<TeamsCrud['Server']['Read']> {\n    const response = await this.sendServerRequest(\n      urlString`/teams/${teamId}`,\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(data),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async deleteServerTeam(teamId: string): Promise<void> {\n    await this.sendServerRequest(\n      urlString`/teams/${teamId}`,\n      { method: \"DELETE\" },\n      null,\n    );\n  }\n\n  async addServerUserToTeam(options: {\n    userId: string,\n    teamId: string,\n  }): Promise<TeamMembershipsCrud['Server']['Read']> {\n    const response = await this.sendServerRequest(\n      urlString`/team-memberships/${options.teamId}/${options.userId}`,\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({}),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async removeServerUserFromTeam(options: {\n    userId: string,\n    teamId: string,\n  }) {\n    await this.sendServerRequest(\n      urlString`/team-memberships/${options.teamId}/${options.userId}`,\n      {\n        method: \"DELETE\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({}),\n      },\n      null,\n    );\n  }\n\n  async updateServerUser(userId: string, update: UsersCrud['Server']['Update']): Promise<UsersCrud['Server']['Read']> {\n    const response = await this.sendServerRequest(\n      urlString`/users/${userId}`,\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(update),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async createServerProviderAccessToken(\n    userId: string,\n    provider: string,\n    scope: string,\n  ): Promise<ConnectedAccountAccessTokenCrud['Server']['Read']> {\n    const response = await this.sendServerRequest(\n      urlString`/connected-accounts/${userId}/${provider}/access-token`,\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({ scope }),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async createServerUserSession(userId: string, expiresInMillis: number, isImpersonation: boolean): Promise<{ accessToken: string, refreshToken: string }> {\n    const response = await this.sendServerRequest(\n      \"/auth/sessions\",\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          user_id: userId,\n          expires_in_millis: expiresInMillis,\n          is_impersonation: isImpersonation,\n        }),\n      },\n      null,\n    );\n    const result = await response.json();\n    return {\n      accessToken: result.access_token,\n      refreshToken: result.refresh_token,\n    };\n  }\n\n  async leaveServerTeam(\n    options: {\n      teamId: string,\n      userId: string,\n    },\n  ) {\n    await this.sendClientRequest(\n      urlString`/team-memberships/${options.teamId}/${options.userId}`,\n      {\n        method: \"DELETE\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({}),\n      },\n      null,\n    );\n  }\n\n  async updateServerTeamMemberProfile(options: {\n    teamId: string,\n    userId: string,\n    profile: TeamMemberProfilesCrud['Server']['Update'],\n  }) {\n    await this.sendServerRequest(\n      urlString`/team-member-profiles/${options.teamId}/${options.userId}`,\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(options.profile),\n      },\n      null,\n    );\n  }\n\n  async grantServerTeamUserPermission(teamId: string, userId: string, permissionId: string) {\n    await this.sendServerRequest(\n      urlString`/team-permissions/${teamId}/${userId}/${permissionId}`,\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({}),\n      },\n      null,\n    );\n  }\n\n  async grantServerProjectPermission(userId: string, permissionId: string) {\n    await this.sendServerRequest(\n      urlString`/project-permissions/${userId}/${permissionId}`,\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({}),\n      },\n      null,\n    );\n  }\n\n  async revokeServerTeamUserPermission(teamId: string, userId: string, permissionId: string) {\n    await this.sendServerRequest(\n      urlString`/team-permissions/${teamId}/${userId}/${permissionId}`,\n      {\n        method: \"DELETE\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({}),\n      },\n      null,\n    );\n  }\n\n  async revokeServerProjectPermission(userId: string, permissionId: string) {\n    await this.sendServerRequest(\n      urlString`/project-permissions/${userId}/${permissionId}`,\n      {\n        method: \"DELETE\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({}),\n      },\n      null,\n    );\n  }\n\n  async deleteServerUser(userId: string) {\n    await this.sendServerRequest(\n      urlString`/users/${userId}`,\n      {\n        method: \"DELETE\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({}),\n      },\n      null,\n    );\n  }\n\n  async createServerContactChannel(\n    data: ContactChannelsCrud['Server']['Create'],\n  ): Promise<ContactChannelsCrud['Server']['Read']> {\n    const response = await this.sendServerRequest(\n      \"/contact-channels\",\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(data),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async updateServerContactChannel(\n    userId: string,\n    contactChannelId: string,\n    data: ContactChannelsCrud['Server']['Update'],\n  ): Promise<ContactChannelsCrud['Server']['Read']> {\n    const response = await this.sendServerRequest(\n      urlString`/contact-channels/${userId}/${contactChannelId}`,\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(data),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async deleteServerContactChannel(\n    userId: string,\n    contactChannelId: string,\n  ): Promise<void> {\n    await this.sendServerRequest(\n      urlString`/contact-channels/${userId}/${contactChannelId}`,\n      {\n        method: \"DELETE\",\n      },\n      null,\n    );\n  }\n\n  async listServerContactChannels(\n    userId: string,\n  ): Promise<ContactChannelsCrud['Server']['Read'][]> {\n    const response = await this.sendServerRequest(\n      urlString`/contact-channels?user_id=${userId}`,\n      {\n        method: \"GET\",\n      },\n      null,\n    );\n    const json = await response.json() as ContactChannelsCrud['Server']['List'];\n    return json.items;\n  }\n\n  async listServerNotificationCategories(\n    userId: string,\n  ): Promise<NotificationPreferenceCrud['Server']['Read'][]> {\n    const response = await this.sendServerRequest(\n      urlString`/emails/notification-preference/${userId}`,\n      {\n        method: \"GET\",\n      },\n      null,\n    );\n    const json = await response.json() as NotificationPreferenceCrud['Server']['List'];\n    return json.items;\n  }\n\n  async setServerNotificationsEnabled(\n    userId: string,\n    notificationCategoryId: string,\n    enabled: boolean,\n  ): Promise<void> {\n    await this.sendServerRequest(\n      urlString`/emails/notification-preference/${userId}/${notificationCategoryId}`,\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          enabled,\n        }),\n      },\n      null,\n    );\n  }\n\n  async sendServerContactChannelVerificationEmail(\n    userId: string,\n    contactChannelId: string,\n    callbackUrl: string,\n  ): Promise<void> {\n    await this.sendServerRequest(\n      urlString`/contact-channels/${userId}/${contactChannelId}/send-verification-code`,\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({ callback_url: callbackUrl }),\n      },\n      null,\n    );\n  }\n\n\n  async listServerSessions(userId: string): Promise<SessionsCrud['Server']['Read'][]> {\n    const response = await this.sendServerRequest(\n      urlString`/auth/sessions?user_id=${userId}`,\n      {\n        method: \"GET\",\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async deleteServerSession(sessionId: string) {\n    await this.sendServerRequest(\n      urlString`/auth/sessions/${sessionId}`,\n      {\n        method: \"DELETE\",\n      },\n      null,\n    );\n  }\n\n\n  async sendServerTeamInvitation(options: {\n    email: string,\n    teamId: string,\n    callbackUrl: string,\n  }): Promise<void> {\n    await this.sendServerRequest(\n      \"/team-invitations/send-code\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          email: options.email,\n          team_id: options.teamId,\n          callback_url: options.callbackUrl,\n        }),\n      },\n      null,\n    );\n  }\n\n  async updatePassword(\n    options: { oldPassword: string, newPassword: string },\n  ): Promise<KnownErrors[\"PasswordConfirmationMismatch\"] | KnownErrors[\"PasswordRequirementsNotMet\"] | undefined> {\n    const res = await this.sendServerRequestAndCatchKnownError(\n      \"/auth/password/update\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          old_password: options.oldPassword,\n          new_password: options.newPassword,\n        }),\n      },\n      null,\n      [KnownErrors.PasswordConfirmationMismatch, KnownErrors.PasswordRequirementsNotMet]\n    );\n\n    if (res.status === \"error\") {\n      return res.error;\n    }\n  }\n\n  // OAuth Providers CRUD operations\n  async createServerOAuthProvider(\n    data: OAuthProviderCrud['Server']['Create'],\n  ): Promise<OAuthProviderCrud['Server']['Read']> {\n    const response = await this.sendServerRequest(\n      \"/oauth-providers\",\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(data),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n\n  async listServerOAuthProviders(\n    options: {\n      user_id?: string,\n    } = {},\n  ): Promise<OAuthProviderCrud['Server']['Read'][]> {\n    const queryParams = new URLSearchParams(filterUndefined(options));\n    const response = await this.sendServerRequest(\n      `/oauth-providers${queryParams.toString() ? `?${queryParams.toString()}` : ''}`,\n      {\n        method: \"GET\",\n      },\n      null,\n    );\n    const result = await response.json();\n    return result.items;\n  }\n\n  async updateServerOAuthProvider(\n    userId: string,\n    providerId: string,\n    data: OAuthProviderCrud['Server']['Update'],\n  ): Promise<OAuthProviderCrud['Server']['Read']> {\n    const response = await this.sendServerRequest(\n      urlString`/oauth-providers/${userId}/${providerId}`,\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(data),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async deleteServerOAuthProvider(\n    userId: string,\n    providerId: string,\n  ): Promise<void> {\n    const response = await this.sendServerRequest(\n      urlString`/oauth-providers/${userId}/${providerId}`,\n      {\n        method: \"DELETE\",\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async sendEmail(options: {\n    userIds?: string[],\n    allUsers?: true,\n    themeId?: string | null | false,\n    html?: string,\n    subject?: string,\n    notificationCategoryName?: string,\n    templateId?: string,\n    variables?: Record<string, any>,\n    draftId?: string,\n  }): Promise<Result<void, KnownErrors[\"RequiresCustomEmailServer\"] | KnownErrors[\"SchemaError\"] | KnownErrors[\"UserIdDoesNotExist\"]>> {\n    const res = await this.sendServerRequest(\n      \"/emails/send-email\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          user_ids: options.userIds,\n          all_users: options.allUsers,\n          theme_id: options.themeId,\n          html: options.html,\n          subject: options.subject,\n          notification_category_name: options.notificationCategoryName,\n          template_id: options.templateId,\n          variables: options.variables,\n          draft_id: options.draftId,\n        }),\n      },\n      null,\n    );\n    return Result.ok(undefined);\n  }\n\n  async updateItemQuantity(\n    options: (\n      { itemId: string, userId: string } |\n      { itemId: string, teamId: string } |\n      { itemId: string, customCustomerId: string }\n    ),\n    data: ItemCrud['Server']['Update'],\n  ): Promise<void> {\n    let customerType: \"user\" | \"team\" | \"custom\";\n    let customerId: string;\n    const itemId: string = options.itemId;\n\n    if (\"userId\" in options) {\n      customerType = \"user\";\n      customerId = options.userId;\n    } else if (\"teamId\" in options) {\n      customerType = \"team\";\n      customerId = options.teamId;\n    } else if (\"customCustomerId\" in options) {\n      customerType = \"custom\";\n      customerId = options.customCustomerId;\n    } else {\n      throw new StackAssertionError(\"updateItemQuantity requires one of userId, teamId, or customCustomerId\");\n    }\n\n    const queryParams = new URLSearchParams({ allow_negative: (data.allow_negative ?? false).toString() });\n    await this.sendServerRequest(\n      `/payments/items/${customerType}/${customerId}/${itemId}/update-quantity?${queryParams.toString()}`,\n      {\n        method: \"POST\",\n        headers: { \"content-type\": \"application/json\" },\n        body: JSON.stringify({ delta: data.delta, expires_at: data.expires_at, description: data.description }),\n      },\n      null\n    );\n  }\n\n  async grantProduct(\n    options: {\n      customerType: \"user\" | \"team\" | \"custom\",\n      customerId: string,\n      productId?: string,\n      product?: yup.InferType<typeof inlineProductSchema>,\n      quantity?: number,\n    },\n  ): Promise<void> {\n    if (!options.productId && !options.product) {\n      throw new StackAssertionError(\"grantProduct requires either productId or product\");\n    }\n    if (options.productId && options.product) {\n      throw new StackAssertionError(\"grantProduct should not receive both productId and product\");\n    }\n    const body = filterUndefined({\n      product_id: options.productId,\n      product_inline: options.product,\n      quantity: options.quantity,\n    });\n    await this.sendServerRequest(\n      urlString`/payments/products/${options.customerType}/${options.customerId}`,\n      {\n        method: \"POST\",\n        headers: { \"content-type\": \"application/json\" },\n        body: JSON.stringify(body),\n      },\n      null,\n    );\n  }\n\n  async getDataVaultStoreValue(secret: string, storeId: string, key: string) {\n    const hashedKey = await hashKey(secret, key);\n    const response = await this.sendServerRequestAndCatchKnownError(\n      `/data-vault/stores/${storeId}/get`,\n      {\n        method: \"POST\",\n        headers: { \"content-type\": \"application/json\" },\n        body: JSON.stringify({ hashed_key: hashedKey }),\n      },\n      null,\n      [KnownErrors.DataVaultStoreHashedKeyDoesNotExist] as const,\n    );\n    if (response.status === \"error\") {\n      if (KnownErrors.DataVaultStoreHashedKeyDoesNotExist.isInstance(response.error)) {\n        return null;\n      } else {\n        throw new StackAssertionError(\"Unexpected uncaught error\", { cause: response.error });\n      }\n    }\n    const json = await response.data.json();\n    const encryptedValue = json.encrypted_value;\n    if (typeof encryptedValue !== \"string\") throw new StackAssertionError(\"encrypted_value is not a string\", { type: typeof encryptedValue });\n    return await decryptValue(secret, key, encryptedValue);\n  }\n\n  async setDataVaultStoreValue(secret: string, storeId: string, key: string, value: string) {\n    const hashedKey = await hashKey(secret, key);\n    const encryptedValue = await encryptValue(secret, key, value);\n    await this.sendServerRequest(\n      `/data-vault/stores/${storeId}/set`,\n      {\n        method: \"POST\",\n        headers: { \"content-type\": \"application/json\" },\n        body: JSON.stringify({ hashed_key: hashedKey, encrypted_value: encryptedValue }),\n      },\n      null,\n    );\n  }\n\n  async initiateServerPasskeyRegistration(userId: string): Promise<Result<{ options_json: any, code: string }, KnownErrors[]>> {\n    // Create a temporary session for this user to use for passkey registration\n    // TODO instead of creating a new session, this should just call the endpoint in a way in which it doesn't require a session\n    // (currently this shows up on session history etc... not ideal)\n    const { accessToken, refreshToken } = await this.createServerUserSession(userId, 60000 * 2, false); // 2 minute session\n    const tempSession = new InternalSession({\n      accessToken,\n      refreshToken,\n      refreshAccessTokenCallback: async () => null, // No refresh for temporary sessions\n    });\n\n    // Use the existing initiatePasskeyRegistration method with the temporary session\n    return await this.initiatePasskeyRegistration({}, tempSession);\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 7449, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack-shared/src/interface/admin-interface.ts"],"sourcesContent":["import { KnownErrors } from \"../known-errors\";\nimport { AccessToken, InternalSession, RefreshToken } from \"../sessions\";\nimport { Result } from \"../utils/results\";\nimport { ConfigCrud, ConfigOverrideCrud } from \"./crud/config\";\nimport { InternalEmailsCrud } from \"./crud/emails\";\nimport { InternalApiKeysCrud } from \"./crud/internal-api-keys\";\nimport { ProjectPermissionDefinitionsCrud } from \"./crud/project-permissions\";\nimport { ProjectsCrud } from \"./crud/projects\";\nimport { SvixTokenCrud } from \"./crud/svix-token\";\nimport { TeamPermissionDefinitionsCrud } from \"./crud/team-permissions\";\nimport type { Transaction, TransactionType } from \"./crud/transactions\";\nimport { ServerAuthApplicationOptions, StackServerInterface } from \"./server-interface\";\n\n\nexport type ChatContent = Array<\n  | { type: \"text\", text: string }\n  | { type: \"tool-call\", toolName: string, toolCallId: string, args: any, argsText: string, result: any }\n>;\n\nexport type AdminAuthApplicationOptions = ServerAuthApplicationOptions &(\n  | {\n    superSecretAdminKey: string,\n  }\n  | {\n    projectOwnerSession: InternalSession,\n  }\n);\n\nexport type InternalApiKeyCreateCrudRequest = {\n  has_publishable_client_key: boolean,\n  has_secret_server_key: boolean,\n  has_super_secret_admin_key: boolean,\n  expires_at_millis: number,\n  description: string,\n};\n\nexport type InternalApiKeyCreateCrudResponse = InternalApiKeysCrud[\"Admin\"][\"Read\"] & {\n  publishable_client_key?: string,\n  secret_server_key?: string,\n  super_secret_admin_key?: string,\n};\n\nexport class StackAdminInterface extends StackServerInterface {\n  constructor(public readonly options: AdminAuthApplicationOptions) {\n    super(options);\n  }\n\n  public async sendAdminRequest(path: string, options: RequestInit, session: InternalSession | null, requestType: \"admin\" = \"admin\") {\n    return await this.sendServerRequest(\n      path,\n      {\n        ...options,\n        headers: {\n          \"x-stack-super-secret-admin-key\": \"superSecretAdminKey\" in this.options ? this.options.superSecretAdminKey : \"\",\n          ...options.headers,\n        },\n      },\n      session,\n      requestType,\n    );\n  }\n\n  protected async sendAdminRequestAndCatchKnownError<E extends typeof KnownErrors[keyof KnownErrors]>(\n    path: string,\n    requestOptions: RequestInit,\n    tokenStoreOrNull: InternalSession | null,\n    errorsToCatch: readonly E[],\n  ): Promise<Result<\n    Response & {\n      usedTokens: {\n        accessToken: AccessToken,\n        refreshToken: RefreshToken | null,\n      } | null,\n    },\n    InstanceType<E>\n  >> {\n    try {\n      return Result.ok(await this.sendAdminRequest(path, requestOptions, tokenStoreOrNull));\n    } catch (e) {\n      for (const errorType of errorsToCatch) {\n        if (errorType.isInstance(e)) {\n          return Result.error(e as InstanceType<E>);\n        }\n      }\n      throw e;\n    }\n  }\n\n  async getProject(): Promise<ProjectsCrud[\"Admin\"][\"Read\"]> {\n    const response = await this.sendAdminRequest(\n      \"/internal/projects/current\",\n      {\n        method: \"GET\",\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async updateProject(update: ProjectsCrud[\"Admin\"][\"Update\"]): Promise<ProjectsCrud[\"Admin\"][\"Read\"]> {\n    const response = await this.sendAdminRequest(\n      \"/internal/projects/current\",\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(update),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async createInternalApiKey(\n    options: InternalApiKeyCreateCrudRequest,\n  ): Promise<InternalApiKeyCreateCrudResponse> {\n    const response = await this.sendAdminRequest(\n      \"/internal/api-keys\",\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(options),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async listInternalApiKeys(): Promise<InternalApiKeysCrud[\"Admin\"][\"Read\"][]> {\n    const response = await this.sendAdminRequest(\"/internal/api-keys\", {}, null);\n    const result = await response.json() as InternalApiKeysCrud[\"Admin\"][\"List\"];\n    return result.items;\n  }\n\n  async revokeInternalApiKeyById(id: string) {\n    await this.sendAdminRequest(\n      `/internal/api-keys/${id}`, {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          revoked: true,\n        }),\n      },\n      null,\n    );\n  }\n\n  async getInternalApiKey(id: string, session: InternalSession): Promise<InternalApiKeysCrud[\"Admin\"][\"Read\"]> {\n    const response = await this.sendAdminRequest(`/internal/api-keys/${id}`, {}, session);\n    return await response.json();\n  }\n\n  async listInternalEmailTemplates(): Promise<{ id: string, display_name: string, theme_id?: string, tsx_source: string }[]> {\n    const response = await this.sendAdminRequest(`/internal/email-templates`, {}, null);\n    const result = await response.json() as { templates: { id: string, display_name: string, theme_id?: string, tsx_source: string }[] };\n    return result.templates;\n  }\n\n  async listInternalEmailDrafts(): Promise<{ id: string, display_name: string, theme_id?: string | undefined | false, tsx_source: string, sent_at_millis?: number | null }[]> {\n    const response = await this.sendAdminRequest(`/internal/email-drafts`, {}, null);\n    const result = await response.json() as { drafts: { id: string, display_name: string, theme_id?: string | undefined | false, tsx_source: string, sent_at_millis?: number | null }[] };\n    return result.drafts;\n  }\n\n  async createEmailDraft(options: { display_name?: string, theme_id?: string | false, tsx_source?: string }): Promise<{ id: string }> {\n    const response = await this.sendAdminRequest(\n      `/internal/email-drafts`,\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(options),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async updateEmailDraft(id: string, data: { display_name?: string, theme_id?: string | null | false, tsx_source?: string, sent_at_millis?: number | null }): Promise<void> {\n    await this.sendAdminRequest(\n      `/internal/email-drafts/${id}`,\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(data),\n      },\n      null,\n    );\n  }\n\n  async listEmailThemes(): Promise<{ id: string, display_name: string }[]> {\n    const response = await this.sendAdminRequest(`/internal/email-themes`, {}, null);\n    const result = await response.json() as { themes: { id: string, display_name: string }[] };\n    return result.themes;\n  }\n\n\n  // Team permission definitions methods\n  async listTeamPermissionDefinitions(): Promise<TeamPermissionDefinitionsCrud['Admin']['Read'][]> {\n    const response = await this.sendAdminRequest(`/team-permission-definitions`, {}, null);\n    const result = await response.json() as TeamPermissionDefinitionsCrud['Admin']['List'];\n    return result.items;\n  }\n\n  async createTeamPermissionDefinition(data: TeamPermissionDefinitionsCrud['Admin']['Create']): Promise<TeamPermissionDefinitionsCrud['Admin']['Read']> {\n    const response = await this.sendAdminRequest(\n      \"/team-permission-definitions\",\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(data),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async updateTeamPermissionDefinition(permissionId: string, data: TeamPermissionDefinitionsCrud['Admin']['Update']): Promise<TeamPermissionDefinitionsCrud['Admin']['Read']> {\n    const response = await this.sendAdminRequest(\n      `/team-permission-definitions/${permissionId}`,\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(data),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async deleteTeamPermissionDefinition(permissionId: string): Promise<void> {\n    await this.sendAdminRequest(\n      `/team-permission-definitions/${permissionId}`,\n      { method: \"DELETE\" },\n      null,\n    );\n  }\n\n  async listProjectPermissionDefinitions(): Promise<ProjectPermissionDefinitionsCrud['Admin']['Read'][]> {\n    const response = await this.sendAdminRequest(`/project-permission-definitions`, {}, null);\n    const result = await response.json() as ProjectPermissionDefinitionsCrud['Admin']['List'];\n    return result.items;\n  }\n\n  async createProjectPermissionDefinition(data: ProjectPermissionDefinitionsCrud['Admin']['Create']): Promise<ProjectPermissionDefinitionsCrud['Admin']['Read']> {\n    const response = await this.sendAdminRequest(\n      \"/project-permission-definitions\",\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(data),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async updateProjectPermissionDefinition(permissionId: string, data: ProjectPermissionDefinitionsCrud['Admin']['Update']): Promise<ProjectPermissionDefinitionsCrud['Admin']['Read']> {\n    const response = await this.sendAdminRequest(\n      `/project-permission-definitions/${permissionId}`,\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(data),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async deleteProjectPermissionDefinition(permissionId: string): Promise<void> {\n    await this.sendAdminRequest(\n      `/project-permission-definitions/${permissionId}`,\n      { method: \"DELETE\" },\n      null,\n    );\n  }\n\n  async getSvixToken(): Promise<SvixTokenCrud[\"Admin\"][\"Read\"]> {\n    const response = await this.sendAdminRequest(\n      \"/webhooks/svix-token\",\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({}),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async deleteProject(): Promise<void> {\n    await this.sendAdminRequest(\n      \"/internal/projects/current\",\n      {\n        method: \"DELETE\",\n      },\n      null,\n    );\n  }\n\n  async getMetrics(includeAnonymous: boolean = false): Promise<any> {\n    const params = new URLSearchParams();\n    if (includeAnonymous) {\n      params.append('include_anonymous', 'true');\n    }\n    const queryString = params.toString();\n    const response = await this.sendAdminRequest(\n      `/internal/metrics${queryString ? `?${queryString}` : ''}`,\n      {\n        method: \"GET\",\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async sendTestEmail(data: {\n    recipient_email: string,\n    email_config: {\n      host: string,\n      port: number,\n      username: string,\n      password: string,\n      sender_email: string,\n      sender_name: string,\n    },\n  }): Promise<{ success: boolean, error_message?: string }> {\n    const response = await this.sendAdminRequest(`/internal/send-test-email`, {\n      method: \"POST\",\n      headers: {\n        \"content-type\": \"application/json\",\n      },\n      body: JSON.stringify(data),\n    }, null);\n    return await response.json();\n  }\n\n  async sendTestWebhook(data: {\n    endpoint_id: string,\n  }): Promise<{ success: boolean, error_message?: string }> {\n    const response = await this.sendAdminRequest(`/internal/send-test-webhook`, {\n      method: \"POST\",\n      headers: {\n        \"content-type\": \"application/json\",\n      },\n      body: JSON.stringify(data),\n    }, null);\n    return await response.json();\n  }\n\n  async listSentEmails(): Promise<InternalEmailsCrud[\"Admin\"][\"List\"]> {\n    const response = await this.sendAdminRequest(\"/internal/emails\", {\n      method: \"GET\",\n    }, null);\n    return await response.json();\n  }\n\n  async sendSignInInvitationEmail(\n    email: string,\n    callbackUrl: string,\n  ): Promise<void> {\n    await this.sendAdminRequest(\n      \"/internal/send-sign-in-invitation\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          email,\n          callback_url: callbackUrl,\n        }),\n      },\n      null,\n    );\n  }\n\n\n  async sendChatMessage(\n    threadId: string,\n    contextType: \"email-theme\" | \"email-template\" | \"email-draft\",\n    messages: Array<{ role: string, content: any }>,\n    abortSignal?: AbortSignal,\n  ): Promise<{ content: ChatContent }> {\n    const response = await this.sendAdminRequest(\n      `/internal/ai-chat/${threadId}`,\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({ context_type: contextType, messages }),\n        signal: abortSignal,\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async saveChatMessage(threadId: string, message: any): Promise<void> {\n    await this.sendAdminRequest(\n      `/internal/ai-chat/${threadId}`,\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({ message }),\n      },\n      null,\n    );\n  }\n\n  async listChatMessages(threadId: string): Promise<{ messages: Array<any> }> {\n    const response = await this.sendAdminRequest(\n      `/internal/ai-chat/${threadId}`,\n      { method: \"GET\" },\n      null,\n    );\n    return await response.json();\n  }\n\n  async renderEmailPreview(options: { themeId?: string | null | false, themeTsxSource?: string, templateId?: string, templateTsxSource?: string }): Promise<{ html: string }> {\n    const response = await this.sendAdminRequest(`/emails/render-email`, {\n      method: \"POST\",\n      headers: {\n        \"content-type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        theme_id: options.themeId,\n        theme_tsx_source: options.themeTsxSource,\n        template_id: options.templateId,\n        template_tsx_source: options.templateTsxSource,\n      }),\n    }, null);\n    return await response.json();\n  }\n\n  async createEmailTheme(displayName: string): Promise<{ id: string }> {\n    const response = await this.sendAdminRequest(\n      `/internal/email-themes`,\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          display_name: displayName,\n        }),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async getEmailTheme(id: string): Promise<{ display_name: string, tsx_source: string }> {\n    const response = await this.sendAdminRequest(\n      `/internal/email-themes/${id}`,\n      { method: \"GET\" },\n      null,\n    );\n    return await response.json();\n  }\n\n  async updateEmailTheme(id: string, tsxSource: string): Promise<void> {\n    await this.sendAdminRequest(\n      `/internal/email-themes/${id}`,\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          tsx_source: tsxSource,\n        }),\n      },\n      null,\n    );\n  }\n\n  async updateEmailTemplate(id: string, tsxSource: string, themeId: string | null | false): Promise<{ rendered_html: string }> {\n    const response = await this.sendAdminRequest(\n      `/internal/email-templates/${id}`,\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({ tsx_source: tsxSource, theme_id: themeId }),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async getConfig(): Promise<ConfigCrud[\"Admin\"][\"Read\"]> {\n    const response = await this.sendAdminRequest(\n      `/internal/config`,\n      { method: \"GET\" },\n      null,\n    );\n    return await response.json();\n  }\n\n  async updateConfig(data: { configOverride: any }): Promise<ConfigOverrideCrud[\"Admin\"][\"Read\"]> {\n    const response = await this.sendAdminRequest(\n      `/internal/config/override`,\n      {\n        method: \"PATCH\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({ config_override_string: JSON.stringify(data.configOverride) }),\n      },\n      null,\n    );\n    return await response.json();\n  }\n  async createEmailTemplate(displayName: string): Promise<{ id: string }> {\n    const response = await this.sendAdminRequest(\n      `/internal/email-templates`,\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          display_name: displayName,\n        }),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async setupPayments(): Promise<{ url: string }> {\n    const response = await this.sendAdminRequest(\n      \"/internal/payments/setup\",\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({}),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async getStripeAccountInfo(): Promise<null | { account_id: string, charges_enabled: boolean, details_submitted: boolean, payouts_enabled: boolean }> {\n    const response = await this.sendAdminRequestAndCatchKnownError(\n      \"/internal/payments/stripe/account-info\",\n      {},\n      null,\n      [KnownErrors.StripeAccountInfoNotFound],\n    );\n    if (response.status === \"error\") {\n      return null;\n    }\n    return await response.data.json();\n  }\n\n  async createStripeWidgetAccountSession(): Promise<{ client_secret: string }> {\n    const response = await this.sendAdminRequest(\n      \"/internal/payments/stripe-widgets/account-session\",\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify({}),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n  async listTransactions(params?: { cursor?: string, limit?: number, type?: TransactionType, customerType?: 'user' | 'team' | 'custom' }): Promise<{ transactions: Transaction[], nextCursor: string | null }> {\n    const qs = new URLSearchParams();\n    if (params?.cursor) qs.set('cursor', params.cursor);\n    if (typeof params?.limit === 'number') qs.set('limit', String(params.limit));\n    if (params?.type) qs.set('type', params.type);\n    if (params?.customerType) qs.set('customer_type', params.customerType);\n    const response = await this.sendAdminRequest(\n      `/internal/payments/transactions${qs.size ? `?${qs.toString()}` : ''}`,\n      { method: 'GET' },\n      null,\n    );\n    const json = await response.json() as { transactions: Transaction[], next_cursor: string | null };\n    return { transactions: json.transactions, nextCursor: json.next_cursor };\n  }\n\n  async refundTransaction(options: { type: \"subscription\" | \"one-time-purchase\", id: string }): Promise<{ success: boolean }> {\n    const response = await this.sendAdminRequest(\n      \"/internal/payments/transactions/refund\",\n      {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n        },\n        body: JSON.stringify(options),\n      },\n      null,\n    );\n    return await response.json();\n  }\n\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 7870, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack-shared/src/index.ts"],"sourcesContent":["// Note: UI components (AppIcon, etc.) are exported via ./dist/apps/apps-ui\n// They are not re-exported here to avoid requiring React for non-UI consumers\n\nexport {\n  StackAdminInterface\n} from \"./interface/admin-interface\";\nexport {\n  StackClientInterface\n} from \"./interface/client-interface\";\nexport {\n  StackServerInterface\n} from \"./interface/server-interface\";\nexport {\n  KnownError,\n  KnownErrors\n} from \"./known-errors\";\n\n"],"names":[],"mappings":";;AAGA;AAGA;AAGA;AAGA"}},
    {"offset": {"line": 7886, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack-shared/src/helpers/production-mode.ts"],"sourcesContent":["import { ProjectsCrud } from \"../interface/crud/projects\";\nimport { StackAssertionError, captureError } from \"../utils/errors\";\nimport { isLocalhost } from \"../utils/urls\";\n\nexport type ProductionModeError = {\n  message: string,\n  relativeFixUrl: `/${string}`,\n};\n\nexport function getProductionModeErrors(project: ProjectsCrud[\"Admin\"][\"Read\"]): ProductionModeError[] {\n  const errors: ProductionModeError[] = [];\n  const domainsFixUrl = `/projects/${project.id}/domains` as const;\n\n  if (project.config.allow_localhost) {\n    errors.push({\n      message: \"Localhost is not allowed in production mode, turn off 'Allow localhost' in project settings\",\n      relativeFixUrl: domainsFixUrl,\n    });\n  }\n\n  for (const { domain } of project.config.domains) {\n    let url;\n    try {\n      // For wildcard domains, replace wildcards with a valid placeholder to validate the URL structure\n      const normalizedDomain = domain.replace(/\\*+/g, 'wildcard-placeholder');\n      url = new URL(normalizedDomain);\n    } catch (e) {\n      captureError(\"production-mode-domain-not-valid\", new StackAssertionError(\"Domain was somehow not a valid URL; we should've caught this when setting the domain in the first place\", {\n        domain,\n        projectId: project\n      }));\n      errors.push({\n        message: \"Trusted domain is not a valid URL: \" + domain,\n        relativeFixUrl: domainsFixUrl,\n      });\n      continue;\n    }\n\n    if (isLocalhost(url)) {\n      errors.push({\n        message: \"Localhost domains are not allowed to be trusted in production mode: \" + domain,\n        relativeFixUrl: domainsFixUrl,\n      });\n    } else if (url.hostname.match(/^\\d+(\\.\\d+)*$/)) {\n      errors.push({\n        message: \"Direct IPs are not valid for trusted domains in production mode: \" + domain,\n        relativeFixUrl: domainsFixUrl,\n      });\n    } else if (url.protocol !== \"https:\") {\n      errors.push({\n        message: \"Trusted domains should be HTTPS: \" + domain,\n        relativeFixUrl: domainsFixUrl,\n      });\n    }\n  }\n\n  return errors;\n}\n"],"names":[],"mappings":";;;;;AACA,SAAS,qBAAqB,oBAAoB;AAClD,SAAS,mBAAmB;;;AAOrB,SAAS,wBAAwB,OAAA,EAA+D;IACrG,MAAM,SAAgC,CAAC,CAAA;IACvC,MAAM,gBAAgB,CAAA,UAAA,EAAa,QAAQ,EAAE,CAAA,QAAA,CAAA;IAE7C,IAAI,QAAQ,MAAA,CAAO,eAAA,EAAiB;QAClC,OAAO,IAAA,CAAK;YACV,SAAS;YACT,gBAAgB;QAClB,CAAC;IACH;IAEA,KAAA,MAAW,EAAE,MAAA,CAAO,CAAA,IAAK,QAAQ,MAAA,CAAO,OAAA,CAAS;QAC/C,IAAI;QACJ,IAAI;YAEF,MAAM,mBAAmB,OAAO,OAAA,CAAQ,QAAQ,sBAAsB;YACtE,MAAM,IAAI,IAAI,gBAAgB;QAChC,EAAA,OAAS,GAAG;YACV,IAAA,wOAAA,EAAa,oCAAoC,IAAI,+OAAA,CAAoB,2GAA2G;gBAClL;gBACA,WAAW;YACb,CAAC,CAAC;YACF,OAAO,IAAA,CAAK;gBACV,SAAS,wCAAwC;gBACjD,gBAAgB;YAClB,CAAC;YACD;QACF;QAEA,QAAI,qOAAA,EAAY,GAAG,GAAG;YACpB,OAAO,IAAA,CAAK;gBACV,SAAS,yEAAyE;gBAClF,gBAAgB;YAClB,CAAC;QACH,OAAA,IAAW,IAAI,QAAA,CAAS,KAAA,CAAM,eAAe,GAAG;YAC9C,OAAO,IAAA,CAAK;gBACV,SAAS,sEAAsE;gBAC/E,gBAAgB;YAClB,CAAC;QACH,OAAA,IAAW,IAAI,QAAA,KAAa,UAAU;YACpC,OAAO,IAAA,CAAK;gBACV,SAAS,sCAAsC;gBAC/C,gBAAgB;YAClB,CAAC;QACH;IACF;IAEA,OAAO;AACT"}},
    {"offset": {"line": 7945, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack-shared/src/utils/env.tsx"],"sourcesContent":["import { throwErr } from \"./errors\";\nimport { deindent } from \"./strings\";\n\nexport function isBrowserLike() {\n  return typeof window !== \"undefined\" && typeof document !== \"undefined\" && typeof document.createElement !== \"undefined\";\n}\n\n// newName: oldName\nconst ENV_VAR_RENAME: Record<string, string[]> = {\n  NEXT_PUBLIC_STACK_API_URL: ['STACK_BASE_URL', 'NEXT_PUBLIC_STACK_URL'],\n};\n\n/**\n * Returns the environment variable with the given name, returning the default (if given) or throwing an error (otherwise) if it's undefined or the empty string.\n */\nexport function getEnvVariable(name: string, defaultValue?: string | undefined): string {\n  if (isBrowserLike()) {\n    throw new Error(deindent`\n      Can't use getEnvVariable on the client because Next.js transpiles expressions of the kind process.env.XYZ at build-time on the client.\n    \n      Use process.env.XYZ directly instead.\n    `);\n  }\n  if (name === \"NEXT_RUNTIME\") {\n    throw new Error(deindent`\n      Can't use getEnvVariable to access the NEXT_RUNTIME environment variable because it's compiled into the client bundle.\n    \n      Use getNextRuntime() instead.\n    `);\n  }\n\n  // throw error if the old name is used as the retrieve key\n  for (const [newName, oldNames] of Object.entries(ENV_VAR_RENAME)) {\n    if (oldNames.includes(name)) {\n      throwErr(`Environment variable ${name} has been renamed to ${newName}. Please update your configuration to use the new name.`);\n    }\n  }\n\n  let value = process.env[name];\n\n  // check the key under the old name if the new name is not found\n  if (!value && ENV_VAR_RENAME[name] as any) {\n    for (const oldName of ENV_VAR_RENAME[name]) {\n      value = process.env[oldName];\n      if (value) break;\n    }\n  }\n\n  if (value === undefined) {\n    if (defaultValue !== undefined) {\n      value = defaultValue;\n    } else {\n      throwErr(`Missing environment variable: ${name}`);\n    }\n  }\n\n  return value;\n}\n\nexport function getNextRuntime() {\n  // This variable is compiled into the client bundle, so we can't use getEnvVariable here.\n  return process.env.NEXT_RUNTIME || throwErr(\"Missing environment variable: NEXT_RUNTIME\");\n}\n\nexport function getNodeEnvironment() {\n  return getEnvVariable(\"NODE_ENV\", \"\");\n}\n"],"names":[],"mappings":";;;;;;;;;;;AAsCc;AAtCd,SAAS,gBAAgB;AACzB,SAAS,gBAAgB;;;AAElB,SAAS,gBAAgB;IAC9B,OAAO,OAAO,WAAW,eAAe,OAAO,aAAa,eAAe,OAAO,SAAS,aAAA,KAAkB;AAC/G;AAGA,IAAM,iBAA2C;IAC/C,2BAA2B;QAAC;QAAkB,uBAAuB;KAAA;AACvE;AAKO,SAAS,eAAe,IAAA,EAAc,YAAA,EAA2C;IACtF,IAAI,cAAc,GAAG;QACnB,MAAM,IAAI,MAAM,qOAAA,CAAA;;;;IAAA,CAIf;IACH;IACA,IAAI,SAAS,gBAAgB;QAC3B,MAAM,IAAI,MAAM,qOAAA,CAAA;;;;IAAA,CAIf;IACH;IAGA,KAAA,MAAW,CAAC,SAAS,QAAQ,CAAA,IAAK,OAAO,OAAA,CAAQ,cAAc,EAAG;QAChE,IAAI,SAAS,QAAA,CAAS,IAAI,GAAG;YAC3B,IAAA,oOAAA,EAAS,CAAA,qBAAA,EAAwB,IAAI,CAAA,qBAAA,EAAwB,OAAO,CAAA,uDAAA,CAAyD;QAC/H;IACF;IAEA,IAAI,uNAAQ,CAAQ,GAAA,CAAI,IAAI,CAAA;IAG5B,IAAI,CAAC,SAAS,cAAA,CAAe,IAAI,CAAA,EAAU;QACzC,KAAA,MAAW,WAAW,cAAA,CAAe,IAAI,CAAA,CAAG;YAC1C,QAAQ,+MAAA,CAAQ,GAAA,CAAI,OAAO,CAAA;YAC3B,IAAI,MAAO,CAAA;QACb;IACF;IAEA,IAAI,UAAU,KAAA,GAAW;QACvB,IAAI,iBAAiB,KAAA,GAAW;YAC9B,QAAQ;QACV,OAAO;YACL,IAAA,oOAAA,EAAS,CAAA,8BAAA,EAAiC,IAAI,EAAE;QAClD;IACF;IAEA,OAAO;AACT;AAEO,SAAS,iBAAiB;IAE/B,OAAO,QAAQ,IAAI,gCAAgB,oOAAA,EAAS,4CAA4C;AAC1F;AAEO,SAAS,qBAAqB;IACnC,OAAO,eAAe,YAAY,EAAE;AACtC"}},
    {"offset": {"line": 8018, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack-shared/src/utils/caches.tsx"],"sourcesContent":["import { isBrowserLike } from \"./env\";\nimport { DependenciesMap } from \"./maps\";\nimport { filterUndefined } from \"./objects\";\nimport { RateLimitOptions, ReactPromise, pending, rateLimited, resolved, runAsynchronously, wait } from \"./promises\";\nimport { AsyncStore } from \"./stores\";\n\n/**\n * Can be used to cache the result of a function call, for example for the `use` hook in React.\n */\nexport function cacheFunction<F extends Function>(f: F): F {\n  const dependenciesMap = new DependenciesMap<any, any>();\n\n  return ((...args: any) => {\n    if (dependenciesMap.has(args)) {\n      return dependenciesMap.get(args);\n    }\n\n    const value = f(...args);\n    dependenciesMap.set(args, value);\n    return value;\n  }) as any as F;\n}\nundefined?.test(\"cacheFunction\", ({ expect }) => {\n  // Test with a simple function\n  let callCount = 0;\n  const add = (a: number, b: number) => {\n    callCount++;\n    return a + b;\n  };\n\n  const cachedAdd = cacheFunction(add);\n\n  // First call should execute the function\n  expect(cachedAdd(1, 2)).toBe(3);\n  expect(callCount).toBe(1);\n\n  // Second call with same args should use cached result\n  expect(cachedAdd(1, 2)).toBe(3);\n  expect(callCount).toBe(1);\n\n  // Call with different args should execute the function again\n  expect(cachedAdd(2, 3)).toBe(5);\n  expect(callCount).toBe(2);\n\n  // Test with a function that returns objects\n  let objectCallCount = 0;\n  const createObject = (id: number) => {\n    objectCallCount++;\n    return { id };\n  };\n\n  const cachedCreateObject = cacheFunction(createObject);\n\n  // First call should execute the function\n  const obj1 = cachedCreateObject(1);\n  expect(obj1).toEqual({ id: 1 });\n  expect(objectCallCount).toBe(1);\n\n  // Second call with same args should use cached result\n  const obj2 = cachedCreateObject(1);\n  expect(obj2).toBe(obj1); // Same reference\n  expect(objectCallCount).toBe(1);\n});\n\n\ntype CacheStrategy = \"write-only\" | \"read-write\" | \"never\";\n\nexport class AsyncCache<D extends any[], T> {\n  private readonly _map = new DependenciesMap<D, AsyncValueCache<T>>();\n\n  constructor(\n    private readonly _fetcher: (dependencies: D) => Promise<T>,\n    private readonly _options: {\n      onSubscribe?: (key: D, refresh: () => void) => (() => void),\n      rateLimiter?: Omit<RateLimitOptions, \"batchCalls\">,\n    } = {},\n  ) {\n    // nothing here yet\n  }\n\n  private _createKeyed<FunctionName extends keyof AsyncValueCache<T>>(\n    functionName: FunctionName,\n  ): (key: D, ...args: Parameters<AsyncValueCache<T>[FunctionName]>) => ReturnType<AsyncValueCache<T>[FunctionName]> {\n    return (key: D, ...args) => {\n      const valueCache = this.getValueCache(key);\n      return (valueCache[functionName] as any).apply(valueCache, args);\n    };\n  }\n\n  getValueCache(dependencies: D): AsyncValueCache<T> {\n    let cache = this._map.get(dependencies);\n    if (!cache) {\n      cache = new AsyncValueCache(\n        async () => await this._fetcher(dependencies),\n        {\n          ...this._options,\n          onSubscribe: this._options.onSubscribe ? (cb) => this._options.onSubscribe!(dependencies, cb) : undefined,\n        },\n      );\n      this._map.set(dependencies, cache);\n    }\n    return cache;\n  }\n\n  async refreshWhere(predicate: (dependencies: D) => boolean) {\n    const promises: Promise<void>[] = [];\n    for (const [dependencies, cache] of this._map) {\n      if (predicate(dependencies)) {\n        promises.push(cache.refresh());\n      }\n    }\n    await Promise.all(promises);\n  }\n\n  async invalidateWhere(predicate: (dependencies: D) => boolean) {\n    const promises: Promise<void>[] = [];\n    for (const [dependencies, cache] of this._map) {\n      if (predicate(dependencies)) {\n        promises.push(cache.invalidate().catch(() => undefined));\n      }\n    }\n    await Promise.all(promises);\n  }\n\n  readonly isCacheAvailable = this._createKeyed(\"isCacheAvailable\");\n  readonly getIfCached = this._createKeyed(\"getIfCached\");\n  readonly getOrWait = this._createKeyed(\"getOrWait\");\n  readonly forceSetCachedValue = this._createKeyed(\"forceSetCachedValue\");\n  readonly forceSetCachedValueAsync = this._createKeyed(\"forceSetCachedValueAsync\");\n  readonly refresh = this._createKeyed(\"refresh\");\n  readonly invalidate = this._createKeyed(\"invalidate\");\n  readonly onStateChange = this._createKeyed(\"onStateChange\");\n  readonly isDirty = this._createKeyed(\"isDirty\");\n}\n\nclass AsyncValueCache<T> {\n  private _store: AsyncStore<T>;\n  private _pendingPromise: ReactPromise<T> | undefined;\n  private _fetcher: () => Promise<T>;\n  private readonly _rateLimitOptions: Omit<RateLimitOptions, \"batchCalls\">;\n  private _subscriptionsCount = 0;\n  private _unsubscribers: (() => void)[] = [];\n  private _mostRecentRefreshPromiseIndex = 0;\n\n  constructor(\n    fetcher: () => Promise<T>,\n    private readonly _options: {\n      onSubscribe?: (refresh: () => void) => (() => void),\n      rateLimiter?: Omit<RateLimitOptions, \"batchCalls\">,\n    } = {},\n  ) {\n    this._store = new AsyncStore();\n    this._rateLimitOptions = {\n      concurrency: 1,\n      throttleMs: 300,\n      ...filterUndefined(_options.rateLimiter ?? {}),\n    };\n\n\n    this._fetcher = rateLimited(fetcher, {\n      ...this._rateLimitOptions,\n      batchCalls: true,\n    });\n  }\n\n  isCacheAvailable(): boolean {\n    return this._store.isAvailable();\n  }\n\n  getIfCached() {\n    return this._store.get();\n  }\n\n  getOrWait(cacheStrategy: CacheStrategy): ReactPromise<T> {\n    const cached = this.getIfCached();\n    if (cacheStrategy === \"read-write\" && cached.status === \"ok\") {\n      return resolved(cached.data);\n    }\n\n    return this._refetch(cacheStrategy);\n  }\n\n  private _set(value: T): void {\n    this._store.set(value);\n  }\n\n  private _setAsync(value: Promise<T>): ReactPromise<void> {\n    if (this._subscriptionsCount === 0 && !isBrowserLike()) {\n      // if we're in a server-like environment, we'd rather cache less aggressively to avoid memory leaks.\n      // hence, if no one is listening to this cache, let's invalidate it\n      this._invalidateCacheSoon();\n    }\n    const promise = pending(value);\n    this._pendingPromise = promise;\n    return pending(this._store.setAsync(promise).then(() => undefined));\n  }\n\n  private _refetch(cacheStrategy: CacheStrategy): ReactPromise<T> {\n    if (cacheStrategy === \"read-write\" && this._pendingPromise) {\n      return this._pendingPromise;\n    }\n    const promise = pending(this._fetcher());\n    if (cacheStrategy === \"never\") {\n      return promise;\n    }\n    return pending(this._setAsync(promise).then(() => promise));\n  }\n\n  forceSetCachedValue(value: T): void {\n    this._set(value);\n  }\n\n  forceSetCachedValueAsync(value: Promise<T>): ReactPromise<void> {\n    return this._setAsync(value);\n  }\n\n  /**\n   * If anyone is listening to the cache, refreshes the value, and sets it without invalidating the cache.\n   */\n  async refresh(): Promise<void> {\n    // note that we do the extra check here to save a request if no one is listening to the cache anyway\n    if (this._subscriptionsCount > 0) {\n      await this.getOrWait(\"write-only\");\n    }\n  }\n\n  /**\n   * Invalidates the cache, marking it dirty (ie. it will be refreshed on the next read). If anyone is listening to the cache, it will refresh immediately.\n   */\n  async invalidate(): Promise<void> {\n    this._store.setUnavailable();\n    this._pendingPromise = undefined;\n    await this.refresh();\n  }\n\n  isDirty(): boolean {\n    return this._pendingPromise === undefined;\n  }\n\n  _invalidateCacheSoon(): void {\n    // wait a few seconds; we want to keep the cache up during this time\n    // else we do unnecessary requests if we unsubscribe and then subscribe again immediately\n    const currentRefreshPromiseIndex = ++this._mostRecentRefreshPromiseIndex;\n    runAsynchronously(async () => {\n      await wait(5000);\n      if (this._subscriptionsCount === 0 && currentRefreshPromiseIndex === this._mostRecentRefreshPromiseIndex) {\n        await this.invalidate();\n      }\n    });\n  }\n\n  onStateChange(callback: (value: T, oldValue: T | undefined) => void): { unsubscribe: () => void } {\n    const storeObj = this._store.onChange(callback);\n\n    runAsynchronously(this.getOrWait(\"read-write\"));\n\n    if (this._subscriptionsCount++ === 0 && this._options.onSubscribe) {\n      const unsubscribe = this._options.onSubscribe(() => {\n        runAsynchronously(this.refresh());\n      });\n      this._unsubscribers.push(unsubscribe);\n    }\n\n    let hasUnsubscribed = false;\n    return {\n      unsubscribe: () => {\n        if (hasUnsubscribed) return;\n        hasUnsubscribed = true;\n        storeObj.unsubscribe();\n        if (--this._subscriptionsCount === 0) {\n          this._invalidateCacheSoon();\n\n          for (const unsubscribe of this._unsubscribers) {\n            unsubscribe();\n          }\n        }\n      },\n    };\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 8211, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack-shared/src/utils/react.tsx"],"sourcesContent":["import React, { SetStateAction } from \"react\";\nimport { isBrowserLike } from \"./env\";\nimport { neverResolve, runAsynchronously } from \"./promises\";\nimport { AsyncResult } from \"./results\";\nimport { deindent } from \"./strings\";\n\nexport function componentWrapper<\n  C extends React.ComponentType<any> | keyof React.JSX.IntrinsicElements,\n  ExtraProps extends {} = {}\n>(displayName: string, render: React.ForwardRefRenderFunction<RefFromComponent<C>, React.ComponentPropsWithRef<C> & ExtraProps>) {\n  const Component = forwardRefIfNeeded(render);\n  Component.displayName = displayName;\n  return Component;\n}\ntype RefFromComponent<C extends React.ComponentType<any> | keyof React.JSX.IntrinsicElements> = NonNullable<RefFromComponentDistCond<React.ComponentPropsWithRef<C>[\"ref\"]>>;\ntype RefFromComponentDistCond<A> = A extends React.RefObject<infer T> ? T : never;  // distributive conditional type; see https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types\n\nconst react18PromiseCache = new WeakMap<Promise<unknown>, AsyncResult<unknown, unknown>>();\nexport function use<T>(promise: Promise<T>): T {\n  if (\"use\" in React) {\n    return React.use(promise);\n  } else {\n    if (react18PromiseCache.has(promise)) {\n      const result = react18PromiseCache.get(promise)!;\n      if (result.status === \"pending\") {\n        throw promise;\n      } else if (result.status === \"ok\") {\n        return result.data as T;\n      } else {\n        throw result.error;\n      }\n    } else {\n      react18PromiseCache.set(promise, { \"status\": \"pending\", progress: undefined });\n      runAsynchronously(async () => {\n        try {\n          const res = await promise;\n          react18PromiseCache.set(promise, { \"status\": \"ok\", data: res });\n        } catch (e) {\n          react18PromiseCache.set(promise, { \"status\": \"error\", error: e });\n        }\n      });\n      throw promise;\n    }\n  }\n}\n\nexport function forwardRefIfNeeded<T, P = {}>(render: React.ForwardRefRenderFunction<T, P>): React.FC<P & { ref?: React.Ref<T> }> {\n  // TODO: when we drop support for react 18, remove this\n\n  const version = React.version;\n  const major = parseInt(version.split(\".\")[0]);\n  if (major < 19) {\n    return React.forwardRef<T, P>(render as any) as any;\n  } else {\n    return ((props: P) => render(props, (props as any).ref)) as any;\n  }\n}\n\nexport function getNodeText(node: React.ReactNode): string {\n  if ([\"number\", \"string\"].includes(typeof node)) {\n    return `${node}`;\n  }\n  if (!node) {\n    return \"\";\n  }\n  if (Array.isArray(node)) {\n    return node.map(getNodeText).join(\"\");\n  }\n  if (typeof node === \"object\" && \"props\" in node) {\n    return getNodeText(node.props.children);\n  }\n  throw new Error(`Unknown node type: ${typeof node}`);\n}\nundefined?.test(\"getNodeText\", ({ expect }) => {\n  // Test with string\n  expect(getNodeText(\"hello\")).toBe(\"hello\");\n\n  // Test with number\n  expect(getNodeText(42)).toBe(\"42\");\n\n  // Test with null/undefined\n  expect(getNodeText(null)).toBe(\"\");\n  expect(getNodeText(undefined)).toBe(\"\");\n\n  // Test with array\n  expect(getNodeText([\"hello\", \" \", \"world\"])).toBe(\"hello world\");\n  expect(getNodeText([1, 2, 3])).toBe(\"123\");\n\n  // Test with mixed array\n  expect(getNodeText([\"hello\", 42, null])).toBe(\"hello42\");\n\n  // Test with React element (mocked)\n  const mockElement = {\n    props: {\n      children: \"child text\"\n    }\n  } as React.ReactElement;\n  expect(getNodeText(mockElement)).toBe(\"child text\");\n\n  // Test with nested React elements\n  const nestedElement = {\n    props: {\n      children: {\n        props: {\n          children: \"nested text\"\n        }\n      } as React.ReactElement\n    }\n  } as React.ReactElement;\n  expect(getNodeText(nestedElement)).toBe(\"nested text\");\n\n  // Test with array of React elements\n  const arrayOfElements = [\n    { props: { children: \"first\" } } as React.ReactElement,\n    { props: { children: \"second\" } } as React.ReactElement\n  ];\n  expect(getNodeText(arrayOfElements)).toBe(\"firstsecond\");\n});\n\n/**\n * Suspends the currently rendered component indefinitely. Will not unsuspend unless the component rerenders.\n *\n * You can use this to translate older query- or AsyncResult-based code to new the Suspense system, for example: `if (query.isLoading) suspend();`\n */\nexport function suspend(): never {\n  use(neverResolve());\n  throw new Error(\"Somehow a Promise that never resolves was resolved?\");\n}\n\nexport function mapRef<T, R>(ref: ReadonlyRef<T>, mapper: (value: T) => R): ReadonlyRef<R> {\n  let last: [T, R] | null = null;\n  return {\n    get current() {\n      const input = ref.current;\n      if (last === null || input !== last[0]) {\n        last = [input, mapper(input)];\n      }\n      return last[1];\n    },\n  };\n}\n\nexport type ReadonlyRef<T> = {\n  readonly current: T,\n};\n\nexport type RefState<T> = ReadonlyRef<T> & {\n  set: (updater: SetStateAction<T>) => void,\n};\n\n/**\n * Like useState, but its value is immediately available on refState.current after being set.\n *\n * Like useRef, but setting the value will cause a rerender.\n *\n * Note that useRefState returns a new object every time a rerender happens due to a value change, which is intentional\n * as it allows you to specify it in a dependency array like this:\n *\n * ```tsx\n * useEffect(() => {\n *   // do something with refState.current\n * }, [refState]);  // instead of refState.current\n * ```\n *\n * If you don't want this, you can wrap the result in a useMemo call.\n */\nexport function useRefState<T>(initialValue: T): RefState<T> {\n  const [, setState] = React.useState(initialValue);\n  const ref = React.useRef(initialValue);\n  const setValue = React.useCallback((updater: SetStateAction<T>) => {\n    const value: T = typeof updater === \"function\" ? (updater as any)(ref.current) : updater;\n    ref.current = value;\n    setState(value);\n  }, []);\n  const res = React.useMemo(() => ({\n    get current() {\n      return ref.current;\n    },\n    set: setValue,\n  }), [setValue]);\n  return res;\n}\n\nexport function mapRefState<T, R>(refState: RefState<T>, mapper: (value: T) => R, reverseMapper: (oldT: T, newR: R) => T): RefState<R> {\n  let last: [T, R] | null = null;\n  return {\n    get current() {\n      const input = refState.current;\n      if (last === null || input !== last[0]) {\n        last = [input, mapper(input)];\n      }\n      return last[1];\n    },\n    set(updater: SetStateAction<R>) {\n      const value: R = typeof updater === \"function\" ? (updater as any)(this.current) : updater;\n      refState.set(reverseMapper(refState.current, value));\n    },\n  };\n}\n\nexport function useQueryState(key: string, defaultValue?: string) {\n  const getValue = () => new URLSearchParams(window.location.search).get(key) ?? defaultValue ?? \"\";\n\n  const [value, setValue] = React.useState(getValue);\n\n  React.useEffect(() => {\n    const onPopState = () => setValue(getValue());\n    window.addEventListener(\"popstate\", onPopState);\n    return () => window.removeEventListener(\"popstate\", onPopState);\n  }, []);\n\n  const update = (next: string) => {\n    const params = new URLSearchParams(window.location.search);\n    params.set(key, next);\n    const newUrl = `${window.location.pathname}?${params.toString()}`;\n    window.history.pushState(null, \"\", newUrl);\n    setValue(next);\n  };\n\n  return [value, update] as const;\n}\n\nexport function shouldRethrowRenderingError(error: unknown): boolean {\n  return !!error && typeof error === \"object\" && \"digest\" in error && error.digest === \"BAILOUT_TO_CLIENT_SIDE_RENDERING\";\n}\n\nexport class NoSuspenseBoundaryError extends Error {\n  digest: string;\n  reason: string;\n\n  constructor(options: { caller?: string }) {\n    super(deindent`\n      Suspense boundary not found! Read the error message below carefully on how to fix it.\n\n      ${options.caller ?? \"This code path\"} attempted to display a loading indicator, but didn't find a Suspense boundary above it. Please read the error message below carefully.\n      \n      The fix depends on which of the 4 scenarios caused it:\n      \n      1. [Next.js] You are missing a loading.tsx file in your app directory. Fix it by adding a loading.tsx file in your app directory.\n\n      2. [React] You are missing a <Suspense> boundary in your component. Fix it by wrapping your component (or the entire app) in a <Suspense> component.\n\n      3. [Next.js] The component is rendered in the root (outermost) layout.tsx or template.tsx file. Next.js does not wrap those files in a Suspense boundary, even if there is a loading.tsx file in the same folder. To fix it, wrap your layout inside a route group like this:\n\n        - app\n        - - layout.tsx  // contains <html> and <body>, alongside providers and other components that don't need ${options.caller ?? \"this code path\"}\n        - - loading.tsx  // required for suspense\n        - - (main)\n        - - - layout.tsx  // contains the main layout of your app, like a sidebar or a header, and can use ${options.caller ?? \"this code path\"}\n        - - - route.tsx  // your actual main page\n        - - - the rest of your app\n\n        For more information on this approach, see Next's documentation on route groups: https://nextjs.org/docs/app/building-your-application/routing/route-groups\n      \n      4. You caught this error with try-catch or a custom error boundary. Fix this by rethrowing the error or not catching it in the first place.\n\n      See: https://nextjs.org/docs/messages/missing-suspense-with-csr-bailout\n\n      More information on SSR and Suspense boundaries: https://react.dev/reference/react/Suspense#providing-a-fallback-for-server-errors-and-client-only-content\n    `);\n\n    this.name = \"NoSuspenseBoundaryError\";\n    this.reason = options.caller ?? \"suspendIfSsr()\";\n\n    // set the digest so nextjs doesn't log the error\n    // https://github.com/vercel/next.js/blob/d01d6d9c35a8c2725b3d74c1402ab76d4779a6cf/packages/next/src/shared/lib/lazy-dynamic/bailout-to-csr.ts#L14\n    this.digest = \"BAILOUT_TO_CLIENT_SIDE_RENDERING\";\n  }\n}\nundefined?.test(\"NoSuspenseBoundaryError\", ({ expect }) => {\n  // Test with default options\n  const defaultError = new NoSuspenseBoundaryError({});\n  expect(defaultError.name).toBe(\"NoSuspenseBoundaryError\");\n  expect(defaultError.reason).toBe(\"suspendIfSsr()\");\n  expect(defaultError.digest).toBe(\"BAILOUT_TO_CLIENT_SIDE_RENDERING\");\n  expect(defaultError.message).toContain(\"This code path attempted to display a loading indicator\");\n\n  // Test with custom caller\n  const customError = new NoSuspenseBoundaryError({ caller: \"CustomComponent\" });\n  expect(customError.name).toBe(\"NoSuspenseBoundaryError\");\n  expect(customError.reason).toBe(\"CustomComponent\");\n  expect(customError.digest).toBe(\"BAILOUT_TO_CLIENT_SIDE_RENDERING\");\n  expect(customError.message).toContain(\"CustomComponent attempted to display a loading indicator\");\n\n  // Verify error message contains all the necessary information\n  expect(customError.message).toContain(\"loading.tsx\");\n  expect(customError.message).toContain(\"route groups\");\n  expect(customError.message).toContain(\"https://nextjs.org/docs/messages/missing-suspense-with-csr-bailout\");\n});\n\n\n/**\n * Use this in a component or a hook to disable SSR. Should be wrapped in a Suspense boundary, or it will throw an error.\n */\nexport function suspendIfSsr(caller?: string) {\n  if (!isBrowserLike()) {\n    throw new NoSuspenseBoundaryError({ caller });\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 8453, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack-shared/src/utils/json.tsx"],"sourcesContent":["import { Result } from \"./results\";\n\nexport type Json =\n  | null\n  | boolean\n  | number\n  | string\n  | Json[]\n  | { [key: string]: Json };\n\nexport type ReadonlyJson =\n  | null\n  | boolean\n  | number\n  | string\n  | readonly ReadonlyJson[]\n  | { readonly [key: string]: ReadonlyJson };\n\nexport function isJsonSerializable(value: unknown): value is Json {\n  switch (typeof value) {\n    case \"object\": {\n      if (value === null) return true;\n      if (Array.isArray(value)) return value.every(isJsonSerializable);\n      return Object.keys(value).every(k => typeof k === \"string\") && Object.values(value).every(isJsonSerializable);\n    }\n    case \"string\":\n    case \"number\":\n    case \"boolean\": {\n      return true;\n    }\n    default: {\n      return false;\n    }\n  }\n}\nundefined?.test(\"isJsonSerializable\", ({ expect }) => {\n  // Test primitive values\n  expect(isJsonSerializable(null)).toBe(true);\n  expect(isJsonSerializable(true)).toBe(true);\n  expect(isJsonSerializable(false)).toBe(true);\n  expect(isJsonSerializable(123)).toBe(true);\n  expect(isJsonSerializable(\"string\")).toBe(true);\n\n  // Test arrays\n  expect(isJsonSerializable([])).toBe(true);\n  expect(isJsonSerializable([1, 2, 3])).toBe(true);\n  expect(isJsonSerializable([\"a\", \"b\", \"c\"])).toBe(true);\n  expect(isJsonSerializable([1, \"a\", true, null])).toBe(true);\n  expect(isJsonSerializable([1, [2, 3], { a: \"b\" }])).toBe(true);\n\n  // Test objects\n  expect(isJsonSerializable({})).toBe(true);\n  expect(isJsonSerializable({ a: 1, b: 2 })).toBe(true);\n  expect(isJsonSerializable({ a: \"string\", b: true, c: null })).toBe(true);\n  expect(isJsonSerializable({ a: [1, 2, 3], b: { c: \"d\" } })).toBe(true);\n\n  // Test invalid JSON values\n  expect(isJsonSerializable(undefined)).toBe(false);\n  expect(isJsonSerializable(() => {})).toBe(false);\n  expect(isJsonSerializable(Symbol())).toBe(false);\n  expect(isJsonSerializable(BigInt(123))).toBe(false);\n\n  // Test arrays with invalid JSON values\n  expect(isJsonSerializable([1, undefined, 3])).toBe(false);\n  expect(isJsonSerializable([1, () => {}, 3])).toBe(false);\n\n  // Test objects with invalid JSON values\n  expect(isJsonSerializable({ a: 1, b: undefined })).toBe(false);\n  expect(isJsonSerializable({ a: 1, b: () => {} })).toBe(false);\n});\n\nexport function parseJson(json: string): Result<Json> {\n  return Result.fromThrowing(() => JSON.parse(json));\n}\nundefined?.test(\"parseJson\", ({ expect }) => {\n  // Test valid JSON strings\n  const nullResult = parseJson(\"null\");\n  expect(nullResult.status).toBe(\"ok\");\n  if (nullResult.status === \"ok\") {\n    expect(nullResult.data).toBe(null);\n  }\n\n  const trueResult = parseJson(\"true\");\n  expect(trueResult.status).toBe(\"ok\");\n  if (trueResult.status === \"ok\") {\n    expect(trueResult.data).toBe(true);\n  }\n\n  const numberResult = parseJson(\"123\");\n  expect(numberResult.status).toBe(\"ok\");\n  if (numberResult.status === \"ok\") {\n    expect(numberResult.data).toBe(123);\n  }\n\n  const stringResult = parseJson('\"string\"');\n  expect(stringResult.status).toBe(\"ok\");\n  if (stringResult.status === \"ok\") {\n    expect(stringResult.data).toBe(\"string\");\n  }\n\n  const emptyArrayResult = parseJson(\"[]\");\n  expect(emptyArrayResult.status).toBe(\"ok\");\n  if (emptyArrayResult.status === \"ok\") {\n    expect(emptyArrayResult.data).toEqual([]);\n  }\n\n  const arrayResult = parseJson(\"[1,2,3]\");\n  expect(arrayResult.status).toBe(\"ok\");\n  if (arrayResult.status === \"ok\") {\n    expect(arrayResult.data).toEqual([1, 2, 3]);\n  }\n\n  const emptyObjectResult = parseJson(\"{}\");\n  expect(emptyObjectResult.status).toBe(\"ok\");\n  if (emptyObjectResult.status === \"ok\") {\n    expect(emptyObjectResult.data).toEqual({});\n  }\n\n  const objectResult = parseJson('{\"a\":1,\"b\":\"string\"}');\n  expect(objectResult.status).toBe(\"ok\");\n  if (objectResult.status === \"ok\") {\n    expect(objectResult.data).toEqual({ a: 1, b: \"string\" });\n  }\n\n  // Test invalid JSON strings\n  expect(parseJson(\"\").status).toBe(\"error\");\n  expect(parseJson(\"undefined\").status).toBe(\"error\");\n  expect(parseJson(\"{\").status).toBe(\"error\");\n  expect(parseJson('{\"a\":1,}').status).toBe(\"error\");\n  expect(parseJson(\"function(){}\").status).toBe(\"error\");\n});\n\nexport function stringifyJson(json: Json): Result<string> {\n  return Result.fromThrowing(() => JSON.stringify(json));\n}\nundefined?.test(\"stringifyJson\", ({ expect }) => {\n  // Test primitive values\n  const nullResult = stringifyJson(null);\n  expect(nullResult.status).toBe(\"ok\");\n  if (nullResult.status === \"ok\") {\n    expect(nullResult.data).toBe(\"null\");\n  }\n\n  const trueResult = stringifyJson(true);\n  expect(trueResult.status).toBe(\"ok\");\n  if (trueResult.status === \"ok\") {\n    expect(trueResult.data).toBe(\"true\");\n  }\n\n  const numberResult = stringifyJson(123);\n  expect(numberResult.status).toBe(\"ok\");\n  if (numberResult.status === \"ok\") {\n    expect(numberResult.data).toBe(\"123\");\n  }\n\n  const stringResult = stringifyJson(\"string\");\n  expect(stringResult.status).toBe(\"ok\");\n  if (stringResult.status === \"ok\") {\n    expect(stringResult.data).toBe('\"string\"');\n  }\n\n  // Test arrays\n  const emptyArrayResult = stringifyJson([]);\n  expect(emptyArrayResult.status).toBe(\"ok\");\n  if (emptyArrayResult.status === \"ok\") {\n    expect(emptyArrayResult.data).toBe(\"[]\");\n  }\n\n  const arrayResult = stringifyJson([1, 2, 3]);\n  expect(arrayResult.status).toBe(\"ok\");\n  if (arrayResult.status === \"ok\") {\n    expect(arrayResult.data).toBe(\"[1,2,3]\");\n  }\n\n  // Test objects\n  const emptyObjectResult = stringifyJson({});\n  expect(emptyObjectResult.status).toBe(\"ok\");\n  if (emptyObjectResult.status === \"ok\") {\n    expect(emptyObjectResult.data).toBe(\"{}\");\n  }\n\n  const objectResult = stringifyJson({ a: 1, b: \"string\" });\n  expect(objectResult.status).toBe(\"ok\");\n  if (objectResult.status === \"ok\") {\n    expect(objectResult.data).toBe('{\"a\":1,\"b\":\"string\"}');\n  }\n\n  // Test nested structures\n  const nested = { a: [1, 2, 3], b: { c: \"d\" } };\n  const nestedResult = stringifyJson(nested);\n  expect(nestedResult.status).toBe(\"ok\");\n  if (nestedResult.status === \"ok\") {\n    expect(nestedResult.data).toBe('{\"a\":[1,2,3],\"b\":{\"c\":\"d\"}}');\n  }\n\n  // Test circular references (should error)\n  const circular: any = { a: 1 };\n  circular.self = circular;\n  expect(stringifyJson(circular).status).toBe(\"error\");\n});\n"],"names":[],"mappings":";;;;;;;;;AAAA,SAAS,cAAc;;AAkBhB,SAAS,mBAAmB,KAAA,EAA+B;IAChE,OAAQ,OAAO,OAAO;QACpB,KAAK;YAAU;gBACb,IAAI,UAAU,KAAM,CAAA,OAAO;gBAC3B,IAAI,MAAM,OAAA,CAAQ,KAAK,EAAG,CAAA,OAAO,MAAM,KAAA,CAAM,kBAAkB;gBAC/D,OAAO,OAAO,IAAA,CAAK,KAAK,EAAE,KAAA,CAAM,CAAA,IAAK,OAAO,MAAM,QAAQ,KAAK,OAAO,MAAA,CAAO,KAAK,EAAE,KAAA,CAAM,kBAAkB;YAC9G;QACA,KAAK;QACL,KAAK;QACL,KAAK;YAAW;gBACd,OAAO;YACT;QACA;YAAS;gBACP,OAAO;YACT;IACF;AACF;AAqCO,SAAS,UAAU,IAAA,EAA4B;IACpD,OAAO,mOAAA,CAAO,YAAA,CAAa,IAAM,KAAK,KAAA,CAAM,IAAI,CAAC;AACnD;AA2DO,SAAS,cAAc,IAAA,EAA4B;IACxD,OAAO,mOAAA,CAAO,YAAA,CAAa,IAAM,KAAK,SAAA,CAAU,IAAI,CAAC;AACvD"}}]
}