{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack/src/lib/hooks.tsx"],"sourcesContent":["\n//===========================================\n// THIS FILE IS AUTO-GENERATED FROM TEMPLATE. DO NOT EDIT IT DIRECTLY\n//===========================================\nimport { useContext } from \"react\";\nimport { StackContext } from \"../providers/stack-provider-client\";\nimport { GetUserOptions as AppGetUserOptions, CurrentInternalUser, CurrentUser, StackClientApp } from \"./stack-app\";\n\ntype GetUserOptions = AppGetUserOptions<true> & {\n  projectIdMustMatch?: string,\n};\n\n/**\n * Returns the current user object. Equivalent to `useStackApp().useUser()`.\n *\n * @returns the current user\n */\nexport function useUser(options: GetUserOptions & { or: 'redirect' | 'throw', projectIdMustMatch: \"internal\" }): CurrentInternalUser;\nexport function useUser(options: GetUserOptions & { or: 'redirect' | 'throw' }): CurrentUser;\nexport function useUser(options: GetUserOptions & { projectIdMustMatch: \"internal\" }): CurrentInternalUser | null;\nexport function useUser(options?: GetUserOptions): CurrentUser | CurrentInternalUser | null;\nexport function useUser(options: GetUserOptions = {}): CurrentUser | CurrentInternalUser | null {\n  const stackApp = useStackApp(options);\n  if (options.projectIdMustMatch && stackApp.projectId !== options.projectIdMustMatch) {\n    throw new Error(\"Unexpected project ID in useStackApp: \" + stackApp.projectId);\n  }\n  if (options.projectIdMustMatch === \"internal\") {\n    return stackApp.useUser(options) as CurrentInternalUser;\n  } else {\n    return stackApp.useUser(options) as CurrentUser;\n  }\n}\n\n/**\n * Returns the current Stack app associated with the StackProvider.\n *\n * @returns the current Stack app\n */\nexport function useStackApp<ProjectId extends string>(options: { projectIdMustMatch?: ProjectId } = {}): StackClientApp<true, ProjectId> {\n  if (typeof useContext !== \"function\") {\n    throw new Error(\"useStackApp() can only be used in a React Client Component. Make sure you're not calling it from a Server Component, or any other environment.\");\n  }\n  const context = useContext(StackContext);\n  if (context === null) {\n    throw new Error(\"useStackApp must be used within a StackProvider\");\n  }\n  const stackApp = context.app;\n  if (options.projectIdMustMatch && stackApp.projectId !== options.projectIdMustMatch) {\n    throw new Error(\"Unexpected project ID in useStackApp: \" + stackApp.projectId);\n  }\n  return stackApp as StackClientApp<true, ProjectId>;\n}\n"],"names":[],"mappings":";;;;;;;AAIA,SAAS,kBAAkB;AAC3B,SAAS,oBAAoB;;;AAgBtB,SAAS,QAAQ,UAA0B,CAAC,CAAA,EAA6C;IAC9F,MAAM,WAAW,YAAY,OAAO;IACpC,IAAI,QAAQ,kBAAA,IAAsB,SAAS,SAAA,KAAc,QAAQ,kBAAA,EAAoB;QACnF,MAAM,IAAI,MAAM,2CAA2C,SAAS,SAAS;IAC/E;IACA,IAAI,QAAQ,kBAAA,KAAuB,YAAY;QAC7C,OAAO,SAAS,OAAA,CAAQ,OAAO;IACjC,OAAO;QACL,OAAO,SAAS,OAAA,CAAQ,OAAO;IACjC;AACF;AAOO,SAAS,YAAsC,UAA8C,CAAC,CAAA,EAAoC;IACvI,IAAI,OAAO,+MAAA,KAAe,YAAY;QACpC,MAAM,IAAI,MAAM,gJAAgJ;IAClK;IACA,MAAM,cAAU,+MAAA,EAAW,uPAAY;IACvC,IAAI,YAAY,MAAM;QACpB,MAAM,IAAI,MAAM,iDAAiD;IACnE;IACA,MAAM,WAAW,QAAQ,GAAA;IACzB,IAAI,QAAQ,kBAAA,IAAsB,SAAS,SAAA,KAAc,QAAQ,kBAAA,EAAoB;QACnF,MAAM,IAAI,MAAM,2CAA2C,SAAS,SAAS;IAC/E;IACA,OAAO;AACT"}},
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack/src/lib/stack-app/common.ts"],"sourcesContent":["\n//===========================================\n// THIS FILE IS AUTO-GENERATED FROM TEMPLATE. DO NOT EDIT IT DIRECTLY\n//===========================================\nimport { ProviderType } from \"@stackframe/stack-shared/dist/utils/oauth\";\nimport type { GenericQueryCtx, UserIdentity } from \"convex/server\";\n\nexport type RedirectToOptions = {\n  replace?: boolean,\n  noRedirectBack?: boolean,\n};\n\nexport type AsyncStoreProperty<Name extends string, Args extends any[], Value, IsMultiple extends boolean> =\n  & { [key in `${IsMultiple extends true ? \"list\" : \"get\"}${Capitalize<Name>}`]: (...args: Args) => Promise<Value> }\n  & { [key in `use${Capitalize<Name>}`]: (...args: Args) => Value } // THIS_LINE_PLATFORM react-like\n\nexport type EmailConfig = {\n  host: string,\n  port: number,\n  username: string,\n  password: string,\n  senderEmail: string,\n  senderName: string,\n}\n\nexport type RedirectMethod = \"window\"\n  | \"nextjs\" // THIS_LINE_PLATFORM next\n  | \"none\"\n  | {\n    useNavigate: () => (to: string) => void,\n    navigate?: (to: string) => void,\n  }\n\n\nexport type GetCurrentUserOptions<HasTokenStore> =\n  & {\n    or?: 'redirect' | 'throw' | 'return-null' | 'anonymous' | /** @deprecated */ 'anonymous-if-exists[deprecated]',\n    tokenStore?: TokenStoreInit,\n  }\n  & (HasTokenStore extends false ? {\n    tokenStore: TokenStoreInit,\n  } : {});\n\nexport type ConvexCtx =\n| GenericQueryCtx<any>\n| { auth: { getUserIdentity: () => Promise<UserIdentity | null> } };\n\nexport type GetCurrentPartialUserOptions<HasTokenStore> =\n  & {\n    or?: 'return-null' | 'anonymous',  // note: unlike normal getUser, 'anonymous' still returns null sometimes (eg. if no token is present)\n    tokenStore?: TokenStoreInit,\n  }\n  & (\n    | {\n      from: 'token',\n    }\n    | {\n      from: 'convex',\n      ctx: ConvexCtx,\n    }\n  )\n  & (HasTokenStore extends false ? {\n    tokenStore: TokenStoreInit,\n  } : {});\n\nexport type RequestLike = {\n  headers: {\n    get: (name: string) => string | null,\n  },\n};\n\nexport type TokenStoreInit<HasTokenStore extends boolean = boolean> =\n  HasTokenStore extends true ? (\n    | \"cookie\"\n    | \"nextjs-cookie\"\n    | \"memory\"\n    | RequestLike\n    | { accessToken: string, refreshToken: string }\n  )\n  : HasTokenStore extends false ? null\n  : TokenStoreInit<true> | TokenStoreInit<false>;\n\nexport type HandlerUrls = {\n  handler: string,\n  signIn: string,\n  signUp: string,\n  afterSignIn: string,\n  afterSignUp: string,\n  signOut: string,\n  afterSignOut: string,\n  emailVerification: string,\n  passwordReset: string,\n  forgotPassword: string,\n  home: string,\n  oauthCallback: string,\n  magicLinkCallback: string,\n  accountSettings: string,\n  teamInvitation: string,\n  mfa: string,\n  error: string,\n}\n\nexport type OAuthScopesOnSignIn = {\n  [key in ProviderType]: string[];\n};\n\n/**\n * Contains the authentication methods without session-related fields.\n * Used for apps that have token storage capabilities.\n */\nexport type AuthLike<ExtraOptions = {}> = {\n  signOut(options?: { redirectUrl?: URL | string } & ExtraOptions): Promise<void>,\n  signOut(options?: { redirectUrl?: URL | string }): Promise<void>,\n\n  /**\n   * Returns headers for sending authenticated HTTP requests to external servers. Most commonly used in cross-origin\n   * requests. Similar to `getAuthJson`, but specifically for HTTP requests.\n   *\n   * If you are using `tokenStore: \"cookie\"`, you don't need this for same-origin requests. However, most\n   * browsers now disable third-party cookies by default, so we must pass authentication tokens by header instead\n   * if the client and server are on different origins.\n   *\n   * This function returns a header object that can be used with `fetch` or other HTTP request libraries to send\n   * authenticated requests.\n   *\n   * On the server, you can then pass in the `Request` object to the `tokenStore` option\n   * of your Stack app. Please note that CORS does not allow most headers by default, so you\n   * must include `x-stack-auth` in the [`Access-Control-Allow-Headers` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Headers)\n   * of the CORS preflight response.\n   *\n   * If you are not using HTTP (and hence cannot set headers), you will need to use the `getAuthJson()` function\n   * instead.\n   *\n   * Example:\n   *\n   * ```ts\n   * // client\n   * const res = await fetch(\"https://api.example.com\", {\n   *   headers: {\n   *     ...await stackApp.getAuthHeaders()\n   *     // you can also add your own headers here\n   *   },\n   * });\n   *\n   * // server\n   * function handleRequest(req: Request) {\n   *   const user = await stackServerApp.getUser({ tokenStore: req });\n   *   return new Response(\"Welcome, \" + user.displayName);\n   * }\n   * ```\n   */\n  getAuthHeaders(options?: {} & ExtraOptions): Promise<{ \"x-stack-auth\": string }>,\n\n  /**\n   * Creates a JSON-serializable object containing the information to authenticate a user on an external server.\n   * Similar to `getAuthHeaders`, but returns an object that can be sent over any protocol instead of just\n   * HTTP headers.\n   *\n   * While `getAuthHeaders` is the recommended way to send authentication tokens over HTTP, your app may use\n   * a different protocol, for example WebSockets or gRPC. This function returns a token object that can be JSON-serialized and sent to the server in any way you like.\n   *\n   * On the server, you can pass in this token object into the `tokenStore` option to fetch user details.\n   *\n   * Example:\n   *\n   * ```ts\n   * // client\n   * const res = await rpcCall(rpcEndpoint, {\n   *   data: {\n   *     auth: await stackApp.getAuthJson(),\n   *   },\n   * });\n   *\n   * // server\n   * function handleRequest(data) {\n   *   const user = await stackServerApp.getUser({ tokenStore: data.auth });\n   *   return new Response(\"Welcome, \" + user.displayName);\n   * }\n   * ```\n   */\n  getAuthJson(options?: {} & ExtraOptions): Promise<{ accessToken: string | null, refreshToken: string | null }>,\n};\n\n/** @internal */\nexport const stackAppInternalsSymbol = Symbol.for(\"StackAuth--DO-NOT-USE-OR-YOU-WILL-BE-FIRED--StackAppInternals\");\n"],"names":[],"mappings":";;;;;AAwLO,IAAM,0BAA0B,OAAO,GAAA,CAAI,+DAA+D"}},
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack/src/lib/stack-app/internal-api-keys/index.ts"],"sourcesContent":["\n//===========================================\n// THIS FILE IS AUTO-GENERATED FROM TEMPLATE. DO NOT EDIT IT DIRECTLY\n//===========================================\n\nimport { InternalApiKeyCreateCrudRequest } from \"@stackframe/stack-shared/dist/interface/admin-interface\";\nimport { InternalApiKeysCrud } from \"@stackframe/stack-shared/dist/interface/crud/internal-api-keys\";\n\nexport type InternalApiKeyBase = {\n  id: string,\n  description: string,\n  expiresAt: Date,\n  manuallyRevokedAt: Date | null,\n  createdAt: Date,\n  isValid(): boolean,\n  whyInvalid(): \"expired\" | \"manually-revoked\" | null,\n  revoke(): Promise<void>,\n};\n\nexport type InternalApiKeyBaseCrudRead = Pick<InternalApiKeysCrud[\"Admin\"][\"Read\"], \"id\" | \"created_at_millis\" | \"description\" | \"expires_at_millis\" | \"manually_revoked_at_millis\">;\n\nexport type InternalApiKeyFirstView = {\n  publishableClientKey?: string,\n  secretServerKey?: string,\n  superSecretAdminKey?: string,\n} & InternalApiKeyBase;\n\nexport type InternalApiKey = {\n  publishableClientKey: null | {\n    lastFour: string,\n  },\n  secretServerKey: null | {\n    lastFour: string,\n  },\n  superSecretAdminKey: null | {\n    lastFour: string,\n  },\n} & InternalApiKeyBase;\n\nexport type InternalApiKeyCreateOptions = {\n  description: string,\n  expiresAt: Date,\n  hasPublishableClientKey: boolean,\n  hasSecretServerKey: boolean,\n  hasSuperSecretAdminKey: boolean,\n};\nexport function internalApiKeyCreateOptionsToCrud(options: InternalApiKeyCreateOptions): InternalApiKeyCreateCrudRequest {\n  return {\n    description: options.description,\n    expires_at_millis: options.expiresAt.getTime(),\n    has_publishable_client_key: options.hasPublishableClientKey,\n    has_secret_server_key: options.hasSecretServerKey,\n    has_super_secret_admin_key: options.hasSuperSecretAdminKey,\n  };\n}\n"],"names":[],"mappings":";;;;;AA8CO,SAAS,kCAAkC,OAAA,EAAuE;IACvH,OAAO;QACL,aAAa,QAAQ,WAAA;QACrB,mBAAmB,QAAQ,SAAA,CAAU,OAAA,CAAQ;QAC7C,4BAA4B,QAAQ,uBAAA;QACpC,uBAAuB,QAAQ,kBAAA;QAC/B,4BAA4B,QAAQ,sBAAA;IACtC;AACF"}},
    {"offset": {"line": 78, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack/src/lib/stack-app/permissions/index.ts"],"sourcesContent":["\n//===========================================\n// THIS FILE IS AUTO-GENERATED FROM TEMPLATE. DO NOT EDIT IT DIRECTLY\n//===========================================\nimport { ProjectPermissionDefinitionsCrud } from \"@stackframe/stack-shared/dist/interface/crud/project-permissions\";\nimport { TeamPermissionDefinitionsCrud } from \"@stackframe/stack-shared/dist/interface/crud/team-permissions\";\n\n\nexport type TeamPermission = {\n  id: string,\n};\n\nexport type AdminTeamPermission = TeamPermission;\n\nexport type AdminTeamPermissionDefinition = {\n  id: string,\n  description?: string,\n  containedPermissionIds: string[],\n  isDefaultUserPermission?: boolean,\n};\n\nexport type AdminTeamPermissionDefinitionCreateOptions = {\n  id: string,\n  description?: string,\n  containedPermissionIds: string[],\n  isDefaultUserPermission?: boolean,\n};\nexport function adminTeamPermissionDefinitionCreateOptionsToCrud(options: AdminTeamPermissionDefinitionCreateOptions): TeamPermissionDefinitionsCrud[\"Admin\"][\"Create\"] {\n  return {\n    id: options.id,\n    description: options.description,\n    contained_permission_ids: options.containedPermissionIds,\n  };\n}\n\nexport type AdminTeamPermissionDefinitionUpdateOptions = Pick<Partial<AdminTeamPermissionDefinitionCreateOptions>, \"description\" | \"containedPermissionIds\">;\nexport function adminTeamPermissionDefinitionUpdateOptionsToCrud(options: AdminTeamPermissionDefinitionUpdateOptions): TeamPermissionDefinitionsCrud[\"Admin\"][\"Update\"] {\n  return {\n    description: options.description,\n    contained_permission_ids: options.containedPermissionIds,\n  };\n}\n\nexport type ProjectPermission = {\n  id: string,\n};\n\nexport type AdminProjectPermission = ProjectPermission;\n\nexport type AdminProjectPermissionDefinition = {\n  id: string,\n  description?: string,\n  containedPermissionIds: string[],\n};\n\nexport type AdminProjectPermissionDefinitionCreateOptions = {\n  id: string,\n  description?: string,\n  containedPermissionIds: string[],\n};\nexport function adminProjectPermissionDefinitionCreateOptionsToCrud(options: AdminProjectPermissionDefinitionCreateOptions): ProjectPermissionDefinitionsCrud[\"Admin\"][\"Create\"] {\n  return {\n    id: options.id,\n    description: options.description,\n    contained_permission_ids: options.containedPermissionIds,\n  };\n}\n\nexport type AdminProjectPermissionDefinitionUpdateOptions = Pick<Partial<AdminProjectPermissionDefinitionCreateOptions>, \"description\" | \"containedPermissionIds\">;\nexport function adminProjectPermissionDefinitionUpdateOptionsToCrud(options: AdminProjectPermissionDefinitionUpdateOptions): ProjectPermissionDefinitionsCrud[\"Admin\"][\"Update\"] {\n  return {\n    description: options.description,\n    contained_permission_ids: options.containedPermissionIds,\n  };\n}\n"],"names":[],"mappings":";;;;;;;;;;;AA2BO,SAAS,iDAAiD,OAAA,EAAuG;IACtK,OAAO;QACL,IAAI,QAAQ,EAAA;QACZ,aAAa,QAAQ,WAAA;QACrB,0BAA0B,QAAQ,sBAAA;IACpC;AACF;AAGO,SAAS,iDAAiD,OAAA,EAAuG;IACtK,OAAO;QACL,aAAa,QAAQ,WAAA;QACrB,0BAA0B,QAAQ,sBAAA;IACpC;AACF;AAmBO,SAAS,oDAAoD,OAAA,EAA6G;IAC/K,OAAO;QACL,IAAI,QAAQ,EAAA;QACZ,aAAa,QAAQ,WAAA;QACrB,0BAA0B,QAAQ,sBAAA;IACpC;AACF;AAGO,SAAS,oDAAoD,OAAA,EAA6G;IAC/K,OAAO;QACL,aAAa,QAAQ,WAAA;QACrB,0BAA0B,QAAQ,sBAAA;IACpC;AACF"}},
    {"offset": {"line": 121, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack/src/lib/stack-app/projects/index.ts"],"sourcesContent":["\n//===========================================\n// THIS FILE IS AUTO-GENERATED FROM TEMPLATE. DO NOT EDIT IT DIRECTLY\n//===========================================\nimport { ProductionModeError } from \"@stackframe/stack-shared/dist/helpers/production-mode\";\nimport { AdminUserProjectsCrud, ProjectsCrud } from \"@stackframe/stack-shared/dist/interface/crud/projects\";\n\nimport { CompleteConfig, EnvironmentConfigNormalizedOverride, EnvironmentConfigOverrideOverride } from \"@stackframe/stack-shared/dist/config/schema\";\nimport { StackAdminApp } from \"../apps/interfaces/admin-app\";\nimport { AdminProjectConfig, AdminProjectConfigUpdateOptions, ProjectConfig } from \"../project-configs\";\n\n\nexport type Project = {\n  readonly id: string,\n  readonly displayName: string,\n  readonly config: ProjectConfig,\n};\n\nexport type AdminProject = {\n  readonly id: string,\n  readonly displayName: string,\n  readonly description: string | null,\n  readonly createdAt: Date,\n  readonly isProductionMode: boolean,\n  readonly ownerTeamId: string | null,\n  readonly logoUrl: string | null | undefined,\n  readonly logoFullUrl: string | null | undefined,\n  readonly logoDarkModeUrl: string | null | undefined,\n  readonly logoFullDarkModeUrl: string | null | undefined,\n\n  readonly config: AdminProjectConfig,\n\n  update(this: AdminProject, update: AdminProjectUpdateOptions): Promise<void>,\n  delete(this: AdminProject): Promise<void>,\n\n  getConfig(this: AdminProject): Promise<CompleteConfig>,\n  useConfig(this: AdminProject): CompleteConfig,\n\n  // We have some strict types here in order to prevent accidental overwriting of a top-level property of a config object\n  updateConfig(\n    this: AdminProject,\n    config: EnvironmentConfigOverrideOverride & {\n      [K in keyof EnvironmentConfigNormalizedOverride]: \"............................ERROR MESSAGE AFTER THIS LINE............................ You have attempted to update a config object with a top-level property in it (for example `emails`). This is very likely a mistake, and you probably meant to update a nested property instead (for example `emails.server`). If you really meant to update a top-level property (resetting all nested properties to their defaults), cast as any (the code will work at runtime) ............................ERROR MESSAGE BEFORE THIS LINE............................\";\n    }\n  ): Promise<void>,\n\n  getProductionModeErrors(this: AdminProject): Promise<ProductionModeError[]>,\n  useProductionModeErrors(this: AdminProject): ProductionModeError[],\n} & Project;\n\nexport type AdminOwnedProject = {\n  readonly app: StackAdminApp<false>,\n} & AdminProject;\n\nexport type AdminProjectUpdateOptions = {\n  displayName?: string,\n  description?: string,\n  isProductionMode?: boolean,\n  logoUrl?: string | null,\n  logoFullUrl?: string | null,\n  logoDarkModeUrl?: string | null,\n  logoFullDarkModeUrl?: string | null,\n  config?: AdminProjectConfigUpdateOptions,\n};\nexport function adminProjectUpdateOptionsToCrud(options: AdminProjectUpdateOptions): ProjectsCrud[\"Admin\"][\"Update\"] {\n  return {\n    display_name: options.displayName,\n    description: options.description,\n    is_production_mode: options.isProductionMode,\n    logo_url: options.logoUrl,\n    logo_full_url: options.logoFullUrl,\n    logo_dark_mode_url: options.logoDarkModeUrl,\n    logo_full_dark_mode_url: options.logoFullDarkModeUrl,\n    config: {\n      domains: options.config?.domains?.map((d) => ({\n        domain: d.domain,\n        handler_path: d.handlerPath\n      })),\n      oauth_providers: options.config?.oauthProviders?.map((p) => ({\n        id: p.id as any,\n        type: p.type,\n        ...(p.type === 'standard' && {\n          client_id: p.clientId,\n          client_secret: p.clientSecret,\n          facebook_config_id: p.facebookConfigId,\n          microsoft_tenant_id: p.microsoftTenantId,\n        }),\n      })),\n      email_config: options.config?.emailConfig && (\n        options.config.emailConfig.type === 'shared' ? {\n          type: 'shared',\n        } : {\n          type: 'standard',\n          host: options.config.emailConfig.host,\n          port: options.config.emailConfig.port,\n          username: options.config.emailConfig.username,\n          password: options.config.emailConfig.password,\n          sender_name: options.config.emailConfig.senderName,\n          sender_email: options.config.emailConfig.senderEmail,\n        }\n      ),\n      email_theme: options.config?.emailTheme,\n      sign_up_enabled: options.config?.signUpEnabled,\n      credential_enabled: options.config?.credentialEnabled,\n      magic_link_enabled: options.config?.magicLinkEnabled,\n      passkey_enabled: options.config?.passkeyEnabled,\n      allow_localhost: options.config?.allowLocalhost,\n      create_team_on_sign_up: options.config?.createTeamOnSignUp,\n      client_team_creation_enabled: options.config?.clientTeamCreationEnabled,\n      client_user_deletion_enabled: options.config?.clientUserDeletionEnabled,\n      team_creator_default_permissions: options.config?.teamCreatorDefaultPermissions,\n      team_member_default_permissions: options.config?.teamMemberDefaultPermissions,\n      user_default_permissions: options.config?.userDefaultPermissions,\n      oauth_account_merge_strategy: options.config?.oauthAccountMergeStrategy,\n      allow_user_api_keys: options.config?.allowUserApiKeys,\n      allow_team_api_keys: options.config?.allowTeamApiKeys,\n    },\n  };\n}\n\nexport type AdminProjectCreateOptions = Omit<AdminProjectUpdateOptions, 'displayName'> & {\n  displayName: string,\n  teamId: string,\n};\nexport function adminProjectCreateOptionsToCrud(options: AdminProjectCreateOptions): AdminUserProjectsCrud[\"Server\"][\"Create\"] {\n  return {\n    ...adminProjectUpdateOptionsToCrud(options),\n    display_name: options.displayName,\n    owner_team_id: options.teamId,\n  };\n}\n"],"names":[],"mappings":";;;;;;;AAgEO,SAAS,gCAAgC,OAAA,EAAqE;IACnH,OAAO;QACL,cAAc,QAAQ,WAAA;QACtB,aAAa,QAAQ,WAAA;QACrB,oBAAoB,QAAQ,gBAAA;QAC5B,UAAU,QAAQ,OAAA;QAClB,eAAe,QAAQ,WAAA;QACvB,oBAAoB,QAAQ,eAAA;QAC5B,yBAAyB,QAAQ,mBAAA;QACjC,QAAQ;YACN,SAAS,QAAQ,MAAA,EAAQ,SAAS,IAAI,CAAC,IAAA,CAAO;oBAC5C,QAAQ,EAAE,MAAA;oBACV,cAAc,EAAE,WAAA;gBAClB,CAAA,CAAE;YACF,iBAAiB,QAAQ,MAAA,EAAQ,gBAAgB,IAAI,CAAC,IAAA,CAAO;oBAC3D,IAAI,EAAE,EAAA;oBACN,MAAM,EAAE,IAAA;oBACR,GAAI,EAAE,IAAA,KAAS,cAAc;wBAC3B,WAAW,EAAE,QAAA;wBACb,eAAe,EAAE,YAAA;wBACjB,oBAAoB,EAAE,gBAAA;wBACtB,qBAAqB,EAAE,iBAAA;oBACzB,CAAA;gBACF,CAAA,CAAE;YACF,cAAc,QAAQ,MAAA,EAAQ,eAAA,CAC5B,QAAQ,MAAA,CAAO,WAAA,CAAY,IAAA,KAAS,WAAW;gBAC7C,MAAM;YACR,IAAI;gBACF,MAAM;gBACN,MAAM,QAAQ,MAAA,CAAO,WAAA,CAAY,IAAA;gBACjC,MAAM,QAAQ,MAAA,CAAO,WAAA,CAAY,IAAA;gBACjC,UAAU,QAAQ,MAAA,CAAO,WAAA,CAAY,QAAA;gBACrC,UAAU,QAAQ,MAAA,CAAO,WAAA,CAAY,QAAA;gBACrC,aAAa,QAAQ,MAAA,CAAO,WAAA,CAAY,UAAA;gBACxC,cAAc,QAAQ,MAAA,CAAO,WAAA,CAAY,WAAA;YAC3C,CAAA;YAEF,aAAa,QAAQ,MAAA,EAAQ;YAC7B,iBAAiB,QAAQ,MAAA,EAAQ;YACjC,oBAAoB,QAAQ,MAAA,EAAQ;YACpC,oBAAoB,QAAQ,MAAA,EAAQ;YACpC,iBAAiB,QAAQ,MAAA,EAAQ;YACjC,iBAAiB,QAAQ,MAAA,EAAQ;YACjC,wBAAwB,QAAQ,MAAA,EAAQ;YACxC,8BAA8B,QAAQ,MAAA,EAAQ;YAC9C,8BAA8B,QAAQ,MAAA,EAAQ;YAC9C,kCAAkC,QAAQ,MAAA,EAAQ;YAClD,iCAAiC,QAAQ,MAAA,EAAQ;YACjD,0BAA0B,QAAQ,MAAA,EAAQ;YAC1C,8BAA8B,QAAQ,MAAA,EAAQ;YAC9C,qBAAqB,QAAQ,MAAA,EAAQ;YACrC,qBAAqB,QAAQ,MAAA,EAAQ;QACvC;IACF;AACF;AAMO,SAAS,gCAAgC,OAAA,EAA+E;IAC7H,OAAO;QACL,GAAG,gCAAgC,OAAO,CAAA;QAC1C,cAAc,QAAQ,WAAA;QACtB,eAAe,QAAQ,MAAA;IACzB;AACF"}},
    {"offset": {"line": 194, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack/src/lib/stack-app/apps/implementations/common.ts"],"sourcesContent":["\n//===========================================\n// THIS FILE IS AUTO-GENERATED FROM TEMPLATE. DO NOT EDIT IT DIRECTLY\n//===========================================\nimport { InternalSession } from \"@stackframe/stack-shared/dist/sessions\";\nimport { AsyncCache } from \"@stackframe/stack-shared/dist/utils/caches\";\nimport { isBrowserLike } from \"@stackframe/stack-shared/dist/utils/env\";\nimport { StackAssertionError, concatStacktraces, throwErr } from \"@stackframe/stack-shared/dist/utils/errors\";\nimport { getGlobal } from \"@stackframe/stack-shared/dist/utils/globals\";\nimport { filterUndefined, omit } from \"@stackframe/stack-shared/dist/utils/objects\";\nimport { ReactPromise } from \"@stackframe/stack-shared/dist/utils/promises\";\nimport { suspendIfSsr, use } from \"@stackframe/stack-shared/dist/utils/react\";\nimport { Result } from \"@stackframe/stack-shared/dist/utils/results\";\nimport { Store } from \"@stackframe/stack-shared/dist/utils/stores\";\nimport React, { useCallback } from \"react\"; // THIS_LINE_PLATFORM react-like\nimport { HandlerUrls, stackAppInternalsSymbol } from \"../../common\";\n\n// hack to make sure process is defined in non-node environments\n\nexport const clientVersion = \"js @stackframe/stack@2.8.54\";\nif (clientVersion.startsWith(\"STACK_COMPILE_TIME\")) {\n  throw new StackAssertionError(\"Client version was not replaced. Something went wrong during build!\");\n}\n\nconst replaceStackPortPrefix = <T extends string | undefined>(input: T): T => {\n  if (!input) return input;\n  const prefix = process.env.NEXT_PUBLIC_STACK_PORT_PREFIX;\n  return prefix ? input.replace(/\\$\\{NEXT_PUBLIC_STACK_PORT_PREFIX:-81\\}/g, prefix) as T : input;\n};\n\n\nexport const createCache = <D extends any[], T>(fetcher: (dependencies: D) => Promise<T>) => {\n  return new AsyncCache<D, Result<T>>(\n    async (dependencies) => await Result.fromThrowingAsync(async () => await fetcher(dependencies)),\n    {},\n  );\n};\n\nexport const createCacheBySession = <D extends any[], T>(fetcher: (session: InternalSession, extraDependencies: D) => Promise<T> ) => {\n  return new AsyncCache<[InternalSession, ...D], Result<T>>(\n    async ([session, ...extraDependencies]) => await Result.fromThrowingAsync(async () => await fetcher(session, extraDependencies)),\n    {\n      onSubscribe: ([session], refresh) => {\n        const handler = session.onInvalidate(() => refresh());\n        return () => handler.unsubscribe();\n      },\n    },\n  );\n};\n\n\ntype AppLike = { [stackAppInternalsSymbol]: { getConstructorOptions: () => any } };\nexport function resolveConstructorOptions<T extends { inheritsFrom?: AppLike }>(options: T): T & { inheritsFrom?: undefined } {\n  return {\n    ...options.inheritsFrom?.[stackAppInternalsSymbol].getConstructorOptions() ?? {},\n    ...filterUndefined(omit(options, [\"inheritsFrom\"])),\n  };\n}\n\nexport function getUrls(partial: Partial<HandlerUrls>): HandlerUrls {\n  const handler = partial.handler ?? \"/handler\";\n  const home = partial.home ?? \"/\";\n  const afterSignIn = partial.afterSignIn ?? home;\n  return {\n    handler,\n    signIn: `${handler}/sign-in`,\n    afterSignIn: home,\n    signUp: `${handler}/sign-up`,\n    afterSignUp: afterSignIn,\n    signOut: `${handler}/sign-out`,\n    afterSignOut: home,\n    emailVerification: `${handler}/email-verification`,\n    passwordReset: `${handler}/password-reset`,\n    forgotPassword: `${handler}/forgot-password`,\n    oauthCallback: `${handler}/oauth-callback`,\n    magicLinkCallback: `${handler}/magic-link-callback`,\n    home: home,\n    accountSettings: `${handler}/account-settings`,\n    error: `${handler}/error`,\n    teamInvitation: `${handler}/team-invitation`,\n    mfa: `${handler}/mfa`,\n    ...filterUndefined(partial),\n  };\n}\n\nexport function getDefaultProjectId() {\n  return process.env.NEXT_PUBLIC_STACK_PROJECT_ID || process.env.STACK_PROJECT_ID || throwErr(new Error(\"Welcome to Stack Auth! It seems that you haven't provided a project ID. Please create a project on the Stack dashboard at https://app.stack-auth.com and put it in the NEXT_PUBLIC_STACK_PROJECT_ID environment variable.\"));\n}\n\nexport function getDefaultPublishableClientKey() {\n  return process.env.NEXT_PUBLIC_STACK_PUBLISHABLE_CLIENT_KEY || process.env.STACK_PUBLISHABLE_CLIENT_KEY || throwErr(new Error(\"Welcome to Stack Auth! It seems that you haven't provided a publishable client key. Please create an API key for your project on the Stack dashboard at https://app.stack-auth.com and copy your publishable client key into the NEXT_PUBLIC_STACK_PUBLISHABLE_CLIENT_KEY environment variable.\"));\n}\n\nexport function getDefaultSecretServerKey() {\n  return process.env.STACK_SECRET_SERVER_KEY || throwErr(new Error(\"No secret server key provided. Please copy your key from the Stack dashboard and put it in the STACK_SECRET_SERVER_KEY environment variable.\"));\n}\n\nexport function getDefaultSuperSecretAdminKey() {\n  return process.env.STACK_SUPER_SECRET_ADMIN_KEY || throwErr(new Error(\"No super secret admin key provided. Please copy your key from the Stack dashboard and put it in the STACK_SUPER_SECRET_ADMIN_KEY environment variable.\"));\n}\n\nexport function getDefaultExtraRequestHeaders() {\n  return JSON.parse(process.env.NEXT_PUBLIC_STACK_EXTRA_REQUEST_HEADERS || process.env.STACK_EXTRA_REQUEST_HEADERS || '{}');\n}\n\n/**\n * Returns the base URL for the Stack API.\n *\n * The URL can be specified in several ways, in order of precedence:\n * 1. Directly through userSpecifiedBaseUrl parameter as string or browser/server object\n * 2. Through environment variables:\n *    - Browser: NEXT_PUBLIC_BROWSER_STACK_API_URL\n *    - Server: NEXT_PUBLIC_SERVER_STACK_API_URL\n *    - Fallback: NEXT_PUBLIC_STACK_API_URL or NEXT_PUBLIC_STACK_URL\n * 3. Default base URL if none of the above are specified\n *\n * The function also ensures the URL doesn't end with a trailing slash\n * by removing it if present.\n *\n * @param userSpecifiedBaseUrl - Optional URL override as string or {browser, server} object\n * @returns The configured base URL without trailing slash\n\n */\nexport function getBaseUrl(userSpecifiedBaseUrl: string | { browser: string, server: string } | undefined) {\n  let url;\n  if (userSpecifiedBaseUrl) {\n    if (typeof userSpecifiedBaseUrl === \"string\") {\n      url = userSpecifiedBaseUrl;\n    } else {\n      if (isBrowserLike()) {\n        url = userSpecifiedBaseUrl.browser;\n      } else {\n        url = userSpecifiedBaseUrl.server;\n      }\n    }\n  } else {\n    // note: NEXT_PUBLIC_BROWSER_STACK_API_URL was renamed to NEXT_PUBLIC_STACK_API_URL_BROWSER, and NEXT_PUBLIC_STACK_URL to NEXT_PUBLIC_STACK_API_URL\n    if (isBrowserLike()) {\n      url = process.env.NEXT_PUBLIC_BROWSER_STACK_API_URL || process.env.NEXT_PUBLIC_STACK_API_URL_BROWSER || process.env.STACK_API_URL_BROWSER;\n    } else {\n      url = process.env.NEXT_PUBLIC_SERVER_STACK_API_URL || process.env.NEXT_PUBLIC_STACK_API_URL_SERVER || process.env.STACK_API_URL_SERVER;\n    }\n    url = url || process.env.NEXT_PUBLIC_STACK_API_URL || process.env.STACK_API_URL || process.env.NEXT_PUBLIC_STACK_URL || defaultBaseUrl;\n  }\n\n  return replaceStackPortPrefix(url.endsWith('/') ? url.slice(0, -1) : url);\n}\nexport const defaultBaseUrl = \"https://api.stack-auth.com\";\n\nexport type TokenObject = {\n  accessToken: string | null,\n  refreshToken: string | null,\n};\n\nexport function createEmptyTokenStore() {\n  return new Store<TokenObject>({\n    refreshToken: null,\n    accessToken: null,\n  });\n}\n\n\nconst cachePromiseByHookId = new Map<string, ReactPromise<Result<unknown>>>();\nexport function useAsyncCache<D extends any[], T>(cache: AsyncCache<D, Result<T>>, dependencies: D, caller: string): T {\n  // we explicitly don't want to run this hook in SSR\n  suspendIfSsr(caller);\n\n  // on the dashboard, we do some perf monitoring for pre-fetching which should hook right in here\n  const asyncCacheHooks: any[] = getGlobal(\"use-async-cache-execution-hooks\") ?? [];\n  for (const hook of asyncCacheHooks) {\n    hook({ cache, caller, dependencies });\n  }\n\n  const id = React.useId();\n\n  // whenever the dependencies change, we need to refresh the promise cache\n  React.useEffect(() => {\n    cachePromiseByHookId.delete(id);\n  }, [...dependencies, id]);\n\n  const subscribe = useCallback((cb: () => void) => {\n    const { unsubscribe } = cache.onStateChange(dependencies, () => {\n      cachePromiseByHookId.delete(id);\n      cb();\n    });\n    return unsubscribe;\n  }, [cache, ...dependencies]);\n  const getSnapshot = useCallback(() => {\n    // React checks whether a promise passed to `use` is still the same as the previous one by comparing the reference.\n    // If we didn't cache here, this wouldn't work because the promise would be recreated every time the value changes.\n    if (!cachePromiseByHookId.has(id)) {\n      cachePromiseByHookId.set(id, cache.getOrWait(dependencies, \"read-write\"));\n    }\n    return cachePromiseByHookId.get(id) as ReactPromise<Result<T>>;\n  }, [cache, ...dependencies]);\n\n  // note: we must use React.useSyncExternalStore instead of importing the function directly, as it will otherwise\n  // throw an error on Next.js (\"can't import useSyncExternalStore from the server\")\n  const promise = React.useSyncExternalStore(\n    subscribe,\n    getSnapshot,\n    () => throwErr(new Error(\"getServerSnapshot should never be called in useAsyncCache because we restrict to CSR earlier\"))\n  );\n\n  const result = use(promise);\n  if (result.status === \"error\") {\n    const error = result.error;\n    if (error instanceof Error && !(error as any).__stackHasConcatenatedStacktraces) {\n      concatStacktraces(error, new Error());\n      (error as any).__stackHasConcatenatedStacktraces = true;\n    }\n    throw error;\n  }\n  return result.data;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 408, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack/src/lib/stack-app/api-keys/index.ts"],"sourcesContent":["\n//===========================================\n// THIS FILE IS AUTO-GENERATED FROM TEMPLATE. DO NOT EDIT IT DIRECTLY\n//===========================================\nimport { TeamApiKeysCrud, UserApiKeysCrud, teamApiKeysCreateInputSchema, userApiKeysCreateInputSchema } from \"@stackframe/stack-shared/dist/interface/crud/project-api-keys\";\nimport { filterUndefined } from \"@stackframe/stack-shared/dist/utils/objects\";\nimport { IfAndOnlyIf, PrettifyType } from \"@stackframe/stack-shared/dist/utils/types\";\nimport type * as yup from \"yup\";\n\nexport type ApiKeyType = \"user\" | \"team\";\n\nexport type ApiKey<Type extends ApiKeyType = ApiKeyType, IsFirstView extends boolean = false> =\n  & {\n      id: string,\n      description: string,\n      expiresAt?: Date,\n      manuallyRevokedAt?: Date | null,\n      createdAt: Date,\n      value: IfAndOnlyIf<IsFirstView, true, string, { lastFour: string }>,\n      update(options: ApiKeyUpdateOptions<Type>): Promise<void>,\n      revoke: () => Promise<void>,\n      isValid: () => boolean,\n      whyInvalid: () => \"manually-revoked\" | \"expired\" | null,\n    }\n  & (\n    | (\"user\" extends Type ? { type: \"user\", userId: string } : never)\n    | (\"team\" extends Type ? { type: \"team\", teamId: string } : never)\n  );\n\nexport type UserApiKeyFirstView = PrettifyType<ApiKey<\"user\", true>>;\nexport type UserApiKey = PrettifyType<ApiKey<\"user\", false>>;\n\nexport type TeamApiKeyFirstView = PrettifyType<ApiKey<\"team\", true>>;\nexport type TeamApiKey = PrettifyType<ApiKey<\"team\", false>>;\n\nexport type ApiKeyCreationOptions<Type extends ApiKeyType = ApiKeyType> =\n  & {\n    description: string,\n    expiresAt: Date | null,\n    /**\n     * Whether the API key should be considered public. A public API key will not be detected by the secret scanner, which\n     * automatically revokes API keys when it detects that they may have been exposed to the public.\n     */\n    isPublic?: boolean,\n  };\nexport function apiKeyCreationOptionsToCrud(type: \"user\", userId: string, options: ApiKeyCreationOptions<\"user\">): Promise<yup.InferType<typeof userApiKeysCreateInputSchema>>;\nexport function apiKeyCreationOptionsToCrud(type: \"team\", teamId: string, options: ApiKeyCreationOptions<\"team\">): Promise<yup.InferType<typeof teamApiKeysCreateInputSchema>>;\nexport function apiKeyCreationOptionsToCrud(type: ApiKeyType, userIdOrTeamId: string, options: ApiKeyCreationOptions): Promise<yup.InferType<typeof userApiKeysCreateInputSchema> | yup.InferType<typeof teamApiKeysCreateInputSchema>>;\nexport async function apiKeyCreationOptionsToCrud(type: ApiKeyType, userIdOrTeamId: string, options: ApiKeyCreationOptions): Promise<yup.InferType<typeof userApiKeysCreateInputSchema> | yup.InferType<typeof teamApiKeysCreateInputSchema>> {\n  return {\n    description: options.description,\n    expires_at_millis: options.expiresAt == null ? options.expiresAt : options.expiresAt.getTime(),\n    is_public: options.isPublic,\n    ...(type === \"user\" ? { user_id: userIdOrTeamId } : { team_id: userIdOrTeamId }),\n  };\n}\n\n\nexport type ApiKeyUpdateOptions<Type extends ApiKeyType = ApiKeyType> = {\n  description?: string,\n  expiresAt?: Date | null,\n  revoked?: boolean,\n};\nexport function apiKeyUpdateOptionsToCrud(type: \"user\", options: ApiKeyUpdateOptions<\"user\">): Promise<UserApiKeysCrud[\"Client\"][\"Update\"]>;\nexport function apiKeyUpdateOptionsToCrud(type: \"team\", options: ApiKeyUpdateOptions<\"team\">): Promise<TeamApiKeysCrud[\"Client\"][\"Update\"]>;\nexport function apiKeyUpdateOptionsToCrud(type: ApiKeyType, options: ApiKeyUpdateOptions): Promise<UserApiKeysCrud[\"Client\"][\"Update\"] | TeamApiKeysCrud[\"Client\"][\"Update\"]>;\nexport async function apiKeyUpdateOptionsToCrud(type: ApiKeyType, options: ApiKeyUpdateOptions): Promise<UserApiKeysCrud[\"Client\"][\"Update\"] | TeamApiKeysCrud[\"Client\"][\"Update\"]> {\n  return filterUndefined({\n    description: options.description,\n    expires_at_millis: options.expiresAt == null ? options.expiresAt : options.expiresAt.getTime(),\n    revoked: options.revoked,\n  });\n}\n"],"names":[],"mappings":";;;;;;;AAKA,SAAS,uBAAuB;;AA2ChC,eAAsB,4BAA4B,IAAA,EAAkB,cAAA,EAAwB,OAAA,EAAkJ;IAC5O,OAAO;QACL,aAAa,QAAQ,WAAA;QACrB,mBAAmB,QAAQ,SAAA,IAAa,OAAO,QAAQ,SAAA,GAAY,QAAQ,SAAA,CAAU,OAAA,CAAQ;QAC7F,WAAW,QAAQ,QAAA;QACnB,GAAI,SAAS,SAAS;YAAE,SAAS;QAAe,IAAI;YAAE,SAAS;QAAe,CAAA;IAChF;AACF;AAWA,eAAsB,0BAA0B,IAAA,EAAkB,OAAA,EAAkH;IAClL,WAAO,4OAAA,EAAgB;QACrB,aAAa,QAAQ,WAAA;QACrB,mBAAmB,QAAQ,SAAA,IAAa,OAAO,QAAQ,SAAA,GAAY,QAAQ,SAAA,CAAU,OAAA,CAAQ;QAC7F,SAAS,QAAQ,OAAA;IACnB,CAAC;AACH"}},
    {"offset": {"line": 442, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack/src/lib/stack-app/contact-channels/index.ts"],"sourcesContent":["\n//===========================================\n// THIS FILE IS AUTO-GENERATED FROM TEMPLATE. DO NOT EDIT IT DIRECTLY\n//===========================================\nimport { ContactChannelsCrud } from \"@stackframe/stack-shared/dist/interface/crud/contact-channels\";\n\n\nexport type ContactChannel = {\n  id: string,\n  value: string,\n  type: 'email',\n  isPrimary: boolean,\n  isVerified: boolean,\n  usedForAuth: boolean,\n\n  sendVerificationEmail(options?: { callbackUrl?: string }): Promise<void>,\n  update(data: ContactChannelUpdateOptions): Promise<void>,\n  delete(): Promise<void>,\n}\n\nexport type ContactChannelCreateOptions = {\n  value: string,\n  type: 'email',\n  usedForAuth: boolean,\n  isPrimary?: boolean,\n}\n\nexport function contactChannelCreateOptionsToCrud(userId: string, options: ContactChannelCreateOptions): ContactChannelsCrud[\"Client\"][\"Create\"] {\n  return {\n    value: options.value,\n    type: options.type,\n    used_for_auth: options.usedForAuth,\n    is_primary: options.isPrimary,\n    user_id: userId,\n  };\n}\n\nexport type ContactChannelUpdateOptions = {\n  usedForAuth?: boolean,\n  value?: string,\n  isPrimary?: boolean,\n}\n\nexport function contactChannelUpdateOptionsToCrud(options: ContactChannelUpdateOptions): ContactChannelsCrud[\"Client\"][\"Update\"] {\n  return {\n    value: options.value,\n    used_for_auth: options.usedForAuth,\n    is_primary: options.isPrimary,\n  };\n}\n\nexport type ServerContactChannel = ContactChannel & {\n  update(data: ServerContactChannelUpdateOptions): Promise<void>,\n}\nexport type ServerContactChannelUpdateOptions = ContactChannelUpdateOptions & {\n  isVerified?: boolean,\n}\n\nexport function serverContactChannelUpdateOptionsToCrud(options: ServerContactChannelUpdateOptions): ContactChannelsCrud[\"Server\"][\"Update\"] {\n  return {\n    value: options.value,\n    is_verified: options.isVerified,\n    used_for_auth: options.usedForAuth,\n    is_primary: options.isPrimary,\n  };\n}\n\nexport type ServerContactChannelCreateOptions = ContactChannelCreateOptions & {\n  isVerified?: boolean,\n}\nexport function serverContactChannelCreateOptionsToCrud(userId: string, options: ServerContactChannelCreateOptions): ContactChannelsCrud[\"Server\"][\"Create\"] {\n  return {\n    type: options.type,\n    value: options.value,\n    is_verified: options.isVerified,\n    user_id: userId,\n    used_for_auth: options.usedForAuth,\n    is_primary: options.isPrimary,\n  };\n}\n"],"names":[],"mappings":";;;;;;;;;;;AA2BO,SAAS,kCAAkC,MAAA,EAAgB,OAAA,EAA+E;IAC/I,OAAO;QACL,OAAO,QAAQ,KAAA;QACf,MAAM,QAAQ,IAAA;QACd,eAAe,QAAQ,WAAA;QACvB,YAAY,QAAQ,SAAA;QACpB,SAAS;IACX;AACF;AAQO,SAAS,kCAAkC,OAAA,EAA+E;IAC/H,OAAO;QACL,OAAO,QAAQ,KAAA;QACf,eAAe,QAAQ,WAAA;QACvB,YAAY,QAAQ,SAAA;IACtB;AACF;AASO,SAAS,wCAAwC,OAAA,EAAqF;IAC3I,OAAO;QACL,OAAO,QAAQ,KAAA;QACf,aAAa,QAAQ,UAAA;QACrB,eAAe,QAAQ,WAAA;QACvB,YAAY,QAAQ,SAAA;IACtB;AACF;AAKO,SAAS,wCAAwC,MAAA,EAAgB,OAAA,EAAqF;IAC3J,OAAO;QACL,MAAM,QAAQ,IAAA;QACd,OAAO,QAAQ,KAAA;QACf,aAAa,QAAQ,UAAA;QACrB,SAAS;QACT,eAAe,QAAQ,WAAA;QACvB,YAAY,QAAQ,SAAA;IACtB;AACF"}},
    {"offset": {"line": 493, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack/src/lib/stack-app/teams/index.ts"],"sourcesContent":["\n//===========================================\n// THIS FILE IS AUTO-GENERATED FROM TEMPLATE. DO NOT EDIT IT DIRECTLY\n//===========================================\nimport { TeamsCrud } from \"@stackframe/stack-shared/dist/interface/crud/teams\";\nimport { ReadonlyJson } from \"@stackframe/stack-shared/dist/utils/json\";\n\nimport { ApiKeyCreationOptions, TeamApiKey, TeamApiKeyFirstView } from \"../api-keys\";\nimport { AsyncStoreProperty } from \"../common\";\nimport { Customer } from \"../customers\";\nimport { ServerUser } from \"../users\";\n\n\nexport type TeamMemberProfile = {\n  displayName: string | null,\n  profileImageUrl: string | null,\n}\n\nexport type TeamMemberProfileUpdateOptions = {\n  displayName?: string,\n  profileImageUrl?: string | null,\n};\n\nexport type EditableTeamMemberProfile = TeamMemberProfile & {\n  update(update: TeamMemberProfileUpdateOptions): Promise<void>,\n}\n\nexport type TeamUser = {\n  id: string,\n  teamProfile: TeamMemberProfile,\n}\n\nexport type TeamInvitation = {\n  id: string,\n  recipientEmail: string | null,\n  expiresAt: Date,\n  revoke(): Promise<void>,\n}\n\nexport type Team = {\n  id: string,\n  displayName: string,\n  profileImageUrl: string | null,\n  clientMetadata: any,\n  clientReadOnlyMetadata: any,\n  inviteUser(options: { email: string, callbackUrl?: string }): Promise<void>,\n  listUsers(): Promise<TeamUser[]>,\n  useUsers(): TeamUser[], // THIS_LINE_PLATFORM react-like\n  listInvitations(): Promise<TeamInvitation[]>,\n  useInvitations(): TeamInvitation[], // THIS_LINE_PLATFORM react-like\n  update(update: TeamUpdateOptions): Promise<void>,\n  delete(): Promise<void>,\n  createApiKey(options: ApiKeyCreationOptions<\"team\">): Promise<TeamApiKeyFirstView>,\n} & AsyncStoreProperty<\"apiKeys\", [], TeamApiKey[], true> & Customer;\n\nexport type TeamUpdateOptions = {\n  displayName?: string,\n  profileImageUrl?: string | null,\n  clientMetadata?: ReadonlyJson,\n};\nexport function teamUpdateOptionsToCrud(options: TeamUpdateOptions): TeamsCrud[\"Client\"][\"Update\"] {\n  return {\n    display_name: options.displayName,\n    profile_image_url: options.profileImageUrl,\n    client_metadata: options.clientMetadata,\n  };\n}\n\nexport type TeamCreateOptions = {\n  displayName: string,\n  profileImageUrl?: string,\n}\nexport function teamCreateOptionsToCrud(options: TeamCreateOptions, creatorUserId: string): TeamsCrud[\"Client\"][\"Create\"] {\n  return {\n    display_name: options.displayName,\n    profile_image_url: options.profileImageUrl,\n    creator_user_id: creatorUserId,\n  };\n}\n\n\nexport type ServerTeamMemberProfile = TeamMemberProfile;\n\nexport type ServerTeamUser = ServerUser & {\n  teamProfile: ServerTeamMemberProfile,\n}\n\nexport type ServerTeam = {\n  createdAt: Date,\n  serverMetadata: any,\n  listUsers(): Promise<ServerTeamUser[]>,\n  useUsers(): ServerUser[], // THIS_LINE_PLATFORM react-like\n  update(update: ServerTeamUpdateOptions): Promise<void>,\n  delete(): Promise<void>,\n  addUser(userId: string): Promise<void>,\n  inviteUser(options: { email: string, callbackUrl?: string }): Promise<void>,\n  removeUser(userId: string): Promise<void>,\n} & Team;\n\nexport type ServerListUsersOptions = {\n  cursor?: string,\n  limit?: number,\n  orderBy?: 'signedUpAt',\n  desc?: boolean,\n  query?: string,\n  includeAnonymous?: boolean,\n};\n\nexport type ServerTeamCreateOptions = TeamCreateOptions & {\n  creatorUserId?: string,\n};\nexport function serverTeamCreateOptionsToCrud(options: ServerTeamCreateOptions): TeamsCrud[\"Server\"][\"Create\"] {\n  return {\n    display_name: options.displayName,\n    profile_image_url: options.profileImageUrl,\n    creator_user_id: options.creatorUserId,\n  };\n}\n\nexport type ServerTeamUpdateOptions = TeamUpdateOptions & {\n  clientReadOnlyMetadata?: ReadonlyJson,\n  serverMetadata?: ReadonlyJson,\n};\nexport function serverTeamUpdateOptionsToCrud(options: ServerTeamUpdateOptions): TeamsCrud[\"Server\"][\"Update\"] {\n  return {\n    display_name: options.displayName,\n    profile_image_url: options.profileImageUrl,\n    client_metadata: options.clientMetadata,\n    client_read_only_metadata: options.clientReadOnlyMetadata,\n    server_metadata: options.serverMetadata,\n  };\n}\n"],"names":[],"mappings":";;;;;;;;;;;AA4DO,SAAS,wBAAwB,OAAA,EAA2D;IACjG,OAAO;QACL,cAAc,QAAQ,WAAA;QACtB,mBAAmB,QAAQ,eAAA;QAC3B,iBAAiB,QAAQ,cAAA;IAC3B;AACF;AAMO,SAAS,wBAAwB,OAAA,EAA4B,aAAA,EAAsD;IACxH,OAAO;QACL,cAAc,QAAQ,WAAA;QACtB,mBAAmB,QAAQ,eAAA;QAC3B,iBAAiB;IACnB;AACF;AAiCO,SAAS,8BAA8B,OAAA,EAAiE;IAC7G,OAAO;QACL,cAAc,QAAQ,WAAA;QACtB,mBAAmB,QAAQ,eAAA;QAC3B,iBAAiB,QAAQ,aAAA;IAC3B;AACF;AAMO,SAAS,8BAA8B,OAAA,EAAiE;IAC7G,OAAO;QACL,cAAc,QAAQ,WAAA;QACtB,mBAAmB,QAAQ,eAAA;QAC3B,iBAAiB,QAAQ,cAAA;QACzB,2BAA2B,QAAQ,sBAAA;QACnC,iBAAiB,QAAQ,cAAA;IAC3B;AACF"}},
    {"offset": {"line": 540, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack/src/lib/stack-app/users/index.ts"],"sourcesContent":["\n//===========================================\n// THIS FILE IS AUTO-GENERATED FROM TEMPLATE. DO NOT EDIT IT DIRECTLY\n//===========================================\nimport { KnownErrors } from \"@stackframe/stack-shared\";\nimport { CurrentUserCrud } from \"@stackframe/stack-shared/dist/interface/crud/current-user\";\nimport { UsersCrud } from \"@stackframe/stack-shared/dist/interface/crud/users\";\nimport { InternalSession } from \"@stackframe/stack-shared/dist/sessions\";\nimport { encodeBase64 } from \"@stackframe/stack-shared/dist/utils/bytes\";\nimport { GeoInfo } from \"@stackframe/stack-shared/dist/utils/geo\";\nimport { ReadonlyJson } from \"@stackframe/stack-shared/dist/utils/json\";\nimport { ProviderType } from \"@stackframe/stack-shared/dist/utils/oauth\";\nimport { Result } from \"@stackframe/stack-shared/dist/utils/results\";\nimport { ApiKeyCreationOptions, UserApiKey, UserApiKeyFirstView } from \"../api-keys\";\nimport { AsyncStoreProperty, AuthLike } from \"../common\";\nimport { OAuthConnection } from \"../connected-accounts\";\nimport { ContactChannel, ContactChannelCreateOptions, ServerContactChannel, ServerContactChannelCreateOptions } from \"../contact-channels\";\nimport { Customer } from \"../customers\";\nimport { NotificationCategory } from \"../notification-categories\";\nimport { AdminTeamPermission, TeamPermission } from \"../permissions\";\nimport { AdminOwnedProject, AdminProjectCreateOptions } from \"../projects\";\nimport { EditableTeamMemberProfile, ServerTeam, ServerTeamCreateOptions, Team, TeamCreateOptions } from \"../teams\";\n\nconst userGetterErrorMessage = \"Stack Auth: useUser() already returns the user object. Use `const user = useUser()` (or `const user = await app.getUser()`) instead of destructuring it like `const { user } = ...`.\";\n\nexport function attachUserDestructureGuard(target: object): void {\n  const descriptor = Object.getOwnPropertyDescriptor(target, \"user\");\n  if (descriptor?.get === guardGetter) {\n    return;\n  }\n\n  Object.defineProperty(target, \"user\", {\n    get: guardGetter,\n    configurable: false,\n    enumerable: false,\n  });\n}\n\nfunction guardGetter(): never {\n  throw new Error(userGetterErrorMessage);\n}\n\nexport type OAuthProvider = {\n  readonly id: string,\n  readonly type: string,\n  readonly userId: string,\n  readonly accountId?: string,\n  readonly email?: string,\n  readonly allowSignIn: boolean,\n  readonly allowConnectedAccounts: boolean,\n  update(data: { allowSignIn?: boolean, allowConnectedAccounts?: boolean }): Promise<Result<void,\n    InstanceType<typeof KnownErrors.OAuthProviderAccountIdAlreadyUsedForSignIn>\n  >>,\n  delete(): Promise<void>,\n};\n\nexport type ServerOAuthProvider = {\n  readonly id: string,\n  readonly type: string,\n  readonly userId: string,\n  readonly accountId: string,\n  readonly email?: string,\n  readonly allowSignIn: boolean,\n  readonly allowConnectedAccounts: boolean,\n  update(data: { accountId?: string, email?: string, allowSignIn?: boolean, allowConnectedAccounts?: boolean }): Promise<Result<void,\n    InstanceType<typeof KnownErrors.OAuthProviderAccountIdAlreadyUsedForSignIn>\n  >>,\n  delete(): Promise<void>,\n};\n\n\nexport type Session = {\n  getTokens(): Promise<{ accessToken: string | null, refreshToken: string | null }>,\n};\n\n/**\n * Contains everything related to the current user session.\n */\nexport type Auth = AuthLike<{}> & {\n  readonly _internalSession: InternalSession,\n  readonly currentSession: Session,\n};\n\n/**\n * ```\n * +----------+-------------+-------------------+\n * |    \\     |   !Server   |      Server       |\n * +----------+-------------+-------------------+\n * | !Session | User        | ServerUser        |\n * | Session  | CurrentUser | CurrentServerUser |\n * +----------+-------------+-------------------+\n * ```\n *\n * The fields on each of these types are available iff:\n * BaseUser: true\n * Auth: Session\n * ServerBaseUser: Server\n * UserExtra: Session OR Server\n *\n * The types are defined as follows (in the typescript manner):\n * User = BaseUser\n * CurrentUser = BaseUser & Auth & UserExtra\n * ServerUser = BaseUser & ServerBaseUser & UserExtra\n * CurrentServerUser = BaseUser & ServerBaseUser & Auth & UserExtra\n **/\n\nexport type BaseUser = {\n  readonly id: string,\n\n  readonly displayName: string | null,\n\n  /**\n   * The user's email address.\n   *\n   * Note: This might NOT be unique across multiple users, so always use `id` for unique identification.\n   */\n  readonly primaryEmail: string | null,\n  readonly primaryEmailVerified: boolean,\n  readonly profileImageUrl: string | null,\n\n  readonly signedUpAt: Date,\n\n  readonly clientMetadata: any,\n  readonly clientReadOnlyMetadata: any,\n\n  /**\n   * Whether the user has a password set.\n   */\n  readonly hasPassword: boolean,\n  readonly otpAuthEnabled: boolean,\n  readonly passkeyAuthEnabled: boolean,\n\n  readonly isMultiFactorRequired: boolean,\n  readonly isAnonymous: boolean,\n  toClientJson(): CurrentUserCrud[\"Client\"][\"Read\"],\n\n  /**\n   * @deprecated, use contact channel's usedForAuth instead\n   */\n  readonly emailAuthEnabled: boolean,\n  /**\n   * @deprecated\n   */\n  readonly oauthProviders: readonly { id: string }[],\n}\n\nexport type UserExtra = {\n  setDisplayName(displayName: string): Promise<void>,\n  /** @deprecated Use contact channel's sendVerificationEmail instead */\n  sendVerificationEmail(): Promise<KnownErrors[\"EmailAlreadyVerified\"] | void>,\n  setClientMetadata(metadata: any): Promise<void>,\n  updatePassword(options: { oldPassword: string, newPassword: string}): Promise<KnownErrors[\"PasswordConfirmationMismatch\"] | KnownErrors[\"PasswordRequirementsNotMet\"] | void>,\n  setPassword(options: { password: string }): Promise<KnownErrors[\"PasswordRequirementsNotMet\"] | void>,\n\n  /**\n   * A shorthand method to update multiple fields of the user at once.\n   */\n  update(update: UserUpdateOptions): Promise<void>,\n\n  useContactChannels(): ContactChannel[], // THIS_LINE_PLATFORM react-like\n  listContactChannels(): Promise<ContactChannel[]>,\n  createContactChannel(data: ContactChannelCreateOptions): Promise<ContactChannel>,\n\n  useNotificationCategories(): NotificationCategory[], // THIS_LINE_PLATFORM react-like\n  listNotificationCategories(): Promise<NotificationCategory[]>,\n\n  delete(): Promise<void>,\n\n  getConnectedAccount(id: ProviderType, options: { or: 'redirect', scopes?: string[] }): Promise<OAuthConnection>,\n  getConnectedAccount(id: ProviderType, options?: { or?: 'redirect' | 'throw' | 'return-null', scopes?: string[] }): Promise<OAuthConnection | null>,\n\n  useConnectedAccount(id: ProviderType, options: { or: 'redirect', scopes?: string[] }): OAuthConnection,\n  useConnectedAccount(id: ProviderType, options?: { or?: 'redirect' | 'throw' | 'return-null', scopes?: string[] }): OAuthConnection | null,\n\n  hasPermission(scope: Team, permissionId: string): Promise<boolean>,\n  hasPermission(permissionId: string): Promise<boolean>,\n\n  getPermission(scope: Team, permissionId: string): Promise<TeamPermission | null>,\n  getPermission(permissionId: string): Promise<TeamPermission | null>,\n\n  listPermissions(scope: Team, options?: { recursive?: boolean }): Promise<TeamPermission[]>,\n  listPermissions(options?: { recursive?: boolean }): Promise<TeamPermission[]>,\n\n  usePermissions(scope: Team, options?: { recursive?: boolean }): TeamPermission[],\n  usePermissions(options?: { recursive?: boolean }): TeamPermission[],\n\n  usePermission(scope: Team, permissionId: string): TeamPermission | null,\n  usePermission(permissionId: string): TeamPermission | null,\n\n  readonly selectedTeam: Team | null,\n  setSelectedTeam(team: Team | null): Promise<void>,\n  createTeam(data: TeamCreateOptions): Promise<Team>,\n  leaveTeam(team: Team): Promise<void>,\n\n  getActiveSessions(): Promise<ActiveSession[]>,\n  revokeSession(sessionId: string): Promise<void>,\n  getTeamProfile(team: Team): Promise<EditableTeamMemberProfile>,\n  useTeamProfile(team: Team): EditableTeamMemberProfile, // THIS_LINE_PLATFORM react-like\n\n  createApiKey(options: ApiKeyCreationOptions<\"user\">): Promise<UserApiKeyFirstView>,\n\n  useOAuthProviders(): OAuthProvider[], // THIS_LINE_PLATFORM react-like\n  listOAuthProviders(): Promise<OAuthProvider[]>,\n\n  useOAuthProvider(id: string): OAuthProvider | null, // THIS_LINE_PLATFORM react-like\n  getOAuthProvider(id: string): Promise<OAuthProvider | null>,\n\n  registerPasskey(options?: { hostname?: string }): Promise<Result<undefined, KnownErrors[\"PasskeyRegistrationFailed\"] | KnownErrors[\"PasskeyWebAuthnError\"]>>,\n}\n& AsyncStoreProperty<\"apiKeys\", [], UserApiKey[], true>\n& AsyncStoreProperty<\"team\", [id: string], Team | null, false>\n& AsyncStoreProperty<\"teams\", [], Team[], true>\n& AsyncStoreProperty<\"permission\", [scope: Team, permissionId: string, options?: { recursive?: boolean }], TeamPermission | null, false>\n& AsyncStoreProperty<\"permissions\", [scope: Team, options?: { recursive?: boolean }], TeamPermission[], true>;\n\nexport type InternalUserExtra =\n  & {\n    createProject(newProject: AdminProjectCreateOptions): Promise<AdminOwnedProject>,\n    transferProject(projectIdToTransfer: string, newTeamId: string): Promise<void>,\n  }\n  & AsyncStoreProperty<\"ownedProjects\", [], AdminOwnedProject[], true>\n\nexport type User = BaseUser;\n\nexport type CurrentUser = BaseUser & Auth & UserExtra & Customer;\n\nexport type CurrentInternalUser = CurrentUser & InternalUserExtra;\n\nexport type ProjectCurrentUser<ProjectId> = ProjectId extends \"internal\" ? CurrentInternalUser : CurrentUser;\n\nexport type TokenPartialUser = Pick<\n  User,\n  | \"id\"\n  | \"displayName\"\n  | \"primaryEmail\"\n  | \"primaryEmailVerified\"\n  | \"isAnonymous\"\n>\n\nexport type SyncedPartialUser = TokenPartialUser & Pick<\n  User,\n  | \"id\"\n  | \"displayName\"\n  | \"primaryEmail\"\n  | \"primaryEmailVerified\"\n  | \"profileImageUrl\"\n  | \"signedUpAt\"\n  | \"clientMetadata\"\n  | \"clientReadOnlyMetadata\"\n  | \"isAnonymous\"\n  | \"hasPassword\"\n>;\n\n\nexport type ActiveSession = {\n  id: string,\n  userId: string,\n  createdAt: Date,\n  isImpersonation: boolean,\n  lastUsedAt: Date | undefined,\n  isCurrentSession: boolean,\n  geoInfo?: GeoInfo,\n};\n\nexport type UserUpdateOptions = {\n  displayName?: string,\n  clientMetadata?: ReadonlyJson,\n  selectedTeamId?: string | null,\n  totpMultiFactorSecret?: Uint8Array | null,\n  profileImageUrl?: string | null,\n  otpAuthEnabled?: boolean,\n  passkeyAuthEnabled?:boolean,\n}\nexport function userUpdateOptionsToCrud(options: UserUpdateOptions): CurrentUserCrud[\"Client\"][\"Update\"] {\n  return {\n    display_name: options.displayName,\n    client_metadata: options.clientMetadata,\n    selected_team_id: options.selectedTeamId,\n    totp_secret_base64: options.totpMultiFactorSecret != null ? encodeBase64(options.totpMultiFactorSecret) : options.totpMultiFactorSecret,\n    profile_image_url: options.profileImageUrl,\n    otp_auth_enabled: options.otpAuthEnabled,\n    passkey_auth_enabled: options.passkeyAuthEnabled,\n  };\n}\n\n\nexport type ServerBaseUser = {\n  setPrimaryEmail(email: string | null, options?: { verified?: boolean | undefined }): Promise<void>,\n\n  readonly lastActiveAt: Date,\n\n  readonly serverMetadata: any,\n  setServerMetadata(metadata: any): Promise<void>,\n  setClientReadOnlyMetadata(metadata: any): Promise<void>,\n\n  createTeam(data: Omit<ServerTeamCreateOptions, \"creatorUserId\">): Promise<ServerTeam>,\n\n  useContactChannels(): ServerContactChannel[], // THIS_LINE_PLATFORM react-like\n  listContactChannels(): Promise<ServerContactChannel[]>,\n  createContactChannel(data: ServerContactChannelCreateOptions): Promise<ServerContactChannel>,\n\n  update(user: ServerUserUpdateOptions): Promise<void>,\n\n  grantPermission(scope: Team, permissionId: string): Promise<void>,\n  grantPermission(permissionId: string): Promise<void>,\n\n  revokePermission(scope: Team, permissionId: string): Promise<void>,\n  revokePermission(permissionId: string): Promise<void>,\n\n  getPermission(scope: Team, permissionId: string): Promise<TeamPermission | null>,\n  getPermission(permissionId: string): Promise<TeamPermission | null>,\n\n  hasPermission(scope: Team, permissionId: string): Promise<boolean>,\n  hasPermission(permissionId: string): Promise<boolean>,\n\n  listPermissions(scope: Team, options?: { recursive?: boolean }): Promise<TeamPermission[]>,\n  listPermissions(options?: { recursive?: boolean }): Promise<TeamPermission[]>,\n\n  usePermissions(scope: Team, options?: { recursive?: boolean }): TeamPermission[],\n  usePermissions(options?: { recursive?: boolean }): TeamPermission[],\n\n  usePermission(scope: Team, permissionId: string): TeamPermission | null,\n  usePermission(permissionId: string): TeamPermission | null,\n\n  useOAuthProviders(): ServerOAuthProvider[], // THIS_LINE_PLATFORM react-like\n  listOAuthProviders(): Promise<ServerOAuthProvider[]>,\n\n  useOAuthProvider(id: string): ServerOAuthProvider | null, // THIS_LINE_PLATFORM react-like\n  getOAuthProvider(id: string): Promise<ServerOAuthProvider | null>,\n\n  /**\n   * Creates a new session object with a refresh token for this user. Can be used to impersonate them.\n   */\n  createSession(options?: { expiresInMillis?: number, isImpersonation?: boolean }): Promise<Session>,\n}\n& AsyncStoreProperty<\"team\", [id: string], ServerTeam | null, false>\n& AsyncStoreProperty<\"teams\", [], ServerTeam[], true>\n& AsyncStoreProperty<\"permission\", [scope: Team, permissionId: string, options?: { direct?: boolean }], AdminTeamPermission | null, false>\n& AsyncStoreProperty<\"permissions\", [scope: Team, options?: { direct?: boolean }], AdminTeamPermission[], true>;\n\n/**\n * A user including sensitive fields that should only be used on the server, never sent to the client\n * (such as sensitive information and serverMetadata).\n */\nexport type ServerUser = ServerBaseUser & BaseUser & UserExtra & Customer<true>;\n\nexport type CurrentServerUser = Auth & ServerUser;\n\nexport type CurrentInternalServerUser = CurrentServerUser & InternalUserExtra;\n\nexport type ProjectCurrentServerUser<ProjectId> = ProjectId extends \"internal\" ? CurrentInternalServerUser : CurrentServerUser;\n\nexport type SyncedPartialServerUser = SyncedPartialUser & Pick<\n  ServerUser,\n  | \"serverMetadata\"\n>;\n\nexport type ServerUserUpdateOptions = {\n  primaryEmail?: string | null,\n  primaryEmailVerified?: boolean,\n  primaryEmailAuthEnabled?: boolean,\n  clientReadOnlyMetadata?: ReadonlyJson,\n  serverMetadata?: ReadonlyJson,\n  password?: string,\n} & UserUpdateOptions;\nexport function serverUserUpdateOptionsToCrud(options: ServerUserUpdateOptions): CurrentUserCrud[\"Server\"][\"Update\"] {\n  return {\n    display_name: options.displayName,\n    primary_email: options.primaryEmail,\n    client_metadata: options.clientMetadata,\n    client_read_only_metadata: options.clientReadOnlyMetadata,\n    server_metadata: options.serverMetadata,\n    selected_team_id: options.selectedTeamId,\n    primary_email_auth_enabled: options.primaryEmailAuthEnabled,\n    primary_email_verified: options.primaryEmailVerified,\n    password: options.password,\n    profile_image_url: options.profileImageUrl,\n    totp_secret_base64: options.totpMultiFactorSecret != null ? encodeBase64(options.totpMultiFactorSecret) : options.totpMultiFactorSecret,\n  };\n}\n\n\nexport type ServerUserCreateOptions = {\n  primaryEmail?: string | null,\n  primaryEmailAuthEnabled?: boolean,\n  password?: string,\n  otpAuthEnabled?: boolean,\n  displayName?: string,\n  primaryEmailVerified?: boolean,\n  clientMetadata?: any,\n  clientReadOnlyMetadata?: any,\n  serverMetadata?: any,\n}\nexport function serverUserCreateOptionsToCrud(options: ServerUserCreateOptions): UsersCrud[\"Server\"][\"Create\"] {\n  return {\n    primary_email: options.primaryEmail,\n    password: options.password,\n    otp_auth_enabled: options.otpAuthEnabled,\n    primary_email_auth_enabled: options.primaryEmailAuthEnabled,\n    display_name: options.displayName,\n    primary_email_verified: options.primaryEmailVerified,\n    client_metadata: options.clientMetadata,\n    client_read_only_metadata: options.clientReadOnlyMetadata,\n    server_metadata: options.serverMetadata,\n  };\n}\n"],"names":[],"mappings":";;;;;;;;;;;AAQA,SAAS,oBAAoB;;AAe7B,IAAM,yBAAyB;AAExB,SAAS,2BAA2B,MAAA,EAAsB;IAC/D,MAAM,aAAa,OAAO,wBAAA,CAAyB,QAAQ,MAAM;IACjE,IAAI,YAAY,QAAQ,aAAa;QACnC;IACF;IAEA,OAAO,cAAA,CAAe,QAAQ,QAAQ;QACpC,KAAK;QACL,cAAc;QACd,YAAY;IACd,CAAC;AACH;AAEA,SAAS,cAAqB;IAC5B,MAAM,IAAI,MAAM,sBAAsB;AACxC;AAyOO,SAAS,wBAAwB,OAAA,EAAiE;IACvG,OAAO;QACL,cAAc,QAAQ,WAAA;QACtB,iBAAiB,QAAQ,cAAA;QACzB,kBAAkB,QAAQ,cAAA;QAC1B,oBAAoB,QAAQ,qBAAA,IAAyB,WAAO,uOAAA,EAAa,QAAQ,qBAAqB,IAAI,QAAQ,qBAAA;QAClH,mBAAmB,QAAQ,eAAA;QAC3B,kBAAkB,QAAQ,cAAA;QAC1B,sBAAsB,QAAQ,kBAAA;IAChC;AACF;AAkFO,SAAS,8BAA8B,OAAA,EAAuE;IACnH,OAAO;QACL,cAAc,QAAQ,WAAA;QACtB,eAAe,QAAQ,YAAA;QACvB,iBAAiB,QAAQ,cAAA;QACzB,2BAA2B,QAAQ,sBAAA;QACnC,iBAAiB,QAAQ,cAAA;QACzB,kBAAkB,QAAQ,cAAA;QAC1B,4BAA4B,QAAQ,uBAAA;QACpC,wBAAwB,QAAQ,oBAAA;QAChC,UAAU,QAAQ,QAAA;QAClB,mBAAmB,QAAQ,eAAA;QAC3B,oBAAoB,QAAQ,qBAAA,IAAyB,WAAO,uOAAA,EAAa,QAAQ,qBAAqB,IAAI,QAAQ,qBAAA;IACpH;AACF;AAcO,SAAS,8BAA8B,OAAA,EAAiE;IAC7G,OAAO;QACL,eAAe,QAAQ,YAAA;QACvB,UAAU,QAAQ,QAAA;QAClB,kBAAkB,QAAQ,cAAA;QAC1B,4BAA4B,QAAQ,uBAAA;QACpC,cAAc,QAAQ,WAAA;QACtB,wBAAwB,QAAQ,oBAAA;QAChC,iBAAiB,QAAQ,cAAA;QACzB,2BAA2B,QAAQ,sBAAA;QACnC,iBAAiB,QAAQ,cAAA;IAC3B;AACF"}},
    {"offset": {"line": 613, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack/src/lib/cookie.ts"],"sourcesContent":["\n//===========================================\n// THIS FILE IS AUTO-GENERATED FROM TEMPLATE. DO NOT EDIT IT DIRECTLY\n//===========================================\nimport { cookies as rscCookies, headers as rscHeaders } from '@stackframe/stack-sc/force-react-server'; // THIS_LINE_PLATFORM next\nimport { isBrowserLike } from '@stackframe/stack-shared/dist/utils/env';\nimport { StackAssertionError } from '@stackframe/stack-shared/dist/utils/errors';\nimport Cookies from \"js-cookie\";\nimport { calculatePKCECodeChallenge, generateRandomCodeVerifier, generateRandomState } from \"oauth4webapi\";\n\ntype SetCookieOptions = { maxAge?: number, noOpIfServerComponent?: boolean, domain?: string, secure?: boolean };\ntype DeleteCookieOptions = { noOpIfServerComponent?: boolean, domain?: string };\n\nfunction ensureClient() {\n  if (!isBrowserLike()) {\n    throw new Error(\"cookieClient functions can only be called in a browser environment, yet window is undefined\");\n  }\n}\n\nexport type CookieHelper = {\n  get: (name: string) => string | null,\n  getAll: () => Record<string, string>,\n  set: (name: string, value: string, options: SetCookieOptions) => void,\n  setOrDelete: (name: string, value: string | null, options: SetCookieOptions & DeleteCookieOptions) => void,\n  delete: (name: string, options: DeleteCookieOptions) => void,\n};\n\nconst placeholderCookieHelperIdentity = { \"placeholder cookie helper identity\": true };\nexport async function createPlaceholderCookieHelper(): Promise<CookieHelper> {\n  function throwError(): never {\n    throw new StackAssertionError(\"Throwing cookie helper is just a placeholder. This should never be called\");\n  }\n  return {\n    get: throwError,\n    getAll: throwError,\n    set: throwError,\n    setOrDelete: throwError,\n    delete: throwError,\n  };\n}\n\nexport async function createCookieHelper(): Promise<CookieHelper> {\n  if (isBrowserLike()) {\n    return createBrowserCookieHelper();\n  } else {\n    return createNextCookieHelper(\n      await rscCookies(),\n      await rscHeaders(),\n    );\n  }\n}\n\nexport function createBrowserCookieHelper(): CookieHelper {\n  return {\n    get: getCookieClient,\n    getAll: getAllCookiesClient,\n    set: setCookieClient,\n    setOrDelete: setOrDeleteCookieClient,\n    delete: deleteCookieClient,\n  };\n}\n\nfunction handleCookieError(e: unknown, options: DeleteCookieOptions | SetCookieOptions) {\n  if (e instanceof Error && e.message.includes(\"Cookies can only be modified in\")) {\n    if (options.noOpIfServerComponent) {\n      // ignore\n    } else {\n      throw new StackAssertionError(\"Attempted to set cookie in server component. Pass { noOpIfServerComponent: true } in the options of Stack's cookie functions if this is intentional and you want to ignore this error. Read more: https://nextjs.org/docs/app/api-reference/functions/cookies#options\");\n    }\n  } else {\n    throw e;\n  }\n}\n\nfunction createNextCookieHelper(\n  rscCookiesAwaited: Awaited<ReturnType<typeof rscCookies>>,\n  rscHeadersAwaited: Awaited<ReturnType<typeof rscHeaders>>,\n): CookieHelper {\n  const cookieHelper = {\n    get: (name: string) => {\n      const all = cookieHelper.getAll();\n      return all[name] ?? null;\n    },\n    getAll: () => {\n      // set a helper cookie, see comment in `NextCookieHelper.set` below\n      try {\n        rscCookiesAwaited.set(\"stack-is-https\", \"true\", { secure: true });\n      } catch (e) {\n        if (\n          typeof e === 'object'\n          && e !== null\n          && 'message' in e\n          && typeof e.message === 'string'\n          && e.message.includes('Cookies can only be modified in a Server Action or Route Handler')\n        ) {\n          // ignore\n        } else {\n          throw e;\n        }\n      }\n      const all = rscCookiesAwaited.getAll();\n      return all.reduce((acc, entry) => {\n        acc[entry.name] = entry.value;\n        return acc;\n      }, {} as Record<string, string>);\n    },\n    set: (name: string, value: string, options: SetCookieOptions) => {\n      // Whenever the client is on HTTPS, we want to set the Secure flag on the cookie.\n      //\n      // This is not easy to find out on a Next.js server, so we use the following steps:\n      //\n      // 1. If we're on the client, we can check window.location.protocol which is the ground-truth\n      // 2. Check whether the stack-is-https cookie exists. This cookie is set in various places on\n      //      the client if the protocol is known to be HTTPS\n      // 3. Check the X-Forwarded-Proto header\n      // 4. Otherwise, assume HTTP without the S\n      //\n      // Note that malicious clients could theoretically manipulate the `stack-is-https` cookie or\n      // the `X-Forwarded-Proto` header; that wouldn't cause any trouble except for themselves,\n      // though.\n      const isSecureCookie = determineSecureFromServerContext(rscCookiesAwaited, rscHeadersAwaited);\n\n      try {\n        rscCookiesAwaited.set(name, value, {\n          secure: isSecureCookie,\n          maxAge: options.maxAge,\n          domain: options.domain,\n        });\n      } catch (e) {\n        handleCookieError(e, options);\n      }\n    },\n    setOrDelete(name: string, value: string | null, options: SetCookieOptions & DeleteCookieOptions = {}) {\n      if (value === null) {\n        this.delete(name, options);\n      } else {\n        this.set(name, value, options);\n      }\n    },\n    delete(name: string, options: DeleteCookieOptions = {}) {\n      try {\n        if (options.domain !== undefined) {\n          rscCookiesAwaited.delete({ name, domain: options.domain });\n        } else {\n          rscCookiesAwaited.delete(name);\n        }\n      } catch (e) {\n        handleCookieError(e, options);\n      }\n    },\n  };\n  return cookieHelper;\n}\n\nexport function getCookieClient(name: string): string | null {\n  const all = getAllCookiesClient();\n  return all[name] ?? null;\n}\n\nexport function getAllCookiesClient(): Record<string, string> {\n  ensureClient();\n  // set a helper cookie, see comment in `NextCookieHelper.set` above\n  Cookies.set(\"stack-is-https\", \"true\", { secure: true });\n  return Cookies.get();\n}\n\nexport async function getCookie(name: string): Promise<string | null> {\n  const cookieHelper = await createCookieHelper();\n  return cookieHelper.get(name);\n}\n\nexport async function isSecure(): Promise<boolean> {\n  if (isBrowserLike()) {\n    return determineSecureFromClientContext();\n  }\n  return determineSecureFromServerContext(await rscCookies(), await rscHeaders());\n  return false;\n}\n\nfunction determineSecureFromClientContext(): boolean {\n  return typeof window !== \"undefined\" && window.location.protocol === \"https:\";\n}\nfunction determineSecureFromServerContext(\n  cookies: Awaited<ReturnType<typeof rscCookies>>,\n  headers: Awaited<ReturnType<typeof rscHeaders>>,\n): boolean {\n  return cookies.has(\"stack-is-https\") || headers.get(\"x-forwarded-proto\") === \"https\";\n}\n\nfunction setCookieClientInternal(name: string, value: string, options: SetCookieOptions = {}) {\n  const secure = options.secure ?? determineSecureFromClientContext();\n  Cookies.set(name, value, {\n    expires: options.maxAge === undefined ? undefined : new Date(Date.now() + (options.maxAge) * 1000),\n    domain: options.domain,\n    secure,\n  });\n}\n\nfunction deleteCookieClientInternal(name: string, options: DeleteCookieOptions = {}) {\n  if (options.domain !== undefined) {\n    Cookies.remove(name, { domain: options.domain, secure: determineSecureFromClientContext() });\n  }\n  Cookies.remove(name, { secure: determineSecureFromClientContext() });\n}\n\nexport function setOrDeleteCookieClient(name: string, value: string | null, options: SetCookieOptions & DeleteCookieOptions = {}) {\n  ensureClient();\n  if (value === null) {\n    deleteCookieClientInternal(name, options);\n  } else {\n    setCookieClientInternal(name, value, options);\n  }\n}\n\nexport async function setOrDeleteCookie(name: string, value: string | null, options: SetCookieOptions & DeleteCookieOptions = {}) {\n  const cookieHelper = await createCookieHelper();\n  cookieHelper.setOrDelete(name, value, options);\n}\n\nexport function deleteCookieClient(name: string, options: DeleteCookieOptions = {}) {\n  ensureClient();\n  deleteCookieClientInternal(name, options);\n}\n\nexport async function deleteCookie(name: string, options: DeleteCookieOptions = {}) {\n  const cookieHelper = await createCookieHelper();\n  cookieHelper.delete(name, options);\n}\n\nexport function setCookieClient(name: string, value: string, options: SetCookieOptions = {}) {\n  ensureClient();\n  setCookieClientInternal(name, value, options);\n}\n\nexport async function setCookie(name: string, value: string, options: SetCookieOptions = {}) {\n  const cookieHelper = await createCookieHelper();\n  cookieHelper.set(name, value, options);\n}\n\nexport async function saveVerifierAndState() {\n  const codeVerifier = generateRandomCodeVerifier();\n  const codeChallenge = await calculatePKCECodeChallenge(codeVerifier);\n  const state = generateRandomState();\n\n  await setCookie(\"stack-oauth-outer-\" + state, codeVerifier, { maxAge: 60 * 60 });\n\n  return {\n    codeChallenge,\n    state,\n  };\n}\n\nexport function consumeVerifierAndStateCookie(state: string) {\n  ensureClient();\n  const cookieName = \"stack-oauth-outer-\" + state;\n  const codeVerifier = getCookieClient(cookieName);\n  if (!codeVerifier) {\n    return null;\n  }\n  deleteCookieClient(cookieName);\n  return {\n    codeVerifier,\n  };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 862, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack/src/lib/auth.ts"],"sourcesContent":["\n//===========================================\n// THIS FILE IS AUTO-GENERATED FROM TEMPLATE. DO NOT EDIT IT DIRECTLY\n//===========================================\nimport { KnownError, StackClientInterface } from \"@stackframe/stack-shared\";\nimport { InternalSession } from \"@stackframe/stack-shared/dist/sessions\";\nimport { StackAssertionError, throwErr } from \"@stackframe/stack-shared/dist/utils/errors\";\nimport { neverResolve } from \"@stackframe/stack-shared/dist/utils/promises\";\nimport { Result } from \"@stackframe/stack-shared/dist/utils/results\";\nimport { deindent } from \"@stackframe/stack-shared/dist/utils/strings\";\nimport { constructRedirectUrl } from \"../utils/url\";\nimport { consumeVerifierAndStateCookie, saveVerifierAndState } from \"./cookie\";\n\nexport async function signInWithOAuth(\n  iface: StackClientInterface,\n  options: {\n    provider: string,\n    redirectUrl: string,\n    errorRedirectUrl: string,\n    providerScope?: string,\n  },\n  session: InternalSession,\n) {\n  const { codeChallenge, state } = await saveVerifierAndState();\n  const location = await iface.getOAuthUrl({\n    provider: options.provider,\n    redirectUrl: constructRedirectUrl(options.redirectUrl, \"redirectUrl\"),\n    errorRedirectUrl: constructRedirectUrl(options.errorRedirectUrl, \"errorRedirectUrl\"),\n    codeChallenge,\n    state,\n    type: \"authenticate\",\n    providerScope: options.providerScope,\n    session,\n  });\n  window.location.assign(location);\n  await neverResolve();\n}\n\nexport async function addNewOAuthProviderOrScope(\n  iface: StackClientInterface,\n  options: {\n    provider: string,\n    redirectUrl: string,\n    errorRedirectUrl: string,\n    providerScope?: string,\n  },\n  session: InternalSession,\n) {\n  const { codeChallenge, state } = await saveVerifierAndState();\n  const location = await iface.getOAuthUrl({\n    provider: options.provider,\n    redirectUrl: constructRedirectUrl(options.redirectUrl, \"redirectUrl\"),\n    errorRedirectUrl: constructRedirectUrl(options.errorRedirectUrl, \"errorRedirectUrl\"),\n    afterCallbackRedirectUrl: constructRedirectUrl(window.location.href, \"afterCallbackRedirectUrl\"),\n    codeChallenge,\n    state,\n    type: \"link\",\n    session,\n    providerScope: options.providerScope,\n  });\n  window.location.assign(location);\n  await neverResolve();\n}\n\n/**\n * Checks if the current URL has the query parameters for an OAuth callback, and if so, removes them.\n *\n * Must be synchronous for the logic in callOAuthCallback to work without race conditions.\n */\nfunction consumeOAuthCallbackQueryParams() {\n  const requiredParams = [\"code\", \"state\"];\n  const originalUrl = new URL(window.location.href);\n  for (const param of requiredParams) {\n    if (!originalUrl.searchParams.has(param)) {\n      console.warn(new Error(`Missing required query parameter on OAuth callback: ${param}. Maybe you opened or reloaded the oauth-callback page from your history?`));\n      return null;\n    }\n  }\n\n  const expectedState = originalUrl.searchParams.get(\"state\") ?? throwErr(\"This should never happen; isn't state required above?\");\n  const cookieResult = consumeVerifierAndStateCookie(expectedState);\n\n  if (!cookieResult) {\n    // If the state can't be found in the cookies, then the callback wasn't meant for us.\n    // Maybe the website uses another OAuth library?\n    console.warn(deindent`\n      Stack found an outer OAuth callback state in the query parameters, but not in cookies.\n      \n      This could have multiple reasons:\n        - The cookie expired, because the OAuth flow took too long.\n        - The user's browser deleted the cookie, either manually or because of a very strict cookie policy.\n        - The cookie was already consumed by this page, and the user already logged in.\n        - You are using another OAuth client library with the same callback URL as Stack.\n        - The user opened the OAuth callback page from their history.\n\n      Either way, it is probably safe to ignore this warning unless you are debugging an OAuth issue.\n    `);\n    return null;\n  }\n\n\n  const newUrl = new URL(originalUrl);\n  for (const param of requiredParams) {\n    newUrl.searchParams.delete(param);\n  }\n\n  // let's get rid of the authorization code in the history as we\n  // don't redirect to `redirectUrl` if there's a validation error\n  // (as the redirectUrl might be malicious!).\n  //\n  // We use history.replaceState instead of location.assign(...) to\n  // prevent an unnecessary reload\n  window.history.replaceState({}, \"\", newUrl.toString());\n\n  return {\n    originalUrl,\n    codeVerifier: cookieResult.codeVerifier,\n    state: expectedState,\n  };\n}\n\nexport async function callOAuthCallback(\n  iface: StackClientInterface,\n  redirectUrl: string,\n) {\n  // note: this part of the function (until the return) needs\n  // to be synchronous, to prevent race conditions when\n  // callOAuthCallback is called multiple times in parallel\n  const consumed = consumeOAuthCallbackQueryParams();\n  if (!consumed) return Result.ok(undefined);\n\n  // the rest can be asynchronous (we now know that we are the\n  // intended recipient of the callback, and the only instance\n  // of callOAuthCallback that's running)\n  try {\n    return Result.ok(await iface.callOAuthCallback({\n      oauthParams: consumed.originalUrl.searchParams,\n      redirectUri: constructRedirectUrl(redirectUrl, \"redirectUri\"),\n      codeVerifier: consumed.codeVerifier,\n      state: consumed.state,\n    }));\n  } catch (e) {\n    if (KnownError.isKnownError(e)) {\n      throw e;\n    }\n    throw new StackAssertionError(\"Error signing in during OAuth callback. Please try again.\", { cause: e });\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 982, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack/src/lib/stack-app/apps/implementations/client-app-impl.ts"],"sourcesContent":["\n//===========================================\n// THIS FILE IS AUTO-GENERATED FROM TEMPLATE. DO NOT EDIT IT DIRECTLY\n//===========================================\nimport { WebAuthnError, startAuthentication, startRegistration } from \"@simplewebauthn/browser\";\nimport { KnownErrors, StackClientInterface } from \"@stackframe/stack-shared\";\nimport { ContactChannelsCrud } from \"@stackframe/stack-shared/dist/interface/crud/contact-channels\";\nimport { CurrentUserCrud } from \"@stackframe/stack-shared/dist/interface/crud/current-user\";\nimport { ItemCrud } from \"@stackframe/stack-shared/dist/interface/crud/items\";\nimport { NotificationPreferenceCrud } from \"@stackframe/stack-shared/dist/interface/crud/notification-preferences\";\nimport { OAuthProviderCrud } from \"@stackframe/stack-shared/dist/interface/crud/oauth-providers\";\nimport type { CustomerProductsListResponse } from \"@stackframe/stack-shared/dist/interface/crud/products\";\nimport { TeamApiKeysCrud, UserApiKeysCrud, teamApiKeysCreateOutputSchema, userApiKeysCreateOutputSchema } from \"@stackframe/stack-shared/dist/interface/crud/project-api-keys\";\nimport { ProjectPermissionsCrud } from \"@stackframe/stack-shared/dist/interface/crud/project-permissions\";\nimport { ClientProjectsCrud } from \"@stackframe/stack-shared/dist/interface/crud/projects\";\nimport { SessionsCrud } from \"@stackframe/stack-shared/dist/interface/crud/sessions\";\nimport { TeamInvitationCrud } from \"@stackframe/stack-shared/dist/interface/crud/team-invitation\";\nimport { TeamMemberProfilesCrud } from \"@stackframe/stack-shared/dist/interface/crud/team-member-profiles\";\nimport { TeamPermissionsCrud } from \"@stackframe/stack-shared/dist/interface/crud/team-permissions\";\nimport { TeamsCrud } from \"@stackframe/stack-shared/dist/interface/crud/teams\";\nimport { UsersCrud } from \"@stackframe/stack-shared/dist/interface/crud/users\";\nimport { InternalSession } from \"@stackframe/stack-shared/dist/sessions\";\nimport { encodeBase32 } from \"@stackframe/stack-shared/dist/utils/bytes\";\nimport { scrambleDuringCompileTime } from \"@stackframe/stack-shared/dist/utils/compile-time\";\nimport { isBrowserLike } from \"@stackframe/stack-shared/dist/utils/env\";\nimport { StackAssertionError, captureError, throwErr } from \"@stackframe/stack-shared/dist/utils/errors\";\nimport { DependenciesMap } from \"@stackframe/stack-shared/dist/utils/maps\";\nimport { ProviderType } from \"@stackframe/stack-shared/dist/utils/oauth\";\nimport { deepPlainEquals, omit } from \"@stackframe/stack-shared/dist/utils/objects\";\nimport { neverResolve, runAsynchronously, wait } from \"@stackframe/stack-shared/dist/utils/promises\";\nimport { suspend, suspendIfSsr } from \"@stackframe/stack-shared/dist/utils/react\";\nimport { Result } from \"@stackframe/stack-shared/dist/utils/results\";\nimport { Store, storeLock } from \"@stackframe/stack-shared/dist/utils/stores\";\nimport { deindent, mergeScopeStrings, stringCompare } from \"@stackframe/stack-shared/dist/utils/strings\";\nimport { getRelativePart, isRelative } from \"@stackframe/stack-shared/dist/utils/urls\";\nimport { generateUuid } from \"@stackframe/stack-shared/dist/utils/uuids\";\nimport * as cookie from \"cookie\";\nimport * as NextNavigationUnscrambled from \"next/navigation\"; // import the entire module to get around some static compiler warnings emitted by Next.js in some cases | THIS_LINE_PLATFORM next\nimport React, { useCallback, useMemo } from \"react\"; // THIS_LINE_PLATFORM react-like\nimport type * as yup from \"yup\";\nimport { constructRedirectUrl } from \"../../../../utils/url\";\nimport { addNewOAuthProviderOrScope, callOAuthCallback, signInWithOAuth } from \"../../../auth\";\nimport { CookieHelper, createBrowserCookieHelper, createCookieHelper, createPlaceholderCookieHelper, deleteCookieClient, isSecure as isSecureCookieContext, setOrDeleteCookie, setOrDeleteCookieClient } from \"../../../cookie\";\nimport { ApiKey, ApiKeyCreationOptions, ApiKeyUpdateOptions, apiKeyCreationOptionsToCrud } from \"../../api-keys\";\nimport { ConvexCtx, GetCurrentPartialUserOptions, GetCurrentUserOptions, HandlerUrls, OAuthScopesOnSignIn, RedirectMethod, RedirectToOptions, RequestLike, TokenStoreInit, stackAppInternalsSymbol } from \"../../common\";\nimport { OAuthConnection } from \"../../connected-accounts\";\nimport { ContactChannel, ContactChannelCreateOptions, ContactChannelUpdateOptions, contactChannelCreateOptionsToCrud, contactChannelUpdateOptionsToCrud } from \"../../contact-channels\";\nimport { Customer, CustomerProductsList, CustomerProductsListOptions, CustomerProductsRequestOptions, Item } from \"../../customers\";\nimport { NotificationCategory } from \"../../notification-categories\";\nimport { TeamPermission } from \"../../permissions\";\nimport { AdminOwnedProject, AdminProjectUpdateOptions, Project, adminProjectCreateOptionsToCrud } from \"../../projects\";\nimport { EditableTeamMemberProfile, Team, TeamCreateOptions, TeamInvitation, TeamUpdateOptions, TeamUser, teamCreateOptionsToCrud, teamUpdateOptionsToCrud } from \"../../teams\";\nimport { ActiveSession, Auth, BaseUser, CurrentUser, InternalUserExtra, OAuthProvider, ProjectCurrentUser, SyncedPartialUser, TokenPartialUser, UserExtra, UserUpdateOptions, attachUserDestructureGuard, userUpdateOptionsToCrud } from \"../../users\";\nimport { StackClientApp, StackClientAppConstructorOptions, StackClientAppJson } from \"../interfaces/client-app\";\nimport { _StackAdminAppImplIncomplete } from \"./admin-app-impl\";\nimport { TokenObject, clientVersion, createCache, createCacheBySession, createEmptyTokenStore, getBaseUrl, getDefaultExtraRequestHeaders, getDefaultProjectId, getDefaultPublishableClientKey, getUrls, resolveConstructorOptions } from \"./common\";\nimport { parseJson } from \"@stackframe/stack-shared/dist/utils/json\";\n\nimport { useAsyncCache } from \"./common\";\n\nlet isReactServer = false;\nimport * as sc from \"@stackframe/stack-sc\";\nimport { cookies } from \"@stackframe/stack-sc\";\nisReactServer = sc.isReactServer;\n\n// NextNavigation.useRouter does not exist in react-server environments and some bundlers try to be helpful and throw a warning. Ignore the warning.\nconst NextNavigation = scrambleDuringCompileTime(NextNavigationUnscrambled);\n\n// hack to make sure process is defined in non-node environments\n\n\nconst allClientApps = new Map<string, [checkString: string | undefined, app: StackClientApp<any, any>]>();\n\ntype StackClientAppImplConstructorOptionsResolved<HasTokenStore extends boolean, ProjectId extends string> = StackClientAppConstructorOptions<HasTokenStore, ProjectId> & { inheritsFrom?: undefined };\n\nexport class _StackClientAppImplIncomplete<HasTokenStore extends boolean, ProjectId extends string = string> implements StackClientApp<HasTokenStore, ProjectId> {\n  /**\n   * There is a circular dependency between the admin app and the client app, as the former inherits from the latter and\n   * the latter needs to use the former when creating a new instance of an internal project.\n   *\n   * To break it, we set the admin app here lazily instead of importing it directly. This variable is set by ./index.ts,\n   * which imports both this file and ./admin-app-impl.ts.\n   */\n  static readonly LazyStackAdminAppImpl: { value: typeof import(\"./admin-app-impl\")._StackAdminAppImplIncomplete | undefined } = { value: undefined };\n\n  protected readonly _options: StackClientAppImplConstructorOptionsResolved<HasTokenStore, ProjectId>;\n  protected readonly _extraOptions: { uniqueIdentifier?: string, checkString?: string, interface?: StackClientInterface } | undefined;\n  protected _uniqueIdentifier: string | undefined = undefined;\n  protected _interface: StackClientInterface;\n  protected readonly _tokenStoreInit: TokenStoreInit<HasTokenStore>;\n  protected readonly _redirectMethod: RedirectMethod | undefined;\n  protected readonly _urlOptions: Partial<HandlerUrls>;\n  protected readonly _oauthScopesOnSignIn: Partial<OAuthScopesOnSignIn>;\n\n  private __DEMO_ENABLE_SLIGHT_FETCH_DELAY = false;\n  private readonly _ownedAdminApps = new DependenciesMap<[InternalSession, string], _StackAdminAppImplIncomplete<false, string>>();\n\n  private readonly _currentUserCache = createCacheBySession(async (session) => {\n    if (this.__DEMO_ENABLE_SLIGHT_FETCH_DELAY) {\n      await wait(2000);\n    }\n    if (session.isKnownToBeInvalid()) {\n      // let's save ourselves a network request\n      //\n      // this also makes a certain race condition less likely to happen. particularly, it's quite common for code to\n      // look like this:\n      //\n      //     const user = await useUser({ or: \"required\" });\n      //     const something = user.useSomething();\n      //\n      // now, let's say the session is invalidated. this will trigger a refresh to refresh both the user and the\n      // something. however, it's not guaranteed that the user will return first, so useUser might still return a\n      // user object while the something request has already completed (and failed, because the session is invalid).\n      // by returning null quickly here without a request, it is very very likely for the user request to complete\n      // first.\n      //\n      // TODO HACK: the above is a bit of a hack, and we should probably think of more consistent ways to handle this.\n      // it also only works for the user endpoint, and only if the session is known to be invalid.\n      return null;\n    }\n    return await this._interface.getClientUserByToken(session);\n  });\n  private readonly _currentProjectCache = createCache(async () => {\n    return Result.orThrow(await this._interface.getClientProject());\n  });\n  private readonly _ownedProjectsCache = createCacheBySession(async (session) => {\n    return await this._interface.listProjects(session);\n  });\n  private readonly _currentUserPermissionsCache = createCacheBySession<\n    [string, boolean],\n    TeamPermissionsCrud['Client']['Read'][]\n  >(async (session, [teamId, recursive]) => {\n    return await this._interface.listCurrentUserTeamPermissions({ teamId, recursive }, session);\n  });\n  private readonly _currentUserProjectPermissionsCache = createCacheBySession<\n    [boolean],\n    ProjectPermissionsCrud['Client']['Read'][]\n  >(async (session, [recursive]) => {\n    return await this._interface.listCurrentUserProjectPermissions({ recursive }, session);\n  });\n  private readonly _currentUserTeamsCache = createCacheBySession(async (session) => {\n    return await this._interface.listCurrentUserTeams(session);\n  });\n  private readonly _currentUserOAuthConnectionAccessTokensCache = createCacheBySession<[string, string], { accessToken: string } | null>(\n    async (session, [providerId, scope]) => {\n      try {\n        const result = await this._interface.createProviderAccessToken(providerId, scope || \"\", session);\n        return { accessToken: result.access_token };\n      } catch (err) {\n        if (!(KnownErrors.OAuthConnectionDoesNotHaveRequiredScope.isInstance(err) || KnownErrors.OAuthConnectionNotConnectedToUser.isInstance(err))) {\n          throw err;\n        }\n      }\n      return null;\n    }\n  );\n  private readonly _currentUserOAuthConnectionCache = createCacheBySession<[ProviderType, string, boolean], OAuthConnection | null>(\n    async (session, [providerId, scope, redirect]) => {\n      return await this._getUserOAuthConnectionCacheFn({\n        getUser: async () => Result.orThrow(await this._currentUserCache.getOrWait([session], \"write-only\")),\n        getOrWaitOAuthToken: async () => Result.orThrow(await this._currentUserOAuthConnectionAccessTokensCache.getOrWait([session, providerId, scope || \"\"] as const, \"write-only\")),\n        useOAuthToken: () => useAsyncCache(this._currentUserOAuthConnectionAccessTokensCache, [session, providerId, scope || \"\"] as const, \"connection.useAccessToken()\"),\n        providerId,\n        scope,\n        redirect,\n        session,\n      });\n    }\n  );\n  private readonly _teamMemberProfilesCache = createCacheBySession<[string], TeamMemberProfilesCrud['Client']['Read'][]>(\n    async (session, [teamId]) => {\n      return await this._interface.listTeamMemberProfiles({ teamId }, session);\n    }\n  );\n  private readonly _teamInvitationsCache = createCacheBySession<[string], TeamInvitationCrud['Client']['Read'][]>(\n    async (session, [teamId]) => {\n      return await this._interface.listTeamInvitations({ teamId }, session);\n    }\n  );\n  private readonly _currentUserTeamProfileCache = createCacheBySession<[string], TeamMemberProfilesCrud['Client']['Read']>(\n    async (session, [teamId]) => {\n      return await this._interface.getTeamMemberProfile({ teamId, userId: 'me' }, session);\n    }\n  );\n  private readonly _clientContactChannelsCache = createCacheBySession<[], ContactChannelsCrud['Client']['Read'][]>(\n    async (session) => {\n      return await this._interface.listClientContactChannels(session);\n    }\n  );\n\n  private readonly _userApiKeysCache = createCacheBySession<[], UserApiKeysCrud['Client']['Read'][]>(\n    async (session) => {\n      const results = await this._interface.listProjectApiKeys({ user_id: 'me' }, session, \"client\");\n      return results as UserApiKeysCrud['Client']['Read'][];\n    }\n  );\n\n  private readonly _teamApiKeysCache = createCacheBySession<[string], TeamApiKeysCrud['Client']['Read'][]>(\n    async (session, [teamId]) => {\n      const results = await this._interface.listProjectApiKeys({ team_id: teamId }, session, \"client\");\n      return results as TeamApiKeysCrud['Client']['Read'][];\n    }\n  );\n\n  private readonly _notificationCategoriesCache = createCacheBySession<[], NotificationPreferenceCrud['Client']['Read'][]>(\n    async (session) => {\n      const results = await this._interface.listNotificationCategories(session);\n      return results as NotificationPreferenceCrud['Client']['Read'][];\n    }\n  );\n\n  private readonly _currentUserOAuthProvidersCache = createCacheBySession<[], OAuthProviderCrud['Client']['Read'][]>(\n    async (session) => {\n      return await this._interface.listOAuthProviders({ user_id: 'me' }, session);\n    }\n  );\n\n  private readonly _userItemCache = createCacheBySession<[string, string], ItemCrud['Client']['Read']>(\n    async (session, [userId, itemId]) => {\n      return await this._interface.getItem({ userId, itemId }, session);\n    }\n  );\n\n  private readonly _teamItemCache = createCacheBySession<[string, string], ItemCrud['Client']['Read']>(\n    async (session, [teamId, itemId]) => {\n      return await this._interface.getItem({ teamId, itemId }, session);\n    }\n  );\n\n  private readonly _customItemCache = createCacheBySession<[string, string], ItemCrud['Client']['Read']>(\n    async (session, [customCustomerId, itemId]) => {\n      return await this._interface.getItem({ customCustomerId, itemId }, session);\n    }\n  );\n\n  private readonly _userProductsCache = createCacheBySession<[string, string | null, number | null], CustomerProductsListResponse>(\n    async (session, [userId, cursor, limit]) => {\n      return await this._interface.listProducts({\n        customer_type: \"user\",\n        customer_id: userId,\n        cursor: cursor ?? undefined,\n        limit: limit ?? undefined,\n      }, session);\n    }\n  );\n\n  private readonly _teamProductsCache = createCacheBySession<[string, string | null, number | null], CustomerProductsListResponse>(\n    async (session, [teamId, cursor, limit]) => {\n      return await this._interface.listProducts({\n        customer_type: \"team\",\n        customer_id: teamId,\n        cursor: cursor ?? undefined,\n        limit: limit ?? undefined,\n      }, session);\n    }\n  );\n\n  private readonly _customProductsCache = createCacheBySession<[string, string | null, number | null], CustomerProductsListResponse>(\n    async (session, [customCustomerId, cursor, limit]) => {\n      return await this._interface.listProducts({\n        customer_type: \"custom\",\n        customer_id: customCustomerId,\n        cursor: cursor ?? undefined,\n        limit: limit ?? undefined,\n      }, session);\n    }\n  );\n\n  private readonly _convexPartialUserCache = createCache<[unknown], TokenPartialUser | null>(\n    async ([ctx]) => await this._getPartialUserFromConvex(ctx as any)\n  );\n\n  private readonly _trustedParentDomainCache = createCache<[string], string | null>(\n    async ([domain]) => await this._getTrustedParentDomain(domain)\n  );\n\n  private _anonymousSignUpInProgress: Promise<{ accessToken: string, refreshToken: string }> | null = null;\n\n  protected async _createCookieHelper(): Promise<CookieHelper> {\n    if (this._tokenStoreInit === 'nextjs-cookie' || this._tokenStoreInit === 'cookie') {\n      return await createCookieHelper();\n    } else {\n      return await createPlaceholderCookieHelper();\n    }\n  }\n\n  protected async _getUserOAuthConnectionCacheFn(options: {\n    getUser: () => Promise<CurrentUserCrud['Client']['Read'] | null>,\n    getOrWaitOAuthToken: () => Promise<{ accessToken: string } | null>,\n    useOAuthToken: () => { accessToken: string } | null,\n    providerId: ProviderType,\n    scope: string | null,\n  } & ({ redirect: true, session: InternalSession | null } | { redirect: false }),) {\n    const user = await options.getUser();\n    let hasConnection = true;\n    if (!user || !user.oauth_providers.find((p) => p.id === options.providerId)) {\n      hasConnection = false;\n    }\n\n    const token = await options.getOrWaitOAuthToken();\n    if (!token) {\n      hasConnection = false;\n    }\n\n    if (!hasConnection && options.redirect) {\n      if (!options.session) {\n        throw new Error(deindent`\n          Cannot add new scopes to a user that is not a CurrentUser. Please ensure that you are calling this function on a CurrentUser object, or remove the 'or: redirect' option.\n\n          Often, you can solve this by calling this function in the browser instead, or by removing the 'or: redirect' option and dealing with the case where the user doesn't have enough permissions.\n        `);\n      }\n      await addNewOAuthProviderOrScope(\n        this._interface,\n        {\n          provider: options.providerId,\n          redirectUrl: this.urls.oauthCallback,\n          errorRedirectUrl: this.urls.error,\n          providerScope: mergeScopeStrings(options.scope || \"\", (this._oauthScopesOnSignIn[options.providerId] ?? []).join(\" \")),\n        },\n        options.session,\n      );\n      return await neverResolve();\n    } else if (!hasConnection) {\n      return null;\n    }\n\n    return {\n      id: options.providerId,\n      async getAccessToken() {\n        const result = await options.getOrWaitOAuthToken();\n        if (!result) {\n          throw new StackAssertionError(\"No access token available\");\n        }\n        return result;\n      },\n      useAccessToken() {\n        const result = options.useOAuthToken();\n        if (!result) {\n          throw new StackAssertionError(\"No access token available\");\n        }\n        return result;\n      }\n    };\n  }\n\n  constructor(options: StackClientAppConstructorOptions<HasTokenStore, ProjectId>, extraOptions?: { uniqueIdentifier?: string, checkString?: string, interface?: StackClientInterface }) {\n    const resolvedOptions = resolveConstructorOptions(options);\n\n    if (!_StackClientAppImplIncomplete.LazyStackAdminAppImpl.value) {\n      throw new StackAssertionError(\"Admin app implementation not initialized. Did you import the _StackClientApp from stack-app/apps/implementations/index.ts? You can't import it directly from ./apps/implementations/client-app-impl.ts as that causes a circular dependency (see the comment at _LazyStackAdminAppImpl for more details).\");\n    }\n\n    this._options = resolvedOptions;\n    this._extraOptions = extraOptions;\n\n    const projectId = resolvedOptions.projectId ?? getDefaultProjectId();\n    if (projectId !== \"internal\" && !(projectId.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[089ab][0-9a-f]{3}-[0-9a-f]{12}$/i))) {\n      throw new Error(`Invalid project ID: ${projectId}. Project IDs must be UUIDs. Please check your environment variables and/or your StackApp.`);\n    }\n\n    if (extraOptions && extraOptions.interface) {\n      this._interface = extraOptions.interface;\n    } else {\n      this._interface = new StackClientInterface({\n        getBaseUrl: () => getBaseUrl(resolvedOptions.baseUrl),\n        extraRequestHeaders: resolvedOptions.extraRequestHeaders ?? getDefaultExtraRequestHeaders(),\n        projectId,\n        clientVersion,\n        publishableClientKey: resolvedOptions.publishableClientKey ?? getDefaultPublishableClientKey(),\n        prepareRequest: async () => {\n          await cookies?.(); // THIS_LINE_PLATFORM next\n        }\n      });\n    }\n\n    this._tokenStoreInit = resolvedOptions.tokenStore;\n    this._redirectMethod = resolvedOptions.redirectMethod || \"none\";\n    this._redirectMethod = resolvedOptions.redirectMethod || \"nextjs\"; // THIS_LINE_PLATFORM next\n    this._urlOptions = resolvedOptions.urls ?? {};\n    this._oauthScopesOnSignIn = resolvedOptions.oauthScopesOnSignIn ?? {};\n\n    if (extraOptions && extraOptions.uniqueIdentifier) {\n      this._uniqueIdentifier = extraOptions.uniqueIdentifier;\n      this._initUniqueIdentifier();\n    }\n  }\n\n  protected _initUniqueIdentifier() {\n    if (!this._uniqueIdentifier) {\n      throw new StackAssertionError(\"Unique identifier not initialized\");\n    }\n    if (allClientApps.has(this._uniqueIdentifier)) {\n      throw new StackAssertionError(\"A Stack client app with the same unique identifier already exists\");\n    }\n    allClientApps.set(this._uniqueIdentifier, [this._extraOptions?.checkString ?? undefined, this]);\n  }\n\n  /**\n   * Cloudflare workers does not allow use of randomness on the global scope (on which the Stack app is probably\n   * initialized). For that reason, we generate the unique identifier lazily when it is first needed instead of in the\n   * constructor.\n   */\n  protected _getUniqueIdentifier() {\n    if (!this._uniqueIdentifier) {\n      this._uniqueIdentifier = generateUuid();\n      this._initUniqueIdentifier();\n    }\n    return this._uniqueIdentifier!;\n  }\n\n  protected async _checkFeatureSupport(name: string, options: any) {\n    return await this._interface.checkFeatureSupport({ ...options, name });\n  }\n\n  protected _useCheckFeatureSupport(name: string, options: any): never {\n    runAsynchronously(this._checkFeatureSupport(name, options));\n    throw new StackAssertionError(`${name} is not currently supported. Please reach out to Stack support for more information.`);\n  }\n\n  protected _memoryTokenStore = createEmptyTokenStore();\n  protected _nextServerCookiesTokenStores = new WeakMap<object, Store<TokenObject>>();\n  protected _requestTokenStores = new WeakMap<RequestLike, Store<TokenObject>>();\n  protected _storedBrowserCookieTokenStore: Store<TokenObject> | null = null;\n  private _mostRecentQueuedCookieRefreshIndex: number = 0;\n  protected get _legacyRefreshTokenCookieName() {\n    return `stack-refresh-${this.projectId}`;\n  }\n  protected get _refreshTokenCookieName() {\n    return `stack-refresh-${this.projectId}`;\n  }\n  private _getRefreshTokenDefaultCookieNameForSecure(secure: boolean): string {\n    return `${secure ? \"__Host-\" : \"\"}${this._refreshTokenCookieName}--default`;\n  }\n  private _getCustomRefreshCookieName(domain: string): string {\n    const encoded = encodeBase32(new TextEncoder().encode(domain.toLowerCase()));\n    return `${this._refreshTokenCookieName}--custom-${encoded}`;\n  }\n  private _formatRefreshCookieValue(refreshToken: string, updatedAt: number): string {\n    return JSON.stringify({\n      refresh_token: refreshToken,\n      updated_at_millis: updatedAt,\n    });\n  }\n  private _formatAccessCookieValue(refreshToken: string | null, accessToken: string | null): string | null {\n    return refreshToken && accessToken ? JSON.stringify([refreshToken, accessToken]) : null;\n  }\n  private _parseStructuredRefreshCookie(value: string | null): { refreshToken: string, updatedAt: number | null } | null {\n    if (!value) {\n      return null;\n    }\n    const parsed = parseJson(value);\n    if (parsed.status !== \"ok\" || typeof parsed.data !== \"object\" || parsed.data === null) {\n      console.warn(\"Failed to parse structured refresh cookie\");\n      return null;\n    }\n    const data = parsed.data;\n    const refreshToken = \"refresh_token\" in data && typeof data.refresh_token === \"string\" ? data.refresh_token : null;\n    const updatedAt = \"updated_at_millis\" in data && typeof data.updated_at_millis === \"number\" ? data.updated_at_millis : null;\n    if (!refreshToken) {\n      console.warn(\"Refresh token not found in structured refresh cookie\");\n      return null;\n    }\n    return {\n      refreshToken,\n      updatedAt,\n    };\n\n  }\n  private _extractRefreshTokenFromCookieMap(cookies: Record<string, string>): { refreshToken: string | null, updatedAt: number | null } {\n    const { legacyNames, structuredPrefixes } = this._getRefreshTokenCookieNamePatterns();\n    for (const name of legacyNames) {\n      const value = cookies[name];\n      if (value) {\n        return { refreshToken: value, updatedAt: null };\n      }\n    }\n\n    let selected: { refreshToken: string, updatedAt: number | null } | null = null;\n    for (const [name, value] of Object.entries(cookies)) {\n      if (!structuredPrefixes.some(prefix => name.startsWith(prefix))) continue;\n      const parsed = this._parseStructuredRefreshCookie(value);\n      if (!parsed) continue;\n      const candidateUpdatedAt = parsed.updatedAt ?? Number.NEGATIVE_INFINITY;\n      const selectedUpdatedAt = selected?.updatedAt ?? Number.NEGATIVE_INFINITY;\n      if (!selected || candidateUpdatedAt > selectedUpdatedAt) {\n        selected = parsed;\n      }\n    }\n\n    if (!selected) {\n      return { refreshToken: null, updatedAt: null };\n    }\n\n    return {\n      refreshToken: selected.refreshToken,\n      updatedAt: selected.updatedAt ?? null,\n    };\n  }\n  protected _getTokensFromCookies(cookies: Record<string, string>): TokenObject {\n    const { refreshToken } = this._extractRefreshTokenFromCookieMap(cookies);\n    const accessTokenCookie = cookies[this._accessTokenCookieName] ?? null;\n    let accessToken: string | null = null;\n    if (accessTokenCookie && accessTokenCookie.startsWith('[\\\"')) {\n      const parsed = parseJson(accessTokenCookie);\n      if (\n        parsed.status === \"ok\" &&\n        typeof parsed.data === \"object\" &&\n        parsed.data !== null &&\n        Array.isArray(parsed.data) &&\n        parsed.data.length === 2 &&\n        typeof parsed.data[0] === \"string\" &&\n        typeof parsed.data[1] === \"string\"\n      ) {\n        if (parsed.data[0] === refreshToken) {\n          accessToken = parsed.data[1];\n        }\n      } else {\n        console.warn(\"Access token cookie has invalid format\");\n      }\n    }\n    return {\n      refreshToken,\n      accessToken,\n    };\n  }\n  protected get _accessTokenCookieName() {\n    // The access token, unlike the refresh token, should not depend on the project ID. We never want to store the\n    // access token in cookies more than once because of how big it is (there's a limit of 4096 bytes for all cookies\n    // together). This means that, if you have multiple projects on the same domain, some of them will need to refetch\n    // the access token on page reload.\n    return `stack-access`;\n  }\n  private _getAllBrowserCookies(): Record<string, string> {\n    if (!isBrowserLike()) {\n      throw new StackAssertionError(\"Cannot get browser cookies on the server!\");\n    }\n    return cookie.parse(document.cookie || \"\");\n  }\n  private _getRefreshTokenCookieNamePatterns(): { legacyNames: string[], structuredPrefixes: string[] } {\n    return {\n      legacyNames: [this._legacyRefreshTokenCookieName, \"stack-refresh\"],\n      structuredPrefixes: [\n        `${this._refreshTokenCookieName}--`,\n        `__Host-${this._refreshTokenCookieName}--`,\n      ],\n    };\n  }\n  private _collectRefreshTokenCookieNames(cookies: Record<string, string>): Set<string> {\n    const { legacyNames, structuredPrefixes } = this._getRefreshTokenCookieNamePatterns();\n    const names = new Set<string>();\n    for (const name of legacyNames) {\n      if (cookies[name]) {\n        names.add(name);\n      }\n    }\n    for (const name of Object.keys(cookies)) {\n      if (structuredPrefixes.some(prefix => name.startsWith(prefix))) {\n        names.add(name);\n      }\n    }\n    return names;\n  }\n  private _prepareRefreshCookieUpdate(\n    existingCookies: Record<string, string>,\n    refreshToken: string | null,\n    accessToken: string | null,\n    defaultCookieName: string,\n  ) {\n    const cookieNames = this._collectRefreshTokenCookieNames(existingCookies);\n    cookieNames.delete(defaultCookieName);\n    const updatedAt = refreshToken ? Date.now() : null;\n    const refreshCookieValue = refreshToken && updatedAt !== null ? this._formatRefreshCookieValue(refreshToken, updatedAt) : null;\n    const accessTokenPayload = this._formatAccessCookieValue(refreshToken, accessToken);\n    return {\n      updatedAt,\n      refreshCookieValue,\n      accessTokenPayload,\n      cookieNamesToDelete: [...cookieNames],\n    };\n  }\n  private _queueCustomRefreshCookieUpdate(refreshToken: string | null, updatedAt: number | null, context: \"browser\" | \"server\") {\n    runAsynchronously(async () => {\n      this._mostRecentQueuedCookieRefreshIndex++;\n      const updateIndex = this._mostRecentQueuedCookieRefreshIndex;\n      let hostname;\n      if (isBrowserLike()) {\n        hostname = window.location.hostname;\n      }\n      else {\n        hostname = (await sc.headers?.())?.get(\"host\");\n      }\n      if (!hostname) {\n        console.warn(\"No hostname found when queueing custom refresh cookie update\");\n        return;\n      }\n      const domain = await this._trustedParentDomainCache.getOrWait([hostname], \"read-write\");\n\n      const setCookie = async (targetDomain: string, value: string | null) => {\n        const name = this._getCustomRefreshCookieName(targetDomain);\n        const options = { maxAge: 60 * 60 * 24 * 365, domain: targetDomain, noOpIfServerComponent: true };\n        if (context === \"browser\") {\n          setOrDeleteCookieClient(name, value, options);\n        } else {\n          await setOrDeleteCookie(name, value, options);\n        }\n      };\n\n      if (domain.status === \"error\" || !domain.data || updateIndex !== this._mostRecentQueuedCookieRefreshIndex) {\n        return;\n      }\n      const value = refreshToken && updatedAt ? this._formatRefreshCookieValue(refreshToken, updatedAt) : null;\n      await setCookie(domain.data, value);\n      const isSecure = await isSecureCookieContext();\n      await setOrDeleteCookie(this._getRefreshTokenDefaultCookieNameForSecure(isSecure), null);\n    });\n  }\n  private async _getTrustedParentDomain(currentDomain: string): Promise<string | null> {\n    const project = Result.orThrow(await this._interface.getClientProject());\n    const domains = project.config.domains.map(d => d.domain.trim().replace(/^https?:\\/\\//, \"\").split(\"/\")[0]?.toLowerCase());\n    const trustedWildcards = domains.filter(d => d.startsWith(\"**.\"));\n    const parts = currentDomain.split('.');\n    for (let i = parts.length - 2; i >= 0; i--) {\n      const parentDomain = parts.slice(i).join('.');\n      if (domains.includes(parentDomain) && trustedWildcards.includes(\"**.\" + parentDomain)) {\n        return parentDomain;\n      }\n    }\n\n    return null;\n  }\n\n  protected _getBrowserCookieTokenStore(): Store<TokenObject> {\n    if (!isBrowserLike()) {\n      throw new Error(\"Cannot use cookie token store on the server!\");\n    }\n\n    if (this._storedBrowserCookieTokenStore === null) {\n      const getCurrentValue = (old: TokenObject | null) => {\n        const tokens = this._getTokensFromCookies(this._getAllBrowserCookies());\n        return {\n          refreshToken: tokens.refreshToken,\n          accessToken: tokens.accessToken ?? (old?.refreshToken === tokens.refreshToken ? old.accessToken : null),\n        };\n      };\n      this._storedBrowserCookieTokenStore = new Store<TokenObject>(getCurrentValue(null));\n      let hasSucceededInWriting = true;\n\n      setInterval(() => {\n        if (hasSucceededInWriting) {\n          const oldValue = this._storedBrowserCookieTokenStore!.get();\n          const currentValue = getCurrentValue(oldValue);\n          if (!deepPlainEquals(currentValue, oldValue)) {\n            this._storedBrowserCookieTokenStore!.set(currentValue);\n          }\n        }\n      }, 100);\n      this._storedBrowserCookieTokenStore.onChange((value) => {\n        try {\n          const refreshToken = value.refreshToken;\n          const secure = window.location.protocol === \"https:\";\n          const defaultName = this._getRefreshTokenDefaultCookieNameForSecure(secure);\n          const { updatedAt, refreshCookieValue, accessTokenPayload, cookieNamesToDelete } = this._prepareRefreshCookieUpdate(\n            this._getAllBrowserCookies(),\n            refreshToken,\n            value.accessToken ?? null,\n            defaultName,\n          );\n          setOrDeleteCookieClient(defaultName, refreshCookieValue, { maxAge: 60 * 60 * 24 * 365, secure });\n          setOrDeleteCookieClient(this._accessTokenCookieName, accessTokenPayload, { maxAge: 60 * 60 * 24 });\n          cookieNamesToDelete.forEach((name) => deleteCookieClient(name));\n          this._queueCustomRefreshCookieUpdate(refreshToken, updatedAt, \"browser\");\n          hasSucceededInWriting = true;\n        } catch (e) {\n          if (!isBrowserLike()) {\n            // Setting cookies inside RSCs is not allowed, so we just ignore it\n            hasSucceededInWriting = false;\n          } else {\n            throw e;\n          }\n        }\n      });\n    }\n\n    return this._storedBrowserCookieTokenStore;\n  };\n  protected _getOrCreateTokenStore(cookieHelper: CookieHelper, overrideTokenStoreInit?: TokenStoreInit): Store<TokenObject> {\n    const tokenStoreInit = overrideTokenStoreInit === undefined ? this._tokenStoreInit : overrideTokenStoreInit;\n\n    switch (tokenStoreInit) {\n      case \"cookie\": {\n        return this._getBrowserCookieTokenStore();\n      }\n      case \"nextjs-cookie\": {\n        if (isBrowserLike()) {\n          return this._getBrowserCookieTokenStore();\n        } else {\n          const tokens = this._getTokensFromCookies(cookieHelper.getAll());\n          const store = new Store<TokenObject>(tokens);\n          store.onChange((value) => {\n            runAsynchronously(async () => {\n              // TODO HACK this is a bit of a hack; while the order happens to work in practice (because the only actual\n              // async operation is waiting for the `cookies()` to resolve which always happens at the same time during\n              // the same request), it's not guaranteed to be free of race conditions if there are many updates happening\n              // at the same time\n              //\n              // instead, we should create a per-request cookie helper outside of the store onChange and reuse that\n              //\n              // but that's kinda hard to do because Next.js doesn't expose a documented way to find out which request\n              // we're currently processing, and hence we can't find out which per-request cookie helper to use\n              //\n              // so hack it is\n              const refreshToken = value.refreshToken;\n              const secure = await isSecureCookieContext();\n              const defaultName = this._getRefreshTokenDefaultCookieNameForSecure(secure);\n              const { updatedAt, refreshCookieValue, accessTokenPayload, cookieNamesToDelete } = this._prepareRefreshCookieUpdate(\n                cookieHelper.getAll(),\n                refreshToken,\n                value.accessToken ?? null,\n                defaultName,\n              );\n              await Promise.all([\n                setOrDeleteCookie(defaultName, refreshCookieValue, { maxAge: 60 * 60 * 24 * 365, noOpIfServerComponent: true }),\n                setOrDeleteCookie(this._accessTokenCookieName, accessTokenPayload, { maxAge: 60 * 60 * 24, noOpIfServerComponent: true }),\n              ]);\n              if (cookieNamesToDelete.length > 0) {\n                await Promise.all(\n                  cookieNamesToDelete.map((name) =>\n                    setOrDeleteCookie(name, null, { noOpIfServerComponent: true }),\n                  ),\n                );\n              }\n              this._queueCustomRefreshCookieUpdate(refreshToken, updatedAt, \"server\");\n            });\n          });\n          return store;\n        }\n      }\n      case \"memory\": {\n        return this._memoryTokenStore;\n      }\n      default: {\n        if (tokenStoreInit === null) {\n          return createEmptyTokenStore();\n        } else if (typeof tokenStoreInit === \"object\" && \"headers\" in tokenStoreInit) {\n          if (this._requestTokenStores.has(tokenStoreInit)) return this._requestTokenStores.get(tokenStoreInit)!;\n\n          // x-stack-auth header\n          const stackAuthHeader = tokenStoreInit.headers.get(\"x-stack-auth\");\n          if (stackAuthHeader) {\n            let parsed;\n            try {\n              parsed = JSON.parse(stackAuthHeader);\n              if (typeof parsed !== \"object\") throw new Error(\"x-stack-auth header must be a JSON object\");\n              if (parsed === null) throw new Error(\"x-stack-auth header must not be null\");\n            } catch (e) {\n              throw new Error(`Invalid x-stack-auth header: ${stackAuthHeader}`, { cause: e });\n            }\n            return this._getOrCreateTokenStore(cookieHelper, {\n              accessToken: parsed.accessToken ?? null,\n              refreshToken: parsed.refreshToken ?? null,\n            });\n          }\n\n          // read from cookies\n          const cookieHeader = tokenStoreInit.headers.get(\"cookie\");\n          const parsed = cookie.parse(cookieHeader || \"\");\n          const res = new Store<TokenObject>(this._getTokensFromCookies(parsed));\n          this._requestTokenStores.set(tokenStoreInit, res);\n          return res;\n        } else if (\"accessToken\" in tokenStoreInit || \"refreshToken\" in tokenStoreInit) {\n          return new Store<TokenObject>({\n            refreshToken: tokenStoreInit.refreshToken,\n            accessToken: tokenStoreInit.accessToken,\n          });\n        }\n\n        throw new Error(`Invalid token store ${tokenStoreInit}`);\n      }\n    }\n  }\n\n  protected _useTokenStore(overrideTokenStoreInit?: TokenStoreInit): Store<TokenObject> {\n    suspendIfSsr();\n    const cookieHelper = createBrowserCookieHelper();\n    const tokenStore = this._getOrCreateTokenStore(cookieHelper, overrideTokenStoreInit);\n    return tokenStore;\n  }\n\n  /**\n   * A map from token stores and session keys to sessions.\n   *\n   * This isn't just a map from session keys to sessions for two reasons:\n   *\n   * - So we can garbage-collect Session objects when the token store is garbage-collected\n   * - So different token stores are separated and don't leak information between each other, eg. if the same user sends two requests to the same server they should get a different session object\n   */\n  private _sessionsByTokenStoreAndSessionKey = new WeakMap<Store<TokenObject>, Map<string, InternalSession>>();\n  protected _getSessionFromTokenStore(tokenStore: Store<TokenObject>): InternalSession {\n    const tokenObj = tokenStore.get();\n    const sessionKey = InternalSession.calculateSessionKey(tokenObj);\n    const existing = sessionKey ? this._sessionsByTokenStoreAndSessionKey.get(tokenStore)?.get(sessionKey) : null;\n    if (existing) return existing;\n\n    const session = this._interface.createSession({\n      refreshToken: tokenObj.refreshToken,\n      accessToken: tokenObj.accessToken,\n    });\n    session.onAccessTokenChange((newAccessToken) => {\n      tokenStore.update((old) => ({\n        ...old,\n        accessToken: newAccessToken?.token ?? null\n      }));\n    });\n    session.onInvalidate(() => {\n      tokenStore.update((old) => ({\n        ...old,\n        accessToken: null,\n        refreshToken: null,\n      }));\n    });\n\n    let sessionsBySessionKey = this._sessionsByTokenStoreAndSessionKey.get(tokenStore) ?? new Map();\n    this._sessionsByTokenStoreAndSessionKey.set(tokenStore, sessionsBySessionKey);\n    sessionsBySessionKey.set(sessionKey, session);\n    return session;\n  }\n\n  protected async _getSession(overrideTokenStoreInit?: TokenStoreInit): Promise<InternalSession> {\n    const tokenStore = this._getOrCreateTokenStore(await this._createCookieHelper(), overrideTokenStoreInit);\n    const session = this._getSessionFromTokenStore(tokenStore);\n    return session;\n  }\n\n  protected _useSession(overrideTokenStoreInit?: TokenStoreInit): InternalSession {\n    const tokenStore = this._useTokenStore(overrideTokenStoreInit);\n    const subscribe = useCallback((cb: () => void) => {\n      const { unsubscribe } = tokenStore.onChange(() => {\n        cb();\n      });\n      return unsubscribe;\n    }, [tokenStore]);\n    const getSnapshot = useCallback(() => this._getSessionFromTokenStore(tokenStore), [tokenStore]);\n    return React.useSyncExternalStore(subscribe, getSnapshot, getSnapshot);\n  }\n\n  protected async _signInToAccountWithTokens(tokens: { accessToken: string | null, refreshToken: string }) {\n    if (!(\"accessToken\" in tokens) || !(\"refreshToken\" in tokens)) {\n      throw new StackAssertionError(\"Invalid tokens object; can't sign in with this\", { tokens });\n    }\n    const tokenStore = this._getOrCreateTokenStore(await this._createCookieHelper());\n    tokenStore.set(tokens);\n  }\n\n  protected _hasPersistentTokenStore(overrideTokenStoreInit?: TokenStoreInit): this is StackClientApp<true, ProjectId> {\n    return (overrideTokenStoreInit !== undefined ? overrideTokenStoreInit : this._tokenStoreInit) !== null;\n  }\n\n  protected _ensurePersistentTokenStore(overrideTokenStoreInit?: TokenStoreInit): asserts this is StackClientApp<true, ProjectId> {\n    if (!this._hasPersistentTokenStore(overrideTokenStoreInit)) {\n      throw new Error(\"Cannot call this function on a Stack app without a persistent token store. Make sure the tokenStore option on the constructor is set to a non-null value when initializing Stack.\\n\\nStack uses token stores to access access tokens of the current user. For example, on web frontends it is commonly the string value 'cookies' for cookie storage.\");\n    }\n  }\n\n  protected _isInternalProject(): this is { projectId: \"internal\" } {\n    return this.projectId === \"internal\";\n  }\n\n  protected _ensureInternalProject(): asserts this is { projectId: \"internal\" } {\n    if (!this._isInternalProject()) {\n      throw new Error(\"Cannot call this function on a Stack app with a project ID other than 'internal'.\");\n    }\n  }\n\n  protected _clientProjectFromCrud(crud: ClientProjectsCrud['Client']['Read']): Project {\n    return {\n      id: crud.id,\n      displayName: crud.display_name,\n      config: {\n        signUpEnabled: crud.config.sign_up_enabled,\n        credentialEnabled: crud.config.credential_enabled,\n        magicLinkEnabled: crud.config.magic_link_enabled,\n        passkeyEnabled: crud.config.passkey_enabled,\n        clientTeamCreationEnabled: crud.config.client_team_creation_enabled,\n        clientUserDeletionEnabled: crud.config.client_user_deletion_enabled,\n        allowTeamApiKeys: crud.config.allow_team_api_keys,\n        allowUserApiKeys: crud.config.allow_user_api_keys,\n        oauthProviders: crud.config.enabled_oauth_providers.map((p) => ({\n          id: p.id,\n        })),\n      }\n    };\n  }\n\n  protected _clientPermissionFromCrud(crud: TeamPermissionsCrud['Client']['Read'] | ProjectPermissionsCrud['Client']['Read']): TeamPermission {\n    return {\n      id: crud.id,\n    };\n  }\n\n  protected _clientTeamUserFromCrud(crud: TeamMemberProfilesCrud['Client']['Read']): TeamUser {\n    return {\n      id: crud.user_id,\n      teamProfile: {\n        displayName: crud.display_name,\n        profileImageUrl: crud.profile_image_url,\n      }\n    };\n  }\n\n  protected _clientTeamInvitationFromCrud(session: InternalSession, crud: TeamInvitationCrud['Client']['Read']): TeamInvitation {\n    return {\n      id: crud.id,\n      recipientEmail: crud.recipient_email,\n      expiresAt: new Date(crud.expires_at_millis),\n      revoke: async () => {\n        await this._interface.revokeTeamInvitation(crud.id, crud.team_id, session);\n        await this._teamInvitationsCache.refresh([session, crud.team_id]);\n      },\n    };\n  }\n\n  protected _baseApiKeyFromCrud(\n    crud: TeamApiKeysCrud['Client']['Read'] | UserApiKeysCrud['Client']['Read'] | yup.InferType<typeof teamApiKeysCreateOutputSchema> | yup.InferType<typeof userApiKeysCreateOutputSchema>\n  ): Omit<ApiKey<\"user\", boolean>, \"revoke\" | \"update\"> | Omit<ApiKey<\"team\", boolean>, \"revoke\" | \"update\"> {\n    return {\n      id: crud.id,\n      description: crud.description,\n      expiresAt: crud.expires_at_millis ? new Date(crud.expires_at_millis) : undefined,\n      manuallyRevokedAt: crud.manually_revoked_at_millis ? new Date(crud.manually_revoked_at_millis) : null,\n      createdAt: new Date(crud.created_at_millis),\n      ...(crud.type === \"team\" ? { type: \"team\", teamId: crud.team_id } : { type: \"user\", userId: crud.user_id }),\n      value: typeof crud.value === \"string\" ? crud.value : {\n        lastFour: crud.value.last_four,\n      },\n      isValid: function () {\n        return this.whyInvalid() === null;\n      },\n      whyInvalid: function () {\n        if (this.manuallyRevokedAt) {\n          return \"manually-revoked\";\n        }\n        if (this.expiresAt && this.expiresAt < new Date()) {\n          return \"expired\";\n        }\n        return null;\n      },\n    };\n  }\n\n\n  protected _clientApiKeyFromCrud(session: InternalSession, crud: TeamApiKeysCrud['Client']['Read']): ApiKey<\"team\">;\n  protected _clientApiKeyFromCrud(session: InternalSession, crud: UserApiKeysCrud['Client']['Read']): ApiKey<\"user\">;\n  protected _clientApiKeyFromCrud(session: InternalSession, crud: yup.InferType<typeof teamApiKeysCreateOutputSchema>): ApiKey<\"team\", true>;\n  protected _clientApiKeyFromCrud(session: InternalSession, crud: yup.InferType<typeof userApiKeysCreateOutputSchema>): ApiKey<\"user\", true>;\n  protected _clientApiKeyFromCrud(session: InternalSession, crud: TeamApiKeysCrud['Client']['Read'] | UserApiKeysCrud['Client']['Read'] | yup.InferType<typeof teamApiKeysCreateOutputSchema> | yup.InferType<typeof userApiKeysCreateOutputSchema>): ApiKey<\"user\" | \"team\", boolean> {\n    return {\n      ...this._baseApiKeyFromCrud(crud),\n      async revoke() {\n        await this.update({ revoked: true });\n      },\n      update: async (options: ApiKeyUpdateOptions) => {\n        await this._interface.updateProjectApiKey(crud.type === \"team\" ? { team_id: crud.team_id } : { user_id: crud.user_id }, crud.id, options, session, \"client\");\n        if (crud.type === \"team\") {\n          await this._teamApiKeysCache.refresh([session, crud.team_id]);\n        } else {\n          await this._userApiKeysCache.refresh([session]);\n        }\n      },\n    };\n  }\n\n  protected _clientTeamFromCrud(crud: TeamsCrud['Client']['Read'], session: InternalSession): Team {\n    const app = this;\n    return {\n      id: crud.id,\n      displayName: crud.display_name,\n      profileImageUrl: crud.profile_image_url,\n      clientMetadata: crud.client_metadata,\n      clientReadOnlyMetadata: crud.client_read_only_metadata,\n      ...this._createCustomer(crud.id, \"team\", session),\n      async inviteUser(options: { email: string, callbackUrl?: string }) {\n        await app._interface.sendTeamInvitation({\n          teamId: crud.id,\n          email: options.email,\n          session,\n          callbackUrl: options.callbackUrl ?? constructRedirectUrl(app.urls.teamInvitation, \"callbackUrl\"),\n        });\n        await app._teamInvitationsCache.refresh([session, crud.id]);\n      },\n      async listUsers() {\n        const result = Result.orThrow(await app._teamMemberProfilesCache.getOrWait([session, crud.id], \"write-only\"));\n        return result.map((crud) => app._clientTeamUserFromCrud(crud));\n      },\n      useUsers() {\n        const result = useAsyncCache(app._teamMemberProfilesCache, [session, crud.id] as const, \"team.useUsers()\");\n        return result.map((crud) => app._clientTeamUserFromCrud(crud));\n      },\n      async listInvitations() {\n        const result = Result.orThrow(await app._teamInvitationsCache.getOrWait([session, crud.id], \"write-only\"));\n        return result.map((crud) => app._clientTeamInvitationFromCrud(session, crud));\n      },\n      useInvitations() {\n        const result = useAsyncCache(app._teamInvitationsCache, [session, crud.id] as const, \"team.useInvitations()\");\n        return result.map((crud) => app._clientTeamInvitationFromCrud(session, crud));\n      },\n      async update(data: TeamUpdateOptions) {\n        await app._interface.updateTeam({ data: teamUpdateOptionsToCrud(data), teamId: crud.id }, session);\n        await app._currentUserTeamsCache.refresh([session]);\n      },\n      async delete() {\n        await app._interface.deleteTeam(crud.id, session);\n        await app._currentUserTeamsCache.refresh([session]);\n      },\n\n      useApiKeys() {\n        const result = useAsyncCache(app._teamApiKeysCache, [session, crud.id] as const, \"team.useApiKeys()\");\n        return result.map((crud) => app._clientApiKeyFromCrud(session, crud));\n      },\n\n      async listApiKeys() {\n        const results = Result.orThrow(await app._teamApiKeysCache.getOrWait([session, crud.id], \"write-only\"));\n        return results.map((crud) => app._clientApiKeyFromCrud(session, crud));\n      },\n\n      async createApiKey(options: ApiKeyCreationOptions<\"team\">) {\n        const result = await app._interface.createProjectApiKey(\n          await apiKeyCreationOptionsToCrud(\"team\", crud.id, options),\n          session,\n          \"client\",\n        );\n        await app._teamApiKeysCache.refresh([session, crud.id]);\n        return app._clientApiKeyFromCrud(session, result);\n      },\n    };\n  }\n\n  protected _clientContactChannelFromCrud(crud: ContactChannelsCrud['Client']['Read'], session: InternalSession): ContactChannel {\n    const app = this;\n    return {\n      id: crud.id,\n      value: crud.value,\n      type: crud.type,\n      isVerified: crud.is_verified,\n      isPrimary: crud.is_primary,\n      usedForAuth: crud.used_for_auth,\n\n      async sendVerificationEmail(options?: { callbackUrl?: string }) {\n        await app._interface.sendCurrentUserContactChannelVerificationEmail(\n          crud.id,\n          options?.callbackUrl || constructRedirectUrl(app.urls.emailVerification, \"callbackUrl\"),\n          session\n        );\n      },\n      async update(data: ContactChannelUpdateOptions) {\n        await app._interface.updateClientContactChannel(crud.id, contactChannelUpdateOptionsToCrud(data), session);\n        await app._clientContactChannelsCache.refresh([session]);\n      },\n      async delete() {\n        await app._interface.deleteClientContactChannel(crud.id, session);\n        await app._clientContactChannelsCache.refresh([session]);\n      },\n    };\n  }\n  protected _clientNotificationCategoryFromCrud(crud: NotificationPreferenceCrud['Client']['Read'], session: InternalSession): NotificationCategory {\n    const app = this;\n    return {\n      id: crud.notification_category_id,\n      name: crud.notification_category_name,\n      enabled: crud.enabled,\n      canDisable: crud.can_disable,\n\n      async setEnabled(enabled: boolean) {\n        await app._interface.setNotificationsEnabled(crud.notification_category_id, enabled, session);\n        await app._notificationCategoriesCache.refresh([session]);\n      },\n    };\n  }\n  protected _clientOAuthProviderFromCrud(crud: OAuthProviderCrud['Client']['Read'], session: InternalSession): OAuthProvider {\n    const app = this;\n    return {\n      id: crud.id,\n      type: crud.type,\n      userId: crud.user_id,\n      email: crud.email,\n      allowSignIn: crud.allow_sign_in,\n      allowConnectedAccounts: crud.allow_connected_accounts,\n\n      async update(data: { allowSignIn?: boolean, allowConnectedAccounts?: boolean }): Promise<Result<void,\n        InstanceType<typeof KnownErrors.OAuthProviderAccountIdAlreadyUsedForSignIn>\n      >> {\n        try {\n          await app._interface.updateOAuthProvider(\n            crud.user_id,\n            crud.id,\n            {\n              allow_sign_in: data.allowSignIn,\n              allow_connected_accounts: data.allowConnectedAccounts,\n            }, session);\n          await app._currentUserOAuthProvidersCache.refresh([session]);\n          return Result.ok(undefined);\n        } catch (error) {\n          if (KnownErrors.OAuthProviderAccountIdAlreadyUsedForSignIn.isInstance(error)) {\n            return Result.error(error);\n          }\n          throw error;\n        }\n      },\n\n      async delete() {\n        await app._interface.deleteOAuthProvider(crud.user_id, crud.id, session);\n        await app._currentUserOAuthProvidersCache.refresh([session]);\n      },\n    };\n  }\n\n  protected _clientItemFromCrud(crud: ItemCrud['Client']['Read']): Item {\n    const app = this;\n    return {\n      displayName: crud.display_name,\n      quantity: crud.quantity,\n      nonNegativeQuantity: Math.max(0, crud.quantity),\n    };\n  }\n\n  protected _customerProductsFromResponse(response: CustomerProductsListResponse): CustomerProductsList {\n    const products = response.items.map((item) => ({\n      id: item.id,\n      quantity: item.quantity,\n      displayName: item.product.display_name,\n      customerType: item.product.customer_type,\n      isServerOnly: item.product.server_only,\n      stackable: item.product.stackable,\n    }));\n    return Object.assign(products, { nextCursor: response.pagination.next_cursor ?? null });\n  }\n\n  protected _createAuth(session: InternalSession): Auth {\n    const app = this;\n    return {\n      _internalSession: session,\n      currentSession: {\n        async getTokens() {\n          const tokens = await session.getOrFetchLikelyValidTokens(20_000);\n          return {\n            accessToken: tokens?.accessToken.token ?? null,\n            refreshToken: tokens?.refreshToken?.token ?? null,\n          };\n        },\n      },\n      async getAuthHeaders(): Promise<{ \"x-stack-auth\": string }> {\n        return {\n          \"x-stack-auth\": JSON.stringify(await this.getAuthJson()),\n        };\n      },\n      async getAuthJson(): Promise<{ accessToken: string | null, refreshToken: string | null }> {\n        const tokens = await this.currentSession.getTokens();\n        return tokens;\n      },\n      signOut(options?: { redirectUrl?: URL | string }) {\n        return app._signOut(session, options);\n      },\n    };\n  }\n\n  protected _editableTeamProfileFromCrud(crud: TeamMemberProfilesCrud['Client']['Read'], session: InternalSession): EditableTeamMemberProfile {\n    const app = this;\n    return {\n      displayName: crud.display_name,\n      profileImageUrl: crud.profile_image_url,\n      async update(update: { displayName?: string, profileImageUrl?: string }) {\n        await app._interface.updateTeamMemberProfile({\n          teamId: crud.team_id,\n          userId: crud.user_id,\n          profile: {\n            display_name: update.displayName,\n            profile_image_url: update.profileImageUrl,\n          },\n        }, session);\n        await app._currentUserTeamProfileCache.refresh([session, crud.team_id]);\n      }\n    };\n  }\n\n  protected _createBaseUser(crud: NonNullable<CurrentUserCrud['Client']['Read']> | UsersCrud['Server']['Read']): BaseUser {\n    return {\n      id: crud.id,\n      displayName: crud.display_name,\n      primaryEmail: crud.primary_email,\n      primaryEmailVerified: crud.primary_email_verified,\n      profileImageUrl: crud.profile_image_url,\n      signedUpAt: new Date(crud.signed_up_at_millis),\n      clientMetadata: crud.client_metadata,\n      clientReadOnlyMetadata: crud.client_read_only_metadata,\n      hasPassword: crud.has_password,\n      emailAuthEnabled: crud.auth_with_email,\n      otpAuthEnabled: crud.otp_auth_enabled,\n      oauthProviders: crud.oauth_providers,\n      passkeyAuthEnabled: crud.passkey_auth_enabled,\n      isMultiFactorRequired: crud.requires_totp_mfa,\n      isAnonymous: crud.is_anonymous,\n      toClientJson(): CurrentUserCrud['Client']['Read'] {\n        return crud;\n      }\n    };\n  }\n\n  protected _createUserExtraFromCurrent(crud: NonNullable<CurrentUserCrud['Client']['Read']>, session: InternalSession): UserExtra {\n    const app = this;\n    async function getConnectedAccount(id: ProviderType, options?: { scopes?: string[] }): Promise<OAuthConnection | null>;\n    async function getConnectedAccount(id: ProviderType, options: { or: 'redirect', scopes?: string[] }): Promise<OAuthConnection>;\n    async function getConnectedAccount(id: ProviderType, options?: { or?: 'redirect', scopes?: string[] }): Promise<OAuthConnection | null> {\n      const scopeString = options?.scopes?.join(\" \");\n      return Result.orThrow(await app._currentUserOAuthConnectionCache.getOrWait([session, id, scopeString || \"\", options?.or === 'redirect'], \"write-only\"));\n    }\n\n    function useConnectedAccount(id: ProviderType, options?: { scopes?: string[] }): OAuthConnection | null;\n    function useConnectedAccount(id: ProviderType, options: { or: 'redirect', scopes?: string[] }): OAuthConnection;\n    function useConnectedAccount(id: ProviderType, options?: { or?: 'redirect', scopes?: string[] }): OAuthConnection | null {\n      const scopeString = options?.scopes?.join(\" \");\n      return useAsyncCache(app._currentUserOAuthConnectionCache, [session, id, scopeString || \"\", options?.or === 'redirect'] as const, \"user.useConnectedAccount()\");\n    }\n    return {\n      async getActiveSessions() {\n        const sessions = await app._interface.listSessions(session);\n        return sessions.items.map((crud) => app._clientSessionFromCrud(crud));\n      },\n      async revokeSession(sessionId: string) {\n        await app._interface.deleteSession(sessionId, session);\n      },\n      setDisplayName(displayName: string) {\n        return this.update({ displayName });\n      },\n      setClientMetadata(metadata: Record<string, any>) {\n        return this.update({ clientMetadata: metadata });\n      },\n      async setSelectedTeam(team: Team | null) {\n        await this.update({ selectedTeamId: team?.id ?? null });\n      },\n      getConnectedAccount,\n      useConnectedAccount, // THIS_LINE_PLATFORM react-like\n      async getTeam(teamId: string) {\n        const teams = await this.listTeams();\n        return teams.find((t) => t.id === teamId) ?? null;\n      },\n      useTeam(teamId: string) {\n        const teams = this.useTeams();\n        return useMemo(() => {\n          return teams.find((t) => t.id === teamId) ?? null;\n        }, [teams, teamId]);\n      },\n      async listTeams() {\n        const teams = Result.orThrow(await app._currentUserTeamsCache.getOrWait([session], \"write-only\"));\n        return teams.map((crud) => app._clientTeamFromCrud(crud, session));\n      },\n      useTeams() {\n        const teams = useAsyncCache(app._currentUserTeamsCache, [session], \"user.useTeams()\");\n        return useMemo(() => teams.map((crud) => app._clientTeamFromCrud(crud, session)), [teams]);\n      },\n      async createTeam(data: TeamCreateOptions) {\n        const crud = await app._interface.createClientTeam(teamCreateOptionsToCrud(data, 'me'), session);\n        await app._currentUserTeamsCache.refresh([session]);\n        await this.update({ selectedTeamId: crud.id });\n        return app._clientTeamFromCrud(crud, session);\n      },\n      async leaveTeam(team: Team) {\n        await app._interface.leaveTeam(team.id, session);\n        // TODO: refresh cache\n      },\n      async listPermissions(scopeOrOptions?: Team | { recursive?: boolean }, options?: { recursive?: boolean }): Promise<TeamPermission[]> {\n        if (scopeOrOptions && 'id' in scopeOrOptions) {\n          const scope = scopeOrOptions;\n          const recursive = options?.recursive ?? true;\n          const permissions = Result.orThrow(await app._currentUserPermissionsCache.getOrWait([session, scope.id, recursive], \"write-only\"));\n          return permissions.map((crud) => app._clientPermissionFromCrud(crud));\n        } else {\n          const opts = scopeOrOptions;\n          const recursive = opts?.recursive ?? true;\n          const permissions = Result.orThrow(await app._currentUserProjectPermissionsCache.getOrWait([session, recursive], \"write-only\"));\n          return permissions.map((crud) => app._clientPermissionFromCrud(crud));\n        }\n      },\n      usePermissions(scopeOrOptions?: Team | { recursive?: boolean }, options?: { recursive?: boolean }): TeamPermission[] {\n        if (scopeOrOptions && 'id' in scopeOrOptions) {\n          const scope = scopeOrOptions;\n          const recursive = options?.recursive ?? true;\n          const permissions = useAsyncCache(app._currentUserPermissionsCache, [session, scope.id, recursive] as const, \"user.usePermissions()\");\n          return useMemo(() => permissions.map((crud) => app._clientPermissionFromCrud(crud)), [permissions]);\n        } else {\n          const opts = scopeOrOptions;\n          const recursive = opts?.recursive ?? true;\n          const permissions = useAsyncCache(app._currentUserProjectPermissionsCache, [session, recursive] as const, \"user.usePermissions()\");\n          return useMemo(() => permissions.map((crud) => app._clientPermissionFromCrud(crud)), [permissions]);\n        }\n      },\n      usePermission(scopeOrPermissionId: Team | string, permissionId?: string): TeamPermission | null {\n        if (scopeOrPermissionId && typeof scopeOrPermissionId !== 'string') {\n          const scope = scopeOrPermissionId;\n          const permissions = this.usePermissions(scope);\n          return useMemo(() => permissions.find((p) => p.id === permissionId) ?? null, [permissions, permissionId]);\n        } else {\n          const pid = scopeOrPermissionId;\n          const permissions = this.usePermissions();\n          return useMemo(() => permissions.find((p) => p.id === pid) ?? null, [permissions, pid]);\n        }\n      },\n      async getPermission(scopeOrPermissionId: Team | string, permissionId?: string): Promise<TeamPermission | null> {\n        if (scopeOrPermissionId && typeof scopeOrPermissionId !== 'string') {\n          const scope = scopeOrPermissionId;\n          const permissions = await this.listPermissions(scope);\n          return permissions.find((p) => p.id === permissionId) ?? null;\n        } else {\n          const pid = scopeOrPermissionId;\n          const permissions = await this.listPermissions();\n          return permissions.find((p) => p.id === pid) ?? null;\n        }\n      },\n      async hasPermission(scopeOrPermissionId: Team | string, permissionId?: string): Promise<boolean> {\n        if (scopeOrPermissionId && typeof scopeOrPermissionId !== 'string') {\n          const scope = scopeOrPermissionId;\n          return (await this.getPermission(scope, permissionId as string)) !== null;\n        } else {\n          const pid = scopeOrPermissionId;\n          return (await this.getPermission(pid)) !== null;\n        }\n      },\n      async update(update) {\n        return await app._updateClientUser(update, session);\n      },\n      async sendVerificationEmail(options?: { callbackUrl?: string }) {\n        if (!crud.primary_email) {\n          throw new StackAssertionError(\"User does not have a primary email\");\n        }\n        return await app._interface.sendVerificationEmail(\n          crud.primary_email,\n          options?.callbackUrl ?? constructRedirectUrl(app.urls.emailVerification, \"callbackUrl\"),\n          session\n        );\n      },\n      async updatePassword(options: { oldPassword: string, newPassword: string }) {\n        const result = await app._interface.updatePassword(options, session);\n        await app._currentUserCache.refresh([session]);\n        return result;\n      },\n      async setPassword(options: { password: string }) {\n        const result = await app._interface.setPassword(options, session);\n        await app._currentUserCache.refresh([session]);\n        return result;\n      },\n      selectedTeam: crud.selected_team && this._clientTeamFromCrud(crud.selected_team, session),\n      async getTeamProfile(team: Team) {\n        const result = Result.orThrow(await app._currentUserTeamProfileCache.getOrWait([session, team.id], \"write-only\"));\n        return app._editableTeamProfileFromCrud(result, session);\n      },\n      useTeamProfile(team: Team) {\n        const result = useAsyncCache(app._currentUserTeamProfileCache, [session, team.id] as const, \"user.useTeamProfile()\");\n        return app._editableTeamProfileFromCrud(result, session);\n      },\n      async delete() {\n        await app._interface.deleteCurrentUser(session);\n        session.markInvalid();\n      },\n      async listContactChannels() {\n        const result = Result.orThrow(await app._clientContactChannelsCache.getOrWait([session], \"write-only\"));\n        return result.map((crud) => app._clientContactChannelFromCrud(crud, session));\n      },\n      useContactChannels() {\n        const result = useAsyncCache(app._clientContactChannelsCache, [session] as const, \"user.useContactChannels()\");\n        return result.map((crud) => app._clientContactChannelFromCrud(crud, session));\n      },\n      async createContactChannel(data: ContactChannelCreateOptions) {\n        const crud = await app._interface.createClientContactChannel(contactChannelCreateOptionsToCrud('me', data), session);\n        await app._clientContactChannelsCache.refresh([session]);\n        return app._clientContactChannelFromCrud(crud, session);\n      },\n      useNotificationCategories() {\n        const results = useAsyncCache(app._notificationCategoriesCache, [session] as const, \"user.useNotificationCategories()\");\n        return results.map((crud) => app._clientNotificationCategoryFromCrud(crud, session));\n      },\n      async listNotificationCategories() {\n        const results = Result.orThrow(await app._notificationCategoriesCache.getOrWait([session], \"write-only\"));\n        return results.map((crud) => app._clientNotificationCategoryFromCrud(crud, session));\n      },\n      useApiKeys() {\n        const result = useAsyncCache(app._userApiKeysCache, [session] as const, \"user.useApiKeys()\");\n        return result.map((crud) => app._clientApiKeyFromCrud(session, crud));\n      },\n\n      async listApiKeys() {\n        const results = await app._interface.listProjectApiKeys({ user_id: 'me' }, session, \"client\");\n        return results.map((crud) => app._clientApiKeyFromCrud(session, crud));\n      },\n\n      async createApiKey(options: ApiKeyCreationOptions<\"user\">) {\n        const result = await app._interface.createProjectApiKey(\n          await apiKeyCreationOptionsToCrud(\"user\", \"me\", options),\n          session,\n          \"client\",\n        );\n        await app._userApiKeysCache.refresh([session]);\n        return app._clientApiKeyFromCrud(session, result);\n      },\n\n      useOAuthProviders() {\n        const results = useAsyncCache(app._currentUserOAuthProvidersCache, [session] as const, \"user.useOAuthProviders()\");\n        return results.map((crud) => app._clientOAuthProviderFromCrud(crud, session));\n      },\n\n      async listOAuthProviders() {\n        const results = Result.orThrow(await app._currentUserOAuthProvidersCache.getOrWait([session], \"write-only\"));\n        return results.map((crud) => app._clientOAuthProviderFromCrud(crud, session));\n      },\n\n      useOAuthProvider(id: string) {\n        const providers = this.useOAuthProviders();\n        return useMemo(() => providers.find((p) => p.id === id) ?? null, [providers, id]);\n      },\n\n      async getOAuthProvider(id: string) {\n        const providers = await this.listOAuthProviders();\n        return providers.find((p) => p.id === id) ?? null;\n      },\n\n      async registerPasskey(options?: { hostname?: string }): Promise<Result<undefined, KnownErrors[\"PasskeyRegistrationFailed\"] | KnownErrors[\"PasskeyWebAuthnError\"]>> {\n        const hostname = (await app._getCurrentUrl())?.hostname;\n        if (!hostname) {\n          throw new StackAssertionError(\"hostname must be provided if the Stack App does not have a redirect method\");\n        }\n\n        const initiationResult = await app._interface.initiatePasskeyRegistration({}, session);\n\n        if (initiationResult.status !== \"ok\") {\n          return Result.error(new KnownErrors.PasskeyRegistrationFailed(\"Failed to get initiation options for passkey registration\"));\n        }\n\n        const { options_json, code } = initiationResult.data;\n\n        // HACK: Override the rpID to be the actual domain\n        if (options_json.rp.id !== \"THIS_VALUE_WILL_BE_REPLACED.example.com\") {\n          throw new StackAssertionError(`Expected returned RP ID from server to equal sentinel, but found ${options_json.rp.id}`);\n        }\n\n        options_json.rp.id = hostname;\n\n        let attResp;\n        try {\n          attResp = await startRegistration({ optionsJSON: options_json });\n        } catch (error: any) {\n          if (error instanceof WebAuthnError) {\n            return Result.error(new KnownErrors.PasskeyWebAuthnError(error.message, error.name));\n          } else {\n            // This should never happen\n            captureError(\"passkey-registration-failed\", error);\n            return Result.error(new KnownErrors.PasskeyRegistrationFailed(\"Failed to start passkey registration due to unknown error\"));\n          }\n        }\n\n\n        const registrationResult = await app._interface.registerPasskey({ credential: attResp, code }, session);\n\n        await app._refreshUser(session);\n        return registrationResult;\n      },\n    };\n  }\n\n  protected _createInternalUserExtra(session: InternalSession): InternalUserExtra {\n    const app = this;\n    this._ensureInternalProject();\n    return {\n      createProject(newProject: AdminProjectUpdateOptions & { displayName: string, teamId: string }) {\n        return app._createProject(session, newProject);\n      },\n      async transferProject(projectIdToTransfer: string, newTeamId: string): Promise<void> {\n        await app._interface.transferProject(session, projectIdToTransfer, newTeamId);\n        await app._refreshProject();\n      },\n      listOwnedProjects() {\n        return app._listOwnedProjects(session);\n      },\n      useOwnedProjects() {\n        return app._useOwnedProjects(session);\n      },\n    };\n  }\n\n  protected _createCustomer(userIdOrTeamId: string, type: \"user\" | \"team\", session: InternalSession | null): Omit<Customer, \"id\"> {\n    const app = this;\n    const customerOptions = type === \"user\" ? { userId: userIdOrTeamId } : { teamId: userIdOrTeamId };\n    return {\n      async getItem(itemId: string) {\n        return await app.getItem({ itemId, ...customerOptions });\n      },\n      useItem(itemId: string) {\n        return app.useItem({ itemId, ...customerOptions });\n      },\n      async listProducts(options?: CustomerProductsListOptions) {\n        return await app.listProducts({ ...options, ...customerOptions });\n      },\n      useProducts(options?: CustomerProductsListOptions) {\n        return app.useProducts({ ...options, ...customerOptions });\n      },\n      async createCheckoutUrl(options: { productId: string, returnUrl?: string }) {\n        return await app._interface.createCheckoutUrl(type, userIdOrTeamId, options.productId, session, options.returnUrl);\n      },\n    };\n  }\n\n  async getItem(options: { itemId: string, userId: string } | { itemId: string, teamId: string } | { itemId: string, customCustomerId: string }): Promise<Item> {\n    const session = await this._getSession();\n    let crud: ItemCrud['Client']['Read'];\n    if (\"userId\" in options) {\n      crud = Result.orThrow(await this._userItemCache.getOrWait([session, options.userId, options.itemId], \"write-only\"));\n    } else if (\"teamId\" in options) {\n      crud = Result.orThrow(await this._teamItemCache.getOrWait([session, options.teamId, options.itemId], \"write-only\"));\n    } else {\n      crud = Result.orThrow(await this._customItemCache.getOrWait([session, options.customCustomerId, options.itemId], \"write-only\"));\n    }\n    return this._clientItemFromCrud(crud);\n  }\n\n  useItem(options: { itemId: string, userId: string } | { itemId: string, teamId: string } | { itemId: string, customCustomerId: string }): Item {\n    const session = this._useSession();\n    const [cache, ownerId] =\n      \"userId\" in options ? [this._userItemCache, options.userId] :\n        \"teamId\" in options ? [this._teamItemCache, options.teamId] : [this._customItemCache, options.customCustomerId];\n    const crud = useAsyncCache(cache, [session, ownerId, options.itemId] as const, \"app.useItem()\");\n    return this._clientItemFromCrud(crud);\n  }\n\n  async listProducts(options: CustomerProductsRequestOptions): Promise<CustomerProductsList> {\n    const session = await this._getSession();\n    if (\"userId\" in options) {\n      const response = Result.orThrow(await this._userProductsCache.getOrWait([session, options.userId, options.cursor ?? null, options.limit ?? null], \"write-only\"));\n      return this._customerProductsFromResponse(response);\n    } else if (\"teamId\" in options) {\n      const response = Result.orThrow(await this._teamProductsCache.getOrWait([session, options.teamId, options.cursor ?? null, options.limit ?? null], \"write-only\"));\n      return this._customerProductsFromResponse(response);\n    }\n    const response = Result.orThrow(await this._customProductsCache.getOrWait([session, options.customCustomerId, options.cursor ?? null, options.limit ?? null], \"write-only\"));\n    return this._customerProductsFromResponse(response);\n  }\n\n  useProducts(options: CustomerProductsRequestOptions): CustomerProductsList {\n    const session = this._useSession();\n    const cache = \"userId\" in options ? this._userProductsCache : \"teamId\" in options ? this._teamProductsCache : this._customProductsCache;\n    const debugLabel = \"clientApp.useProducts()\";\n    const customerId = \"userId\" in options ? options.userId : \"teamId\" in options ? options.teamId : options.customCustomerId;\n    const response = useAsyncCache(cache, [session, customerId, options.cursor ?? null, options.limit ?? null] as const, debugLabel);\n    return this._customerProductsFromResponse(response);\n  }\n\n  protected _currentUserFromCrud(crud: NonNullable<CurrentUserCrud['Client']['Read']>, session: InternalSession): ProjectCurrentUser<ProjectId> {\n    const currentUser = {\n      ...this._createBaseUser(crud),\n      ...this._createAuth(session),\n      ...this._createUserExtraFromCurrent(crud, session),\n      ...this._isInternalProject() ? this._createInternalUserExtra(session) : {},\n      ...this._createCustomer(crud.id, \"user\", session),\n    } satisfies CurrentUser;\n\n    attachUserDestructureGuard(currentUser);\n    Object.freeze(currentUser);\n    return currentUser as ProjectCurrentUser<ProjectId>;\n  }\n  protected _clientSessionFromCrud(crud: SessionsCrud['Client']['Read']): ActiveSession {\n    return {\n      id: crud.id,\n      userId: crud.user_id,\n      createdAt: new Date(crud.created_at),\n      isImpersonation: crud.is_impersonation,\n      lastUsedAt: crud.last_used_at ? new Date(crud.last_used_at) : undefined,\n      isCurrentSession: crud.is_current_session ?? false,\n      geoInfo: crud.last_used_at_end_user_ip_info,\n    };\n  }\n\n  protected _getOwnedAdminApp(forProjectId: string, session: InternalSession): _StackAdminAppImplIncomplete<false, string> {\n    if (!this._ownedAdminApps.has([session, forProjectId])) {\n      this._ownedAdminApps.set([session, forProjectId], new (_StackClientAppImplIncomplete.LazyStackAdminAppImpl.value!)({\n        baseUrl: this._interface.options.getBaseUrl(),\n        projectId: forProjectId,\n        tokenStore: null,\n        projectOwnerSession: session,\n        noAutomaticPrefetch: true,\n      }));\n    }\n    return this._ownedAdminApps.get([session, forProjectId])!;\n  }\n\n  get projectId(): ProjectId {\n    return this._interface.projectId as ProjectId;\n  }\n\n  protected async _isTrusted(url: string): Promise<boolean> {\n    return isRelative(url);\n  }\n\n  get urls(): Readonly<HandlerUrls> {\n    return getUrls(this._urlOptions);\n  }\n\n  protected async _getCurrentUrl() {\n    if (this._redirectMethod === \"none\") {\n      return null;\n    }\n    return new URL(window.location.href);\n  }\n\n  protected async _redirectTo(options: { url: URL | string, replace?: boolean }) {\n    if (this._redirectMethod === \"none\") {\n      return;\n    } else if (isReactServer && this._redirectMethod === \"nextjs\") {\n      NextNavigation.redirect(options.url.toString(), options.replace ? NextNavigation.RedirectType.replace : NextNavigation.RedirectType.push);\n    } else if (typeof this._redirectMethod === \"object\" && this._redirectMethod.navigate) {\n      this._redirectMethod.navigate(options.url.toString());\n    } else {\n      if (options.replace) {\n        window.location.replace(options.url);\n      } else {\n        window.location.assign(options.url);\n      }\n    }\n\n    await wait(2000);\n  }\n\n  useNavigate(): (to: string) => void {\n    if (typeof this._redirectMethod === \"object\") {\n      return this._redirectMethod.useNavigate();\n    } else if (this._redirectMethod === \"window\") {\n      return (to: string) => window.location.assign(to);\n    } else if (this._redirectMethod === \"nextjs\") {\n      const router = NextNavigation.useRouter();\n      return (to: string) => router.push(to);\n    } else {\n      return (to: string) => { };\n    }\n  }\n  protected async _redirectIfTrusted(url: string, options?: RedirectToOptions) {\n    if (!await this._isTrusted(url)) {\n      throw new Error(`Redirect URL ${url} is not trusted; should be relative.`);\n    }\n    return await this._redirectTo({ url, ...options });\n  }\n\n  protected async _redirectToHandler(handlerName: keyof HandlerUrls, options?: RedirectToOptions) {\n    let url = this.urls[handlerName];\n    if (!url) {\n      throw new Error(`No URL for handler name ${handlerName}`);\n    }\n\n    if (!options?.noRedirectBack) {\n      if (handlerName === \"afterSignIn\" || handlerName === \"afterSignUp\") {\n        if (isReactServer || typeof window === \"undefined\") {\n          // TODO implement this\n        } else {\n          const queryParams = new URLSearchParams(window.location.search);\n          url = queryParams.get(\"after_auth_return_to\") || url;\n        }\n      } else if (handlerName === \"signIn\" || handlerName === \"signUp\") {\n        if (isReactServer || typeof window === \"undefined\") {\n          // TODO implement this\n        } else {\n          const currentUrl = new URL(window.location.href);\n          const nextUrl = new URL(url, currentUrl);\n          if (currentUrl.searchParams.has(\"after_auth_return_to\")) {\n            nextUrl.searchParams.set(\"after_auth_return_to\", currentUrl.searchParams.get(\"after_auth_return_to\")!);\n          } else if (currentUrl.protocol === nextUrl.protocol && currentUrl.host === nextUrl.host) {\n            nextUrl.searchParams.set(\"after_auth_return_to\", getRelativePart(currentUrl));\n          }\n          url = getRelativePart(nextUrl);\n        }\n      }\n    }\n\n    await this._redirectIfTrusted(url, options);\n  }\n\n  async redirectToSignIn(options?: RedirectToOptions) { return await this._redirectToHandler(\"signIn\", options); }\n  async redirectToSignUp(options?: RedirectToOptions) { return await this._redirectToHandler(\"signUp\", options); }\n  async redirectToSignOut(options?: RedirectToOptions) { return await this._redirectToHandler(\"signOut\", options); }\n  async redirectToEmailVerification(options?: RedirectToOptions) { return await this._redirectToHandler(\"emailVerification\", options); }\n  async redirectToPasswordReset(options?: RedirectToOptions) { return await this._redirectToHandler(\"passwordReset\", options); }\n  async redirectToForgotPassword(options?: RedirectToOptions) { return await this._redirectToHandler(\"forgotPassword\", options); }\n  async redirectToHome(options?: RedirectToOptions) { return await this._redirectToHandler(\"home\", options); }\n  async redirectToOAuthCallback(options?: RedirectToOptions) { return await this._redirectToHandler(\"oauthCallback\", options); }\n  async redirectToMagicLinkCallback(options?: RedirectToOptions) { return await this._redirectToHandler(\"magicLinkCallback\", options); }\n  async redirectToAfterSignIn(options?: RedirectToOptions) { return await this._redirectToHandler(\"afterSignIn\", options); }\n  async redirectToAfterSignUp(options?: RedirectToOptions) { return await this._redirectToHandler(\"afterSignUp\", options); }\n  async redirectToAfterSignOut(options?: RedirectToOptions) { return await this._redirectToHandler(\"afterSignOut\", options); }\n  async redirectToAccountSettings(options?: RedirectToOptions) { return await this._redirectToHandler(\"accountSettings\", options); }\n  async redirectToError(options?: RedirectToOptions) { return await this._redirectToHandler(\"error\", options); }\n  async redirectToTeamInvitation(options?: RedirectToOptions) { return await this._redirectToHandler(\"teamInvitation\", options); }\n  async redirectToMfa(options?: RedirectToOptions) { return await this._redirectToHandler(\"mfa\", options); }\n\n  async sendForgotPasswordEmail(email: string, options?: { callbackUrl?: string }): Promise<Result<undefined, KnownErrors[\"UserNotFound\"]>> {\n    return await this._interface.sendForgotPasswordEmail(email, options?.callbackUrl ?? constructRedirectUrl(this.urls.passwordReset, \"callbackUrl\"));\n  }\n\n  async sendMagicLinkEmail(email: string, options?: { callbackUrl?: string }): Promise<Result<{ nonce: string }, KnownErrors[\"RedirectUrlNotWhitelisted\"]>> {\n    return await this._interface.sendMagicLinkEmail(email, options?.callbackUrl ?? constructRedirectUrl(this.urls.magicLinkCallback, \"callbackUrl\"));\n  }\n\n  async resetPassword(options: { password: string, code: string }): Promise<Result<undefined, KnownErrors[\"VerificationCodeError\"]>> {\n    return await this._interface.resetPassword(options);\n  }\n\n  async verifyPasswordResetCode(code: string): Promise<Result<undefined, KnownErrors[\"VerificationCodeError\"]>> {\n    return await this._interface.verifyPasswordResetCode(code);\n  }\n\n  async verifyTeamInvitationCode(code: string): Promise<Result<undefined, KnownErrors[\"VerificationCodeError\"]>> {\n    return await this._interface.acceptTeamInvitation({\n      type: 'check',\n      code,\n      session: await this._getSession(),\n    });\n  }\n\n  async acceptTeamInvitation(code: string): Promise<Result<undefined, KnownErrors[\"VerificationCodeError\"]>> {\n    const result = await this._interface.acceptTeamInvitation({\n      type: 'use',\n      code,\n      session: await this._getSession(),\n    });\n\n    if (result.status === 'ok') {\n      return Result.ok(undefined);\n    } else {\n      return Result.error(result.error);\n    }\n  }\n\n  async getTeamInvitationDetails(code: string): Promise<Result<{ teamDisplayName: string }, KnownErrors[\"VerificationCodeError\"]>> {\n    const result = await this._interface.acceptTeamInvitation({\n      type: 'details',\n      code,\n      session: await this._getSession(),\n    });\n\n    if (result.status === 'ok') {\n      return Result.ok({ teamDisplayName: result.data.team_display_name });\n    } else {\n      return Result.error(result.error);\n    }\n  }\n\n  async verifyEmail(code: string): Promise<Result<undefined, KnownErrors[\"VerificationCodeError\"]>> {\n    const result = await this._interface.verifyEmail(code);\n    await this._currentUserCache.refresh([await this._getSession()]);\n    await this._clientContactChannelsCache.refresh([await this._getSession()]);\n    return result;\n  }\n\n  async getUser(options: GetCurrentUserOptions<HasTokenStore> & { or: 'redirect' }): Promise<ProjectCurrentUser<ProjectId>>;\n  async getUser(options: GetCurrentUserOptions<HasTokenStore> & { or: 'throw' }): Promise<ProjectCurrentUser<ProjectId>>;\n  async getUser(options: GetCurrentUserOptions<HasTokenStore> & { or: 'anonymous' }): Promise<ProjectCurrentUser<ProjectId>>;\n  async getUser(options?: GetCurrentUserOptions<HasTokenStore>): Promise<ProjectCurrentUser<ProjectId> | null>;\n  async getUser(options?: GetCurrentUserOptions<HasTokenStore>): Promise<ProjectCurrentUser<ProjectId> | null> {\n    this._ensurePersistentTokenStore(options?.tokenStore);\n    const session = await this._getSession(options?.tokenStore);\n    let crud = Result.orThrow(await this._currentUserCache.getOrWait([session], \"write-only\"));\n    if (crud?.is_anonymous && options?.or !== \"anonymous\" && options?.or !== \"anonymous-if-exists[deprecated]\") {\n      crud = null;\n    }\n\n    if (crud === null) {\n      switch (options?.or) {\n        case 'redirect': {\n          await this.redirectToSignIn({ replace: true });\n          break;\n        }\n        case 'throw': {\n          throw new Error(\"User is not signed in but getUser was called with { or: 'throw' }\");\n        }\n        case 'anonymous': {\n          const tokens = await this._signUpAnonymously();\n          return await this.getUser({ tokenStore: tokens, or: \"anonymous-if-exists[deprecated]\" }) ?? throwErr(\"Something went wrong while signing up anonymously\");\n        }\n        case undefined:\n        case \"anonymous-if-exists[deprecated]\":\n        case \"return-null\": {\n          return null;\n        }\n      }\n    }\n\n    return crud && this._currentUserFromCrud(crud, session);\n  }\n\n  useUser(options: GetCurrentUserOptions<HasTokenStore> & { or: 'redirect' }): ProjectCurrentUser<ProjectId>;\n  useUser(options: GetCurrentUserOptions<HasTokenStore> & { or: 'throw' }): ProjectCurrentUser<ProjectId>;\n  useUser(options: GetCurrentUserOptions<HasTokenStore> & { or: 'anonymous' }): ProjectCurrentUser<ProjectId>;\n  useUser(options?: GetCurrentUserOptions<HasTokenStore>): ProjectCurrentUser<ProjectId> | null;\n  useUser(options?: GetCurrentUserOptions<HasTokenStore>): ProjectCurrentUser<ProjectId> | null {\n    this._ensurePersistentTokenStore(options?.tokenStore);\n\n    const session = this._useSession(options?.tokenStore);\n    let crud = useAsyncCache(this._currentUserCache, [session] as const, \"clientApp.useUser()\");\n    if (crud?.is_anonymous && options?.or !== \"anonymous\" && options?.or !== \"anonymous-if-exists[deprecated]\") {\n      crud = null;\n    }\n\n    if (crud === null) {\n      switch (options?.or) {\n        case 'redirect': {\n          runAsynchronously(this.redirectToSignIn({ replace: true }));\n          suspend();\n          throw new StackAssertionError(\"suspend should never return\");\n        }\n        case 'throw': {\n          throw new Error(\"User is not signed in but useUser was called with { or: 'throw' }\");\n        }\n        case 'anonymous': {\n          // TODO we should think about the behavior when calling useUser (or getUser) in anonymous with a custom token store. signUpAnonymously always sets the current token store on app level, instead of the one passed to this function\n          // TODO we shouldn't reload & suspend here, instead we should use a promise that resolves to the new anonymous user\n          runAsynchronously(async () => {\n            await this._signUpAnonymously();\n            if (typeof window !== \"undefined\") {\n              window.location.reload();\n            }\n          });\n          suspend();\n          throw new StackAssertionError(\"suspend should never return\");\n        }\n        case undefined:\n        case \"anonymous-if-exists[deprecated]\":\n        case \"return-null\": {\n          // do nothing\n        }\n      }\n    }\n\n    return useMemo(() => {\n      return crud && this._currentUserFromCrud(crud, session);\n    }, [crud, session, options?.or]);\n  }\n\n  _getTokenPartialUserFromSession(session: InternalSession, options: GetCurrentPartialUserOptions<HasTokenStore>): TokenPartialUser | null {\n    const accessToken = session.getAccessTokenIfNotExpiredYet(0);\n    if (!accessToken) {\n      return null;\n    }\n    const isAnonymous = accessToken.payload.is_anonymous;\n    if (isAnonymous && options.or !== \"anonymous\") {\n      return null;\n    }\n    return {\n      id: accessToken.payload.sub,\n      primaryEmail: accessToken.payload.email,\n      displayName: accessToken.payload.name,\n      primaryEmailVerified: accessToken.payload.email_verified,\n      isAnonymous,\n    } satisfies TokenPartialUser;\n  }\n\n  async _getPartialUserFromConvex(ctx: ConvexCtx): Promise<TokenPartialUser | null> {\n    const auth = await ctx.auth.getUserIdentity();\n    if (!auth) {\n      return null;\n    }\n    return {\n      id: auth.subject,\n      displayName: auth.name ?? null,\n      primaryEmail: auth.email ?? null,\n      primaryEmailVerified: auth.email_verified as boolean,\n      isAnonymous: auth.is_anonymous as boolean,\n    };\n  }\n\n  async getPartialUser(options: GetCurrentPartialUserOptions<HasTokenStore> & { from: 'token' }): Promise<TokenPartialUser | null>;\n  async getPartialUser(options: GetCurrentPartialUserOptions<HasTokenStore> & { from: 'convex' }): Promise<TokenPartialUser | null>;\n  async getPartialUser(options: GetCurrentPartialUserOptions<HasTokenStore>): Promise<SyncedPartialUser | TokenPartialUser | null> {\n    switch (options.from) {\n      case \"token\": {\n        this._ensurePersistentTokenStore(options.tokenStore ?? this._tokenStoreInit);\n        const session = await this._getSession(options.tokenStore);\n        return this._getTokenPartialUserFromSession(session, options);\n      }\n      case \"convex\": {\n        return await this._getPartialUserFromConvex(options.ctx);\n      }\n      default: {\n        // @ts-expect-error\n        throw new Error(`Invalid 'from' option: ${options.from}`);\n      }\n    }\n  }\n  usePartialUser(options: GetCurrentPartialUserOptions<HasTokenStore> & { from: 'token' }): TokenPartialUser | null;\n  usePartialUser(options: GetCurrentPartialUserOptions<HasTokenStore> & { from: 'convex' }): TokenPartialUser | null;\n  usePartialUser(options: GetCurrentPartialUserOptions<HasTokenStore>): TokenPartialUser | SyncedPartialUser | null {\n    switch (options.from) {\n      case \"token\": {\n        this._ensurePersistentTokenStore(options.tokenStore ?? this._tokenStoreInit);\n        const session = this._useSession(options.tokenStore);\n        return this._getTokenPartialUserFromSession(session, options);\n      }\n      case \"convex\": {\n        const result = useAsyncCache(this._convexPartialUserCache, [options.ctx] as const, \"clientApp.usePartialUser()\");\n        return result;\n      }\n      default: {\n        // @ts-expect-error\n        throw new Error(`Invalid 'from' option: ${options.from}`);\n      }\n    }\n  }\n  getConvexClientAuth(options: { tokenStore: TokenStoreInit }): (args: { forceRefreshToken: boolean }) => Promise<string | null> {\n    return async (args: { forceRefreshToken: boolean }) => {\n      const session = await this._getSession(options.tokenStore ?? this._tokenStoreInit);\n      if (!args.forceRefreshToken) {\n        const tokens = await session.getOrFetchLikelyValidTokens(20_000);\n        return tokens?.accessToken.token ?? null;\n      }\n      const tokens = await session.fetchNewTokens();\n      return tokens?.accessToken.token ?? null;\n    };\n  }\n\n  async getConvexHttpClientAuth(options: { tokenStore: TokenStoreInit }): Promise<string> {\n    const session = await this._getSession(options.tokenStore);\n    const tokens = await session.getOrFetchLikelyValidTokens(20_000);\n    return tokens?.accessToken.token ?? \"\";\n  }\n\n  protected async _updateClientUser(update: UserUpdateOptions, session: InternalSession) {\n    const res = await this._interface.updateClientUser(userUpdateOptionsToCrud(update), session);\n    await this._refreshUser(session);\n    return res;\n  }\n\n  async signInWithOAuth(provider: ProviderType, options?: { returnTo?: string }) {\n    if (typeof window === \"undefined\") {\n      throw new Error(\"signInWithOAuth can currently only be called in a browser environment\");\n    }\n\n    this._ensurePersistentTokenStore();\n    const session = await this._getSession();\n    await signInWithOAuth(\n      this._interface,\n      {\n        provider,\n        redirectUrl: options?.returnTo ?? this.urls.oauthCallback,\n        errorRedirectUrl: this.urls.error,\n        providerScope: this._oauthScopesOnSignIn[provider]?.join(\" \"),\n      },\n      session,\n    );\n  }\n\n  /**\n   * Handles MFA verification by redirecting to the OTP page\n   */\n  protected async _experimentalMfa(error: KnownErrors['MultiFactorAuthenticationRequired'], session: InternalSession): Promise<never> {\n    // Store the attempt code in session storage so the OTP page can access it\n    if (typeof window !== 'undefined') {\n      window.sessionStorage.setItem('stack_mfa_attempt_code', (error.details as any)?.attempt_code ?? throwErr(\"attempt code missing\"));\n    }\n\n    // Redirect to the MFA page\n    await this.redirectToMfa();\n\n    throw new StackAssertionError(\"we should have redirected in redirectToMfa()\");\n  }\n\n  /**\n   * @deprecated\n   * TODO remove\n   */\n  protected async _catchMfaRequiredError<T, E>(callback: () => Promise<Result<T, E>>): Promise<Result<T | { accessToken: string, refreshToken: string, newUser: boolean }, E>> {\n    try {\n      return await callback();\n    } catch (e) {\n      if (KnownErrors.MultiFactorAuthenticationRequired.isInstance(e)) {\n        return Result.ok(await this._experimentalMfa(e, await this._getSession()));\n      }\n      throw e;\n    }\n  }\n\n  async signInWithCredential(options: {\n    email: string,\n    password: string,\n    noRedirect?: boolean,\n  }): Promise<Result<undefined, KnownErrors[\"EmailPasswordMismatch\"] | KnownErrors[\"InvalidTotpCode\"]>> {\n    this._ensurePersistentTokenStore();\n    const session = await this._getSession();\n    let result;\n    try {\n      result = await this._catchMfaRequiredError(async () => {\n        return await this._interface.signInWithCredential(options.email, options.password, session);\n      });\n    } catch (e) {\n      if (KnownErrors.InvalidTotpCode.isInstance(e)) {\n        return Result.error(e);\n      }\n      throw e;\n    }\n\n    if (result.status === 'ok') {\n      await this._signInToAccountWithTokens(result.data);\n      if (!options.noRedirect) {\n        await this.redirectToAfterSignIn({ replace: true });\n      }\n      return Result.ok(undefined);\n    } else {\n      return Result.error(result.error);\n    }\n  }\n\n  async signUpWithCredential(options: {\n    email: string,\n    password: string,\n    noRedirect?: boolean,\n    noVerificationCallback?: boolean,\n    verificationCallbackUrl?: string,\n  }): Promise<Result<undefined, KnownErrors[\"UserWithEmailAlreadyExists\"] | KnownErrors['PasswordRequirementsNotMet']>> {\n    if (options.noVerificationCallback && options.verificationCallbackUrl) {\n      throw new StackAssertionError(\"verificationCallbackUrl is not allowed when noVerificationCallback is true\");\n    }\n    this._ensurePersistentTokenStore();\n    const session = await this._getSession();\n    const emailVerificationRedirectUrl = options.noVerificationCallback ? undefined : options.verificationCallbackUrl ?? constructRedirectUrl(this.urls.emailVerification, \"verificationCallbackUrl\");\n\n    let result = await this._interface.signUpWithCredential(\n      options.email,\n      options.password,\n      emailVerificationRedirectUrl,\n      session\n    );\n\n    // If the redirect URL is not whitelisted and we didn't explicitly opt out of verification,\n    // retry with undefined (no email verification) and log a warning\n    if (result.status === 'error' &&\n      result.error instanceof KnownErrors.RedirectUrlNotWhitelisted &&\n      !options.noVerificationCallback &&\n      emailVerificationRedirectUrl !== undefined) {\n      console.error(\"Warning: The verification callback URL is not trusted. Proceeding with signup without email verification. Please add your domain to the trusted domains list in your Stack Auth dashboard.\", { url: emailVerificationRedirectUrl });\n\n      result = await this._interface.signUpWithCredential(\n        options.email,\n        options.password,\n        undefined, // No email verification\n        session\n      );\n    }\n\n    if (result.status === 'ok') {\n      await this._signInToAccountWithTokens(result.data);\n      if (!options.noRedirect) {\n        await this.redirectToAfterSignUp({ replace: true });\n      }\n      return Result.ok(undefined);\n    } else {\n      return Result.error(result.error);\n    }\n  }\n\n  async _signUpAnonymously() {\n    this._ensurePersistentTokenStore();\n\n    if (!this._anonymousSignUpInProgress) {\n      this._anonymousSignUpInProgress = (async () => {\n        this._ensurePersistentTokenStore();\n        const session = await this._getSession();\n        const result = await this._interface.signUpAnonymously(session);\n        if (result.status === \"ok\") {\n          await this._signInToAccountWithTokens(result.data);\n        } else {\n          throw new StackAssertionError(\"signUpAnonymously() should never return an error\");\n        }\n        this._anonymousSignUpInProgress = null;\n        return result.data;\n      })();\n    }\n\n    return await this._anonymousSignUpInProgress;\n  }\n\n  async signInWithMagicLink(code: string, options?: { noRedirect?: boolean }): Promise<Result<undefined, KnownErrors[\"VerificationCodeError\"] | KnownErrors[\"InvalidTotpCode\"]>> {\n    this._ensurePersistentTokenStore();\n    const session = await this._getSession();\n    let result;\n    try {\n      result = await this._catchMfaRequiredError(async () => {\n        return await this._interface.signInWithMagicLink(code, session);\n      });\n    } catch (e) {\n      if (KnownErrors.InvalidTotpCode.isInstance(e)) {\n        return Result.error(e);\n      }\n      throw e;\n    }\n\n    if (result.status === 'ok') {\n      await this._signInToAccountWithTokens(result.data);\n      if (!(options?.noRedirect)) {\n        if (result.data.newUser) {\n          await this.redirectToAfterSignUp({ replace: true });\n        } else {\n          await this.redirectToAfterSignIn({ replace: true });\n        }\n      }\n      return Result.ok(undefined);\n    } else {\n      return Result.error(result.error);\n    }\n  }\n\n  /**\n   * Initiates a CLI authentication process that allows a command line application\n   * to get a refresh token for a user's account.\n   *\n   * This process works as follows:\n   * 1. The CLI app calls this method, which initiates the auth process with the server\n   * 2. The server returns a polling code and a login code\n   * 3. The CLI app opens a browser window to the appUrl with the login code as a parameter\n   * 4. The user logs in through the browser and confirms the authorization\n   * 5. The CLI app polls for the refresh token using the polling code\n   *\n   * @param options Options for the CLI login\n   * @param options.appUrl The URL of the app that will handle the CLI auth confirmation\n   * @param options.expiresInMillis Optional duration in milliseconds before the auth attempt expires (default: 2 hours)\n   * @param options.maxAttempts Optional maximum number of polling attempts (default: Infinity)\n   * @param options.waitTimeMillis Optional time to wait between polling attempts (default: 2 seconds)\n   * @param options.promptLink Optional function to call with the login URL to prompt the user to open the browser\n   * @returns Result containing either the refresh token or an error\n   */\n  async promptCliLogin(options: {\n    appUrl: string,\n    expiresInMillis?: number,\n    maxAttempts?: number,\n    waitTimeMillis?: number,\n    promptLink?: (url: string) => void,\n  }): Promise<Result<string, KnownErrors[\"CliAuthError\"] | KnownErrors[\"CliAuthExpiredError\"] | KnownErrors[\"CliAuthUsedError\"]>> {\n    // Step 1: Initiate the CLI auth process\n    const response = await this._interface.sendClientRequest(\n      \"/auth/cli\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          expires_in_millis: options.expiresInMillis,\n        }),\n      },\n      null\n    );\n\n    if (!response.ok) {\n      return Result.error(new KnownErrors.CliAuthError(`Failed to initiate CLI auth: ${response.status} ${await response.text()}`));\n    }\n\n    const initResult = await response.json();\n    const pollingCode = initResult.polling_code;\n    const loginCode = initResult.login_code;\n\n    // Step 2: Open the browser for the user to authenticate\n    const url = `${options.appUrl}/handler/cli-auth-confirm?login_code=${encodeURIComponent(loginCode)}`;\n    if (options.promptLink) {\n      options.promptLink(url);\n    } else {\n      console.log(`Please visit the following URL to authenticate:\\n${url}`);\n    }\n\n\n    // Step 3: Poll for the token\n    let attempts = 0;\n    while (attempts < (options.maxAttempts ?? Infinity)) {\n      attempts++;\n      const pollResponse = await this._interface.sendClientRequest(\"/auth/cli/poll\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          polling_code: pollingCode,\n        }),\n      }, null);\n\n      if (!pollResponse.ok) {\n        return Result.error(new KnownErrors.CliAuthError(`Failed to initiate CLI auth: ${pollResponse.status} ${await pollResponse.text()}`));\n      }\n      const pollResult = await pollResponse.json();\n\n      if (pollResponse.status === 201 && pollResult.status === \"success\") {\n        return Result.ok(pollResult.refresh_token);\n      }\n      if (pollResult.status === \"waiting\") {\n        await wait(options.waitTimeMillis ?? 2000);\n        continue;\n      }\n      if (pollResult.status === \"expired\") {\n        return Result.error(new KnownErrors.CliAuthExpiredError(\"CLI authentication request expired. Please try again.\"));\n      }\n      if (pollResult.status === \"used\") {\n        return Result.error(new KnownErrors.CliAuthUsedError(\"This authentication token has already been used.\"));\n      }\n      return Result.error(new KnownErrors.CliAuthError(`Unexpected status from CLI auth polling: ${pollResult.status}`));\n    }\n\n    return Result.error(new KnownErrors.CliAuthError(\"Timed out waiting for CLI authentication.\"));\n  }\n\n  /*\n   * Completes the MFA sign-in process by verifying the provided OTP code\n   * @param totp The TOTP (Time-based One-Time Password) provided by the user\n   * @param code The Attempt code provided by the user\n   * @param options Additional options for the sign-in process\n   * @returns A Result indicating success or failure\n   */\n  async signInWithMfa(totp: string, code: string, options?: { noRedirect?: boolean }): Promise<Result<undefined, KnownErrors[\"VerificationCodeError\"] | KnownErrors[\"InvalidTotpCode\"]>> {\n    this._ensurePersistentTokenStore();\n    const session = await this._getSession();\n    let result;\n    try {\n      result = await this._catchMfaRequiredError(async () => {\n        return await this._interface.signInWithMfa(totp, code, session);\n      });\n    } catch (e) {\n      if (e instanceof KnownErrors.InvalidTotpCode) {\n        return Result.error(e);\n      }\n      throw e;\n    }\n\n    if (result.status === 'ok') {\n      await this._signInToAccountWithTokens(result.data);\n      if (!(options?.noRedirect)) {\n        if (result.data.newUser) {\n          await this.redirectToAfterSignUp({ replace: true });\n        } else {\n          await this.redirectToAfterSignIn({ replace: true });\n        }\n      }\n      return Result.ok(undefined);\n    }\n    return Result.error(result.error);\n  }\n\n  async signInWithPasskey(): Promise<Result<undefined, KnownErrors[\"PasskeyAuthenticationFailed\"] | KnownErrors[\"InvalidTotpCode\"] | KnownErrors[\"PasskeyWebAuthnError\"]>> {\n    this._ensurePersistentTokenStore();\n    const session = await this._getSession();\n    let result;\n    try {\n      result = await this._catchMfaRequiredError(async () => {\n        const initiationResult = await this._interface.initiatePasskeyAuthentication({}, session);\n        if (initiationResult.status !== \"ok\") {\n          return Result.error(new KnownErrors.PasskeyAuthenticationFailed(\"Failed to get initiation options for passkey authentication\"));\n        }\n\n        const { options_json, code } = initiationResult.data;\n\n        // HACK: Override the rpID to be the actual domain\n        if (options_json.rpId !== \"THIS_VALUE_WILL_BE_REPLACED.example.com\") {\n          throw new StackAssertionError(`Expected returned RP ID from server to equal sentinel, but found ${options_json.rpId}`);\n        }\n        options_json.rpId = window.location.hostname;\n\n        const authentication_response = await startAuthentication({ optionsJSON: options_json });\n        return await this._interface.signInWithPasskey({ authentication_response, code }, session);\n      });\n    } catch (error) {\n      if (error instanceof WebAuthnError) {\n        return Result.error(new KnownErrors.PasskeyWebAuthnError(error.message, error.name));\n      } else {\n        // This should never happen\n        return Result.error(new KnownErrors.PasskeyAuthenticationFailed(\"Failed to sign in with passkey\"));\n      }\n    }\n\n    if (result.status === 'ok') {\n      await this._signInToAccountWithTokens(result.data);\n      await this.redirectToAfterSignIn({ replace: true });\n      return Result.ok(undefined);\n    } else {\n      return Result.error(result.error);\n    }\n  }\n\n\n  async callOAuthCallback() {\n    if (typeof window === \"undefined\") {\n      throw new Error(\"callOAuthCallback can currently only be called in a browser environment\");\n    }\n    this._ensurePersistentTokenStore();\n    let result;\n    try {\n      result = await this._catchMfaRequiredError(async () => {\n        return await callOAuthCallback(this._interface, this.urls.oauthCallback);\n      });\n    } catch (e) {\n      if (KnownErrors.InvalidTotpCode.isInstance(e)) {\n        alert(\"Invalid TOTP code. Please try signing in again.\");\n        return false;\n      } else {\n        throw e;\n      }\n    }\n    if (result.status === 'ok' && result.data) {\n      await this._signInToAccountWithTokens(result.data);\n      // TODO fix afterCallbackRedirectUrl for MFA (currently not passed because /mfa/sign-in doesn't return it)\n      // or just get rid of afterCallbackRedirectUrl entirely tbh\n      if (\"afterCallbackRedirectUrl\" in result.data && result.data.afterCallbackRedirectUrl) {\n        await this._redirectTo({ url: result.data.afterCallbackRedirectUrl, replace: true });\n        return true;\n      } else if (result.data.newUser) {\n        await this.redirectToAfterSignUp({ replace: true });\n        return true;\n      } else {\n        await this.redirectToAfterSignIn({ replace: true });\n        return true;\n      }\n    }\n    return false;\n  }\n\n  protected async _signOut(session: InternalSession, options?: { redirectUrl?: URL | string }): Promise<void> {\n    await storeLock.withWriteLock(async () => {\n      await this._interface.signOut(session);\n      if (options?.redirectUrl) {\n        await this._redirectTo({ url: options.redirectUrl, replace: true });\n      } else {\n        await this.redirectToAfterSignOut();\n      }\n    });\n  }\n\n  async signOut(options?: { redirectUrl?: URL | string, tokenStore?: TokenStoreInit }): Promise<void> {\n    const user = await this.getUser({ tokenStore: options?.tokenStore ?? undefined as any });\n    if (user) {\n      await user.signOut({ redirectUrl: options?.redirectUrl });\n    }\n  }\n\n  async getAuthHeaders(options?: { tokenStore?: TokenStoreInit }): Promise<{ \"x-stack-auth\": string }> {\n    return {\n      \"x-stack-auth\": JSON.stringify(await this.getAuthJson(options)),\n    };\n  }\n\n  async getAuthJson(options?: { tokenStore?: TokenStoreInit }): Promise<{ accessToken: string | null, refreshToken: string | null }> {\n    const user = await this.getUser({ tokenStore: options?.tokenStore ?? undefined as any });\n    if (user) {\n      return await user.getAuthJson();\n    }\n    return { accessToken: null, refreshToken: null };\n  }\n\n  async getProject(): Promise<Project> {\n    const crud = Result.orThrow(await this._currentProjectCache.getOrWait([], \"write-only\"));\n    return this._clientProjectFromCrud(crud);\n  }\n\n  useProject(): Project {\n    const crud = useAsyncCache(this._currentProjectCache, [], \"clientApp.useProject()\");\n    return useMemo(() => this._clientProjectFromCrud(crud), [crud]);\n  }\n\n  protected async _listOwnedProjects(session: InternalSession): Promise<AdminOwnedProject[]> {\n    this._ensureInternalProject();\n    const crud = Result.orThrow(await this._ownedProjectsCache.getOrWait([session], \"write-only\"));\n    return crud.map((j) => this._getOwnedAdminApp(j.id, session)._adminOwnedProjectFromCrud(\n      j,\n      () => this._refreshOwnedProjects(session),\n    ));\n  }\n\n  protected _useOwnedProjects(session: InternalSession): AdminOwnedProject[] {\n    this._ensureInternalProject();\n    const projects = useAsyncCache(this._ownedProjectsCache, [session], \"clientApp.useOwnedProjects()\");\n    return useMemo(() => projects.map((j) => this._getOwnedAdminApp(j.id, session)._adminOwnedProjectFromCrud(\n      j,\n      () => this._refreshOwnedProjects(session),\n    )), [projects]);\n  }\n  protected async _createProject(session: InternalSession, newProject: AdminProjectUpdateOptions & { displayName: string, teamId: string }): Promise<AdminOwnedProject> {\n    this._ensureInternalProject();\n    const crud = await this._interface.createProject(adminProjectCreateOptionsToCrud(newProject), session);\n    const res = this._getOwnedAdminApp(crud.id, session)._adminOwnedProjectFromCrud(\n      crud,\n      () => this._refreshOwnedProjects(session),\n    );\n    await this._refreshOwnedProjects(session);\n    return res;\n  }\n\n  protected async _refreshUser(session: InternalSession) {\n    // TODO this should take a user ID instead of a session, and automatically refresh all sessions with that user ID\n    await this._refreshSession(session);\n  }\n\n  protected async _refreshSession(session: InternalSession) {\n    await this._currentUserCache.refresh([session]);\n  }\n\n  protected async _refreshUsers() {\n    // nothing yet\n  }\n\n  protected async _refreshProject() {\n    await this._currentProjectCache.refresh([]);\n  }\n\n  protected async _refreshOwnedProjects(session: InternalSession) {\n    await this._ownedProjectsCache.refresh([session]);\n  }\n\n  static get [stackAppInternalsSymbol]() {\n    return {\n      fromClientJson: <HasTokenStore extends boolean, ProjectId extends string>(\n        json: StackClientAppJson<HasTokenStore, ProjectId>\n      ): StackClientApp<HasTokenStore, ProjectId> => {\n        const providedCheckString = JSON.stringify(omit(json, [/* none currently */]));\n        const existing = allClientApps.get(json.uniqueIdentifier);\n        if (existing) {\n          const [existingCheckString, clientApp] = existing;\n          if (existingCheckString !== undefined && existingCheckString !== providedCheckString) {\n            throw new StackAssertionError(\"The provided app JSON does not match the configuration of the existing client app with the same unique identifier\", { providedObj: json, existingString: existingCheckString });\n          }\n          return clientApp as any;\n        }\n\n        return new _StackClientAppImplIncomplete<HasTokenStore, ProjectId>({\n          ...omit(json, [\"uniqueIdentifier\"]) as any,\n        }, {\n          uniqueIdentifier: json.uniqueIdentifier,\n          checkString: providedCheckString,\n        });\n      }\n    };\n  }\n\n  get [stackAppInternalsSymbol]() {\n    return {\n      toClientJson: (): StackClientAppJson<HasTokenStore, ProjectId> => {\n        if (!(\"publishableClientKey\" in this._interface.options)) {\n          // TODO find a way to do this\n          throw new StackAssertionError(\"Cannot serialize to JSON from an application without a publishable client key\");\n        }\n\n        if (typeof this._redirectMethod !== \"string\") {\n          throw new StackAssertionError(\"Cannot serialize to JSON from an application with a non-string redirect method\");\n        }\n\n        return {\n          baseUrl: this._options.baseUrl,\n          projectId: this.projectId,\n          publishableClientKey: this._interface.options.publishableClientKey,\n          tokenStore: this._tokenStoreInit,\n          urls: this._urlOptions,\n          oauthScopesOnSignIn: this._oauthScopesOnSignIn,\n          uniqueIdentifier: this._getUniqueIdentifier(),\n          redirectMethod: this._redirectMethod,\n          extraRequestHeaders: this._options.extraRequestHeaders,\n        };\n      },\n      setCurrentUser: (userJsonPromise: Promise<CurrentUserCrud['Client']['Read'] | null>) => {\n        runAsynchronously(async () => {\n          await this._currentUserCache.forceSetCachedValueAsync([await this._getSession()], Result.fromPromise(userJsonPromise));\n        });\n      },\n      getConstructorOptions: () => this._options,\n      sendRequest: async (\n        path: string,\n        requestOptions: RequestInit,\n        requestType: \"client\" | \"server\" | \"admin\" = \"client\",\n      ) => {\n        return await this._interface.sendClientRequest(path, requestOptions, await this._getSession(), requestType);\n      },\n    };\n  };\n}\n"],"names":["isReactServer","cookies","value","parsed","crud","response","tokens"],"mappings":"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"}},
    {"offset": {"line": 3476, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack/src/lib/stack-app/apps/implementations/server-app-impl.ts"],"sourcesContent":["\n//===========================================\n// THIS FILE IS AUTO-GENERATED FROM TEMPLATE. DO NOT EDIT IT DIRECTLY\n//===========================================\nimport { KnownErrors, StackServerInterface } from \"@stackframe/stack-shared\";\nimport { ContactChannelsCrud } from \"@stackframe/stack-shared/dist/interface/crud/contact-channels\";\nimport { ItemCrud } from \"@stackframe/stack-shared/dist/interface/crud/items\";\nimport { NotificationPreferenceCrud } from \"@stackframe/stack-shared/dist/interface/crud/notification-preferences\";\nimport { OAuthProviderCrud } from \"@stackframe/stack-shared/dist/interface/crud/oauth-providers\";\nimport type { CustomerProductsListResponse } from \"@stackframe/stack-shared/dist/interface/crud/products\";\nimport { TeamApiKeysCrud, UserApiKeysCrud, teamApiKeysCreateOutputSchema, userApiKeysCreateOutputSchema } from \"@stackframe/stack-shared/dist/interface/crud/project-api-keys\";\nimport { ProjectPermissionDefinitionsCrud, ProjectPermissionsCrud } from \"@stackframe/stack-shared/dist/interface/crud/project-permissions\";\nimport { TeamInvitationCrud } from \"@stackframe/stack-shared/dist/interface/crud/team-invitation\";\nimport { TeamMemberProfilesCrud } from \"@stackframe/stack-shared/dist/interface/crud/team-member-profiles\";\nimport { TeamPermissionDefinitionsCrud, TeamPermissionsCrud } from \"@stackframe/stack-shared/dist/interface/crud/team-permissions\";\nimport { TeamsCrud } from \"@stackframe/stack-shared/dist/interface/crud/teams\";\nimport { UsersCrud } from \"@stackframe/stack-shared/dist/interface/crud/users\";\nimport { InternalSession } from \"@stackframe/stack-shared/dist/sessions\";\nimport type { AsyncCache } from \"@stackframe/stack-shared/dist/utils/caches\";\nimport { captureError, StackAssertionError, throwErr } from \"@stackframe/stack-shared/dist/utils/errors\";\nimport { ProviderType } from \"@stackframe/stack-shared/dist/utils/oauth\";\nimport { runAsynchronously } from \"@stackframe/stack-shared/dist/utils/promises\";\nimport { suspend } from \"@stackframe/stack-shared/dist/utils/react\";\nimport { Result } from \"@stackframe/stack-shared/dist/utils/results\";\nimport { useMemo } from \"react\"; // THIS_LINE_PLATFORM react-like\nimport * as yup from \"yup\";\nimport { constructRedirectUrl } from \"../../../../utils/url\";\nimport { ApiKey, ApiKeyCreationOptions, ApiKeyUpdateOptions, apiKeyCreationOptionsToCrud, apiKeyUpdateOptionsToCrud } from \"../../api-keys\";\nimport { ConvexCtx, GetCurrentUserOptions } from \"../../common\";\nimport { OAuthConnection } from \"../../connected-accounts\";\nimport { ServerContactChannel, ServerContactChannelCreateOptions, ServerContactChannelUpdateOptions, serverContactChannelCreateOptionsToCrud, serverContactChannelUpdateOptionsToCrud } from \"../../contact-channels\";\nimport { Customer, InlineProduct, ServerItem } from \"../../customers\";\nimport { DataVaultStore } from \"../../data-vault\";\nimport { SendEmailOptions } from \"../../email\";\nimport { NotificationCategory } from \"../../notification-categories\";\nimport { AdminProjectPermissionDefinition, AdminTeamPermission, AdminTeamPermissionDefinition } from \"../../permissions\";\nimport { EditableTeamMemberProfile, ServerListUsersOptions, ServerTeam, ServerTeamCreateOptions, ServerTeamUpdateOptions, ServerTeamUser, Team, TeamInvitation, serverTeamCreateOptionsToCrud, serverTeamUpdateOptionsToCrud } from \"../../teams\";\nimport { ProjectCurrentServerUser, ServerOAuthProvider, ServerUser, ServerUserCreateOptions, ServerUserUpdateOptions, attachUserDestructureGuard, serverUserCreateOptionsToCrud, serverUserUpdateOptionsToCrud } from \"../../users\";\nimport { StackServerAppConstructorOptions } from \"../interfaces/server-app\";\nimport { _StackClientAppImplIncomplete } from \"./client-app-impl\";\nimport { clientVersion, createCache, createCacheBySession, getBaseUrl, getDefaultExtraRequestHeaders, getDefaultProjectId, getDefaultPublishableClientKey, getDefaultSecretServerKey, resolveConstructorOptions } from \"./common\";\nimport { startRegistration, WebAuthnError } from \"@simplewebauthn/browser\";\n\nimport { useAsyncCache } from \"./common\"; // THIS_LINE_PLATFORM react-like\n\nexport class _StackServerAppImplIncomplete<HasTokenStore extends boolean, ProjectId extends string> extends _StackClientAppImplIncomplete<HasTokenStore, ProjectId> {\n  declare protected _interface: StackServerInterface;\n\n  // TODO override the client user cache to use the server user cache, so we save some requests\n  private readonly _currentServerUserCache = createCacheBySession(async (session) => {\n    if (session.isKnownToBeInvalid()) {\n      // see comment in _currentUserCache for more details on why we do this\n      return null;\n    }\n    return await this._interface.getServerUserByToken(session);\n  });\n  private readonly _serverUsersCache = createCache<[\n    cursor?: string,\n    limit?: number,\n    orderBy?: 'signedUpAt',\n    desc?: boolean,\n    query?: string,\n    includeAnonymous?: boolean,\n  ], UsersCrud['Server']['List']>(async ([cursor, limit, orderBy, desc, query, includeAnonymous]) => {\n    return await this._interface.listServerUsers({ cursor, limit, orderBy, desc, query, includeAnonymous });\n  });\n  private readonly _serverUserCache = createCache<string[], UsersCrud['Server']['Read'] | null>(async ([userId]) => {\n    const user = await this._interface.getServerUserById(userId);\n    return Result.or(user, null);\n  });\n  private readonly _serverTeamsCache = createCache<[string | undefined], TeamsCrud['Server']['Read'][]>(async ([userId]) => {\n    return await this._interface.listServerTeams({ userId });\n  });\n  private readonly _serverTeamUserPermissionsCache = createCache<\n    [string, string, boolean],\n    TeamPermissionsCrud['Server']['Read'][]\n  >(async ([teamId, userId, recursive]) => {\n    return await this._interface.listServerTeamPermissions({ teamId, userId, recursive }, null);\n  });\n  private readonly _serverUserProjectPermissionsCache = createCache<\n    [string, boolean],\n    ProjectPermissionsCrud['Server']['Read'][]\n  >(async ([userId, recursive]) => {\n    return await this._interface.listServerProjectPermissions({ userId, recursive }, null);\n  });\n  private readonly _serverUserOAuthConnectionAccessTokensCache = createCache<[string, string, string], { accessToken: string } | null>(\n    async ([userId, providerId, scope]) => {\n      try {\n        const result = await this._interface.createServerProviderAccessToken(userId, providerId, scope || \"\");\n        return { accessToken: result.access_token };\n      } catch (err) {\n        if (!(KnownErrors.OAuthConnectionDoesNotHaveRequiredScope.isInstance(err) || KnownErrors.OAuthConnectionNotConnectedToUser.isInstance(err))) {\n          throw err;\n        }\n      }\n      return null;\n    }\n  );\n  private readonly _serverUserOAuthConnectionCache = createCache<[string, ProviderType, string, boolean], OAuthConnection | null>(\n    async ([userId, providerId, scope, redirect]) => {\n      return await this._getUserOAuthConnectionCacheFn({\n        getUser: async () => Result.orThrow(await this._serverUserCache.getOrWait([userId], \"write-only\")),\n        getOrWaitOAuthToken: async () => Result.orThrow(await this._serverUserOAuthConnectionAccessTokensCache.getOrWait([userId, providerId, scope || \"\"] as const, \"write-only\")),\n        useOAuthToken: () => useAsyncCache(this._serverUserOAuthConnectionAccessTokensCache, [userId, providerId, scope || \"\"] as const, \"user.useConnectedAccount()\"),\n        providerId,\n        scope,\n        redirect,\n        session: null,\n      });\n    }\n  );\n  private readonly _serverTeamMemberProfilesCache = createCache<[string], TeamMemberProfilesCrud['Server']['Read'][]>(\n    async ([teamId]) => {\n      return await this._interface.listServerTeamMemberProfiles({ teamId });\n    }\n  );\n  private readonly _serverTeamInvitationsCache = createCache<[string], TeamInvitationCrud['Server']['Read'][]>(\n    async ([teamId]) => {\n      return await this._interface.listServerTeamInvitations({ teamId });\n    }\n  );\n  private readonly _serverUserTeamProfileCache = createCache<[string, string], TeamMemberProfilesCrud['Client']['Read']>(\n    async ([teamId, userId]) => {\n      return await this._interface.getServerTeamMemberProfile({ teamId, userId });\n    }\n  );\n  private readonly _serverContactChannelsCache = createCache<[string], ContactChannelsCrud['Server']['Read'][]>(\n    async ([userId]) => {\n      return await this._interface.listServerContactChannels(userId);\n    }\n  );\n  private readonly _serverNotificationCategoriesCache = createCache<[string], NotificationPreferenceCrud['Server']['Read'][]>(\n    async ([userId]) => {\n      return await this._interface.listServerNotificationCategories(userId);\n    }\n  );\n  private readonly _serverDataVaultStoreValueCache = createCache<[string, string, string], string | null>(async ([storeId, key, secret]) => {\n    return await this._interface.getDataVaultStoreValue(secret, storeId, key);\n  });\n\n  private readonly _serverUserApiKeysCache = createCache<[string], UserApiKeysCrud['Server']['Read'][]>(\n    async ([userId]) => {\n      const result = await this._interface.listProjectApiKeys({\n        user_id: userId,\n      }, null, \"server\");\n      return result as UserApiKeysCrud['Server']['Read'][];\n    }\n  );\n\n  private readonly _serverTeamApiKeysCache = createCache<[string], TeamApiKeysCrud['Server']['Read'][]>(\n    async ([teamId]) => {\n      const result = await this._interface.listProjectApiKeys({\n        team_id: teamId,\n      }, null, \"server\");\n      return result as TeamApiKeysCrud['Server']['Read'][];\n    }\n  );\n\n  private readonly _convexIdentitySubjectCache = createCache<[ConvexCtx], string | null>(\n    async ([ctx]) => {\n      const identity = await ctx.auth.getUserIdentity();\n      return identity ? identity.subject : null;\n    }\n  );\n\n  private readonly _serverCheckApiKeyCache = createCache<[\"user\" | \"team\", string], UserApiKeysCrud['Server']['Read'] | TeamApiKeysCrud['Server']['Read'] | null>(async ([type, apiKey]) => {\n    const result = await this._interface.checkProjectApiKey(\n      type,\n      apiKey,\n      null,\n      \"server\",\n    );\n    return result;\n  });\n\n  private readonly _serverOAuthProvidersCache = createCache<[string], OAuthProviderCrud['Server']['Read'][]>(\n    async ([userId]) => {\n      return await this._interface.listServerOAuthProviders({ user_id: userId });\n    }\n  );\n\n  private readonly _serverTeamItemsCache = createCache<[string, string], ItemCrud['Client']['Read']>(\n    async ([teamId, itemId]) => {\n      return await this._interface.getItem({ teamId, itemId }, null);\n    }\n  );\n\n  private readonly _serverUserItemsCache = createCache<[string, string], ItemCrud['Client']['Read']>(\n    async ([userId, itemId]) => {\n      return await this._interface.getItem({ userId, itemId }, null);\n    }\n  );\n\n  private readonly _serverCustomItemsCache = createCache<[string, string], ItemCrud['Client']['Read']>(\n    async ([customCustomerId, itemId]) => {\n      return await this._interface.getItem({ customCustomerId, itemId }, null);\n    }\n  );\n\n  private readonly _serverUserProductsCache = createCache<[string, string | null, number | null], CustomerProductsListResponse>(\n    async ([userId, cursor, limit]) => {\n      return await this._interface.listProducts({\n        customer_type: \"user\",\n        customer_id: userId,\n        cursor: cursor ?? undefined,\n        limit: limit ?? undefined,\n      }, null);\n    }\n  );\n\n  private readonly _serverTeamProductsCache = createCache<[string, string | null, number | null], CustomerProductsListResponse>(\n    async ([teamId, cursor, limit]) => {\n      return await this._interface.listProducts({\n        customer_type: \"team\",\n        customer_id: teamId,\n        cursor: cursor ?? undefined,\n        limit: limit ?? undefined,\n      }, null);\n    }\n  );\n\n  private readonly _serverCustomProductsCache = createCache<[string, string | null, number | null], CustomerProductsListResponse>(\n    async ([customCustomerId, cursor, limit]) => {\n      return await this._interface.listProducts({\n        customer_type: \"custom\",\n        customer_id: customCustomerId,\n        cursor: cursor ?? undefined,\n        limit: limit ?? undefined,\n      }, null);\n    }\n  );\n\n  protected _createServerCustomer(userIdOrTeamId: string, type: \"user\" | \"team\"): Omit<Customer<true>, \"id\"> {\n    const app = this;\n    const productsCache = type === \"user\" ? app._serverUserProductsCache : app._serverTeamProductsCache;\n    const customerOptions = type === \"user\" ? { userId: userIdOrTeamId } : { teamId: userIdOrTeamId };\n    return {\n      ...this._createCustomer(userIdOrTeamId, type, null),\n      async getItem(itemId: string) {\n        return await app.getItem({ itemId, ...customerOptions });\n      },\n      useItem(itemId: string) {\n        return app.useItem({ itemId, ...customerOptions });\n      },\n      async grantProduct(productOptions: { productId: string, quantity?: number } | { product: InlineProduct, quantity?: number }) {\n        if (type === \"user\") {\n          if (\"productId\" in productOptions) {\n            await app.grantProduct({ userId: userIdOrTeamId, productId: productOptions.productId, quantity: productOptions.quantity });\n          } else {\n            await app.grantProduct({ userId: userIdOrTeamId, product: productOptions.product, quantity: productOptions.quantity });\n          }\n        } else {\n          if (\"productId\" in productOptions) {\n            await app.grantProduct({ teamId: userIdOrTeamId, productId: productOptions.productId, quantity: productOptions.quantity });\n          } else {\n            await app.grantProduct({ teamId: userIdOrTeamId, product: productOptions.product, quantity: productOptions.quantity });\n          }\n        }\n        await productsCache.refresh([userIdOrTeamId, null, null]);\n      },\n      async createCheckoutUrl(options: { productId: string, returnUrl?: string } | { product: InlineProduct, returnUrl?: string }) {\n        const productIdOrInline = \"productId\" in options ? options.productId : options.product;\n        return await app._interface.createCheckoutUrl(type, userIdOrTeamId, productIdOrInline, null, options.returnUrl);\n      },\n    };\n  }\n\n  private async _updateServerUser(userId: string, update: ServerUserUpdateOptions): Promise<UsersCrud['Server']['Read']> {\n    const result = await this._interface.updateServerUser(userId, serverUserUpdateOptionsToCrud(update));\n    await this._refreshUsers();\n    return result;\n  }\n\n  protected _serverEditableTeamProfileFromCrud(crud: TeamMemberProfilesCrud['Client']['Read']): EditableTeamMemberProfile {\n    const app = this;\n    return {\n      displayName: crud.display_name,\n      profileImageUrl: crud.profile_image_url,\n      async update(update: { displayName?: string, profileImageUrl?: string }) {\n        await app._interface.updateServerTeamMemberProfile({\n          teamId: crud.team_id,\n          userId: crud.user_id,\n          profile: {\n            display_name: update.displayName,\n            profile_image_url: update.profileImageUrl,\n          },\n        });\n        await app._serverUserTeamProfileCache.refresh([crud.team_id, crud.user_id]);\n      }\n    };\n  }\n\n  protected _serverContactChannelFromCrud(userId: string, crud: ContactChannelsCrud['Server']['Read']): ServerContactChannel {\n    const app = this;\n    return {\n      id: crud.id,\n      value: crud.value,\n      type: crud.type,\n      isVerified: crud.is_verified,\n      isPrimary: crud.is_primary,\n      usedForAuth: crud.used_for_auth,\n      async sendVerificationEmail(options?: { callbackUrl?: string }) {\n        await app._interface.sendServerContactChannelVerificationEmail(userId, crud.id, options?.callbackUrl ?? constructRedirectUrl(app.urls.emailVerification, \"callbackUrl\"));\n      },\n      async update(data: ServerContactChannelUpdateOptions) {\n        await app._interface.updateServerContactChannel(userId, crud.id, serverContactChannelUpdateOptionsToCrud(data));\n        await Promise.all([\n          app._serverContactChannelsCache.refresh([userId]),\n          app._serverUserCache.refresh([userId])\n        ]);\n      },\n      async delete() {\n        await app._interface.deleteServerContactChannel(userId, crud.id);\n        await Promise.all([\n          app._serverContactChannelsCache.refresh([userId]),\n          app._serverUserCache.refresh([userId])\n        ]);\n      },\n    };\n  }\n\n  protected _serverNotificationCategoryFromCrud(userId: string, crud: NotificationPreferenceCrud['Server']['Read']): NotificationCategory {\n    const app = this;\n    return {\n      id: crud.notification_category_id,\n      name: crud.notification_category_name,\n      enabled: crud.enabled,\n      canDisable: crud.can_disable,\n\n      async setEnabled(enabled: boolean) {\n        await app._interface.setServerNotificationsEnabled(userId, crud.notification_category_id, enabled);\n        await app._serverNotificationCategoriesCache.refresh([userId]);\n      },\n    };\n  }\n\n  protected _serverOAuthProviderFromCrud(crud: OAuthProviderCrud['Server']['Read']) {\n    const app = this;\n    return {\n      id: crud.id,\n      type: crud.type,\n      userId: crud.user_id,\n      accountId: crud.account_id,\n      email: crud.email,\n      allowSignIn: crud.allow_sign_in,\n      allowConnectedAccounts: crud.allow_connected_accounts,\n\n      async update(data: { accountId?: string, email?: string, allowSignIn?: boolean, allowConnectedAccounts?: boolean }): Promise<Result<void,\n        InstanceType<typeof KnownErrors.OAuthProviderAccountIdAlreadyUsedForSignIn>\n      >> {\n        try {\n          await app._interface.updateServerOAuthProvider(crud.user_id, crud.id, {\n            account_id: data.accountId,\n            email: data.email,\n            allow_sign_in: data.allowSignIn,\n            allow_connected_accounts: data.allowConnectedAccounts,\n          });\n          await app._serverOAuthProvidersCache.refresh([crud.user_id]);\n          return Result.ok(undefined);\n        } catch (error) {\n          if (KnownErrors.OAuthProviderAccountIdAlreadyUsedForSignIn.isInstance(error)) {\n            return Result.error(error);\n          }\n          throw error;\n        }\n      },\n\n      async delete() {\n        await app._interface.deleteServerOAuthProvider(crud.user_id, crud.id);\n        await app._serverOAuthProvidersCache.refresh([crud.user_id]);\n      },\n    };\n  }\n\n  constructor(options: StackServerAppConstructorOptions<HasTokenStore, ProjectId>, extraOptions?: { uniqueIdentifier?: string, checkString?: string, interface?: StackServerInterface }) {\n    const resolvedOptions = resolveConstructorOptions(options);\n\n    super(resolvedOptions, {\n      ...extraOptions,\n      interface: extraOptions?.interface ?? new StackServerInterface({\n        getBaseUrl: () => getBaseUrl(resolvedOptions.baseUrl),\n        projectId: resolvedOptions.projectId ?? getDefaultProjectId(),\n        extraRequestHeaders: resolvedOptions.extraRequestHeaders ?? getDefaultExtraRequestHeaders(),\n        clientVersion,\n        publishableClientKey: resolvedOptions.publishableClientKey ?? getDefaultPublishableClientKey(),\n        secretServerKey: resolvedOptions.secretServerKey ?? getDefaultSecretServerKey(),\n      }),\n    });\n  }\n\n\n  protected _serverApiKeyFromCrud(crud: TeamApiKeysCrud['Client']['Read']): ApiKey<\"team\">;\n  protected _serverApiKeyFromCrud(crud: UserApiKeysCrud['Client']['Read']): ApiKey<\"user\">;\n  protected _serverApiKeyFromCrud(crud: yup.InferType<typeof teamApiKeysCreateOutputSchema>): ApiKey<\"team\", true>;\n  protected _serverApiKeyFromCrud(crud: yup.InferType<typeof userApiKeysCreateOutputSchema>): ApiKey<\"user\", true>;\n  protected _serverApiKeyFromCrud(crud: TeamApiKeysCrud['Client']['Read'] | UserApiKeysCrud['Client']['Read'] | yup.InferType<typeof teamApiKeysCreateOutputSchema> | yup.InferType<typeof userApiKeysCreateOutputSchema>): ApiKey<\"user\" | \"team\", boolean> {\n    return {\n      ...this._baseApiKeyFromCrud(crud),\n      async revoke() {\n        await this.update({ revoked: true });\n      },\n      update: async (options: ApiKeyUpdateOptions) => {\n        await this._interface.updateProjectApiKey(\n          crud.type === \"team\" ? { team_id: crud.team_id } : { user_id: crud.user_id },\n          crud.id,\n          await apiKeyUpdateOptionsToCrud(crud.type, options),\n          null,\n          \"server\");\n        if (crud.type === \"team\") {\n          await this._serverTeamApiKeysCache.refresh([crud.team_id]);\n        } else {\n          await this._serverUserApiKeysCache.refresh([crud.user_id]);\n        }\n      },\n    };\n  }\n\n  protected _serverUserFromCrud(crud: UsersCrud['Server']['Read']): ServerUser {\n    const app = this;\n\n    async function getConnectedAccount(id: ProviderType, options?: { scopes?: string[] }): Promise<OAuthConnection | null>;\n    async function getConnectedAccount(id: ProviderType, options: { or: 'redirect', scopes?: string[] }): Promise<OAuthConnection>;\n    async function getConnectedAccount(id: ProviderType, options?: { or?: 'redirect', scopes?: string[] }): Promise<OAuthConnection | null> {\n      const scopeString = options?.scopes?.join(\" \");\n      return Result.orThrow(await app._serverUserOAuthConnectionCache.getOrWait([crud.id, id, scopeString || \"\", options?.or === 'redirect'], \"write-only\"));\n    }\n\n    function useConnectedAccount(id: ProviderType, options?: { scopes?: string[] }): OAuthConnection | null;\n    function useConnectedAccount(id: ProviderType, options: { or: 'redirect', scopes?: string[] }): OAuthConnection;\n    function useConnectedAccount(id: ProviderType, options?: { or?: 'redirect', scopes?: string[] }): OAuthConnection | null {\n      const scopeString = options?.scopes?.join(\" \");\n      return useAsyncCache(app._serverUserOAuthConnectionCache, [crud.id, id, scopeString || \"\", options?.or === 'redirect'] as const, \"user.useConnectedAccount()\");\n    }\n\n    const serverUser = {\n      ...super._createBaseUser(crud),\n      lastActiveAt: new Date(crud.last_active_at_millis),\n      serverMetadata: crud.server_metadata,\n      async setPrimaryEmail(email: string | null, options?: { verified?: boolean }) {\n        await app._updateServerUser(crud.id, { primaryEmail: email, primaryEmailVerified: options?.verified });\n      },\n      async grantPermission(scopeOrPermissionId: Team | string, permissionId?: string): Promise<void> {\n        if (scopeOrPermissionId && typeof scopeOrPermissionId !== 'string' && permissionId) {\n          const scope = scopeOrPermissionId;\n          await app._interface.grantServerTeamUserPermission(scope.id, crud.id, permissionId);\n\n          for (const recursive of [true, false]) {\n            await app._serverTeamUserPermissionsCache.refresh([scope.id, crud.id, recursive]);\n          }\n        } else {\n          const pId = scopeOrPermissionId as string;\n          await app._interface.grantServerProjectPermission(crud.id, pId);\n\n          for (const recursive of [true, false]) {\n            await app._serverUserProjectPermissionsCache.refresh([crud.id, recursive]);\n          }\n        }\n      },\n      async revokePermission(scopeOrPermissionId: Team | string, permissionId?: string): Promise<void> {\n        if (scopeOrPermissionId && typeof scopeOrPermissionId !== 'string' && permissionId) {\n          const scope = scopeOrPermissionId;\n          await app._interface.revokeServerTeamUserPermission(scope.id, crud.id, permissionId);\n\n          for (const recursive of [true, false]) {\n            await app._serverTeamUserPermissionsCache.refresh([scope.id, crud.id, recursive]);\n          }\n        } else {\n          const pId = scopeOrPermissionId as string;\n          await app._interface.revokeServerProjectPermission(crud.id, pId);\n\n          for (const recursive of [true, false]) {\n            await app._serverUserProjectPermissionsCache.refresh([crud.id, recursive]);\n          }\n        }\n      },\n      async delete() {\n        const res = await app._interface.deleteServerUser(crud.id);\n        await app._refreshUsers();\n        return res;\n      },\n      async createSession(options: { expiresInMillis?: number, isImpersonation?: boolean }) {\n        // TODO this should also refresh the access token when it expires (like InternalSession)\n        const tokens = await app._interface.createServerUserSession(crud.id, options.expiresInMillis ?? 1000 * 60 * 60 * 24 * 365, options.isImpersonation ?? false);\n        return {\n          async getTokens() {\n            return tokens;\n          },\n        };\n      },\n\n      async getActiveSessions() {\n        const sessions = await app._interface.listServerSessions(crud.id);\n        return sessions.map((session) => app._clientSessionFromCrud(session));\n      },\n\n      async revokeSession(sessionId: string) {\n        await app._interface.deleteServerSession(sessionId);\n      },\n      async setDisplayName(displayName: string) {\n        return await this.update({ displayName });\n      },\n      async setClientMetadata(metadata: Record<string, any>) {\n        return await this.update({ clientMetadata: metadata });\n      },\n      async setClientReadOnlyMetadata(metadata: Record<string, any>) {\n        return await this.update({ clientReadOnlyMetadata: metadata });\n      },\n      async setServerMetadata(metadata: Record<string, any>) {\n        return await this.update({ serverMetadata: metadata });\n      },\n      async setSelectedTeam(team: Team | null) {\n        return await this.update({ selectedTeamId: team?.id ?? null });\n      },\n      getConnectedAccount,\n      useConnectedAccount, // THIS_LINE_PLATFORM react-like\n      selectedTeam: crud.selected_team ? app._serverTeamFromCrud(crud.selected_team) : null,\n      async getTeam(teamId: string) {\n        const teams = await this.listTeams();\n        return teams.find((t) => t.id === teamId) ?? null;\n      },\n      useTeam(teamId: string) {\n        const teams = this.useTeams();\n        return useMemo(() => {\n          return teams.find((t) => t.id === teamId) ?? null;\n        }, [teams, teamId]);\n      },\n      async listTeams() {\n        const teams = Result.orThrow(await app._serverTeamsCache.getOrWait([crud.id], \"write-only\"));\n        return teams.map((t) => app._serverTeamFromCrud(t));\n      },\n      useTeams() {\n        const teams = useAsyncCache(app._serverTeamsCache, [crud.id], \"user.useTeams()\");\n        return useMemo(() => teams.map((t) => app._serverTeamFromCrud(t)), [teams]);\n      },\n      createTeam: async (data: Omit<ServerTeamCreateOptions, \"creatorUserId\">) => {\n        const team = await app._interface.createServerTeam(serverTeamCreateOptionsToCrud({\n          creatorUserId: crud.id,\n          ...data,\n        }));\n        await app._serverTeamsCache.refresh([undefined]);\n        await app._updateServerUser(crud.id, { selectedTeamId: team.id });\n        return app._serverTeamFromCrud(team);\n      },\n      leaveTeam: async (team: Team) => {\n        await app._interface.leaveServerTeam({ teamId: team.id, userId: crud.id });\n        // TODO: refresh cache\n      },\n      async listPermissions(scopeOrOptions?: Team | { recursive?: boolean }, options?: { recursive?: boolean }): Promise<AdminTeamPermission[]> {\n        if (scopeOrOptions && 'id' in scopeOrOptions) {\n          const scope = scopeOrOptions;\n          const recursive = options?.recursive ?? true;\n          const permissions = Result.orThrow(await app._serverTeamUserPermissionsCache.getOrWait([scope.id, crud.id, recursive], \"write-only\"));\n          return permissions.map((crud) => app._serverPermissionFromCrud(crud));\n        } else {\n          const opts = scopeOrOptions;\n          const recursive = opts?.recursive ?? true;\n          const permissions = Result.orThrow(await app._serverUserProjectPermissionsCache.getOrWait([crud.id, recursive], \"write-only\"));\n          return permissions.map((crud) => app._serverPermissionFromCrud(crud));\n        }\n      },\n      usePermissions(scopeOrOptions?: Team | { recursive?: boolean }, options?: { recursive?: boolean }): AdminTeamPermission[] {\n        if (scopeOrOptions && 'id' in scopeOrOptions) {\n          const scope = scopeOrOptions;\n          const recursive = options?.recursive ?? true;\n          const permissions = useAsyncCache(app._serverTeamUserPermissionsCache, [scope.id, crud.id, recursive] as const, \"user.usePermissions()\");\n          return useMemo(() => permissions.map((crud) => app._serverPermissionFromCrud(crud)), [permissions]);\n        } else {\n          const opts = scopeOrOptions;\n          const recursive = opts?.recursive ?? true;\n          const permissions = useAsyncCache(app._serverUserProjectPermissionsCache, [crud.id, recursive] as const, \"user.usePermissions()\");\n          return useMemo(() => permissions.map((crud) => app._serverPermissionFromCrud(crud)), [permissions]);\n        }\n      },\n      async getPermission(scopeOrPermissionId: Team | string, permissionId?: string): Promise<AdminTeamPermission | null> {\n        if (scopeOrPermissionId && typeof scopeOrPermissionId !== 'string') {\n          const scope = scopeOrPermissionId;\n          const permissions = await this.listPermissions(scope);\n          return permissions.find((p) => p.id === permissionId) ?? null;\n        } else {\n          const pid = scopeOrPermissionId;\n          const permissions = await this.listPermissions();\n          return permissions.find((p) => p.id === pid) ?? null;\n        }\n      },\n      usePermission(scopeOrPermissionId: Team | string, permissionId?: string): AdminTeamPermission | null {\n        if (scopeOrPermissionId && typeof scopeOrPermissionId !== 'string') {\n          const scope = scopeOrPermissionId;\n          const permissions = this.usePermissions(scope);\n          return useMemo(() => permissions.find((p) => p.id === permissionId) ?? null, [permissions, permissionId]);\n        } else {\n          const pid = scopeOrPermissionId;\n          const permissions = this.usePermissions();\n          return useMemo(() => permissions.find((p) => p.id === pid) ?? null, [permissions, pid]);\n        }\n      },\n      async hasPermission(scopeOrPermissionId: Team | string, permissionId?: string): Promise<boolean> {\n        if (scopeOrPermissionId && typeof scopeOrPermissionId !== 'string') {\n          const scope = scopeOrPermissionId;\n          return (await this.getPermission(scope, permissionId as string)) !== null;\n        } else {\n          const pid = scopeOrPermissionId;\n          return (await this.getPermission(pid)) !== null;\n        }\n      },\n      async update(update: ServerUserUpdateOptions) {\n        await app._updateServerUser(crud.id, update);\n      },\n      async sendVerificationEmail() {\n        return await app._checkFeatureSupport(\"sendVerificationEmail() on ServerUser\", {});\n      },\n      async updatePassword(options: { oldPassword: string, newPassword: string }) {\n        const result = await app._interface.updatePassword(options);\n        await app._serverUserCache.refresh([crud.id]);\n        return result;\n      },\n      async setPassword(options: { password: string }) {\n        const result = await this.update(options);\n        await app._serverUserCache.refresh([crud.id]);\n        return result;\n      },\n      async getTeamProfile(team: Team) {\n        const result = Result.orThrow(await app._serverUserTeamProfileCache.getOrWait([team.id, crud.id], \"write-only\"));\n        return app._serverEditableTeamProfileFromCrud(result);\n      },\n      useTeamProfile(team: Team) {\n        const result = useAsyncCache(app._serverUserTeamProfileCache, [team.id, crud.id] as const, \"user.useTeamProfile()\");\n        return useMemo(() => app._serverEditableTeamProfileFromCrud(result), [result]);\n      },\n      async listContactChannels() {\n        const result = Result.orThrow(await app._serverContactChannelsCache.getOrWait([crud.id], \"write-only\"));\n        return result.map((data) => app._serverContactChannelFromCrud(crud.id, data));\n      },\n      useContactChannels() {\n        const result = useAsyncCache(app._serverContactChannelsCache, [crud.id] as const, \"user.useContactChannels()\");\n        return useMemo(() => result.map((data) => app._serverContactChannelFromCrud(crud.id, data)), [result]);\n      },\n      createContactChannel: async (data: ServerContactChannelCreateOptions) => {\n        const contactChannel = await app._interface.createServerContactChannel(serverContactChannelCreateOptionsToCrud(crud.id, data));\n        await Promise.all([\n          app._serverContactChannelsCache.refresh([crud.id]),\n          app._serverUserCache.refresh([crud.id])\n        ]);\n        return app._serverContactChannelFromCrud(crud.id, contactChannel);\n      },\n      useNotificationCategories() {\n        const results = useAsyncCache(app._serverNotificationCategoriesCache, [crud.id] as const, \"user.useNotificationCategories()\");\n        return results.map((category) => app._serverNotificationCategoryFromCrud(crud.id, category));\n      },\n      async listNotificationCategories() {\n        const results = Result.orThrow(await app._serverNotificationCategoriesCache.getOrWait([crud.id], \"write-only\"));\n        return results.map((category) => app._serverNotificationCategoryFromCrud(crud.id, category));\n      },\n      useApiKeys() {\n        const result = useAsyncCache(app._serverUserApiKeysCache, [crud.id] as const, \"user.useApiKeys()\");\n        return result.map((apiKey) => app._serverApiKeyFromCrud(apiKey));\n      },\n      async listApiKeys() {\n        const result = Result.orThrow(await app._serverUserApiKeysCache.getOrWait([crud.id], \"write-only\"));\n        return result.map((apiKey) => app._serverApiKeyFromCrud(apiKey));\n      },\n      async createApiKey(options: ApiKeyCreationOptions<\"user\">) {\n        const result = await app._interface.createProjectApiKey(\n          await apiKeyCreationOptionsToCrud(\"user\", crud.id, options),\n          null,\n          \"server\",\n        );\n        await app._serverUserApiKeysCache.refresh([crud.id]);\n        return app._serverApiKeyFromCrud(result);\n      },\n      useOAuthProviders() {\n        const results = useAsyncCache(app._serverOAuthProvidersCache, [crud.id] as const, \"user.useOAuthProviders()\");\n        return useMemo(() => results.map((oauthCrud) => app._serverOAuthProviderFromCrud(oauthCrud)), [results]);\n      },\n\n      async listOAuthProviders() {\n        const results = Result.orThrow(await app._serverOAuthProvidersCache.getOrWait([crud.id], \"write-only\"));\n        return results.map((oauthCrud) => app._serverOAuthProviderFromCrud(oauthCrud));\n      },\n\n      useOAuthProvider(id: string) {\n        const providers = this.useOAuthProviders();\n        return useMemo(() => providers.find((p) => p.id === id) ?? null, [providers, id]);\n      },\n      async getOAuthProvider(id: string) {\n        const providers = await this.listOAuthProviders();\n        return providers.find((p) => p.id === id) ?? null;\n      },\n      async registerPasskey(options?: { hostname?: string }): Promise<Result<undefined, KnownErrors[\"PasskeyRegistrationFailed\"] | KnownErrors[\"PasskeyWebAuthnError\"]>> {\n        // TODO remove duplicated code between this and the function in client-app-impl.ts\n        const hostname = options?.hostname || (await app._getCurrentUrl())?.hostname;\n        if (!hostname) {\n          throw new StackAssertionError(\"hostname must be provided if the Stack App does not have a redirect method\");\n        }\n\n        // Use server interface to initiate passkey registration for this specific user\n        const initiationResult = await app._interface.initiateServerPasskeyRegistration(crud.id);\n\n        if (initiationResult.status !== \"ok\") {\n          return Result.error(new KnownErrors.PasskeyRegistrationFailed(\"Failed to get initiation options for passkey registration\"));\n        }\n\n        const { options_json, code } = initiationResult.data;\n\n        // HACK: Override the rpID to be the actual domain\n        if (options_json.rp.id !== \"THIS_VALUE_WILL_BE_REPLACED.example.com\") {\n          throw new StackAssertionError(`Expected returned RP ID from server to equal sentinel, but found ${options_json.rp.id}`);\n        }\n\n        options_json.rp.id = hostname;\n\n        let attResp;\n        try {\n          attResp = await startRegistration({ optionsJSON: options_json });\n        } catch (error: any) {\n          if (error instanceof WebAuthnError) {\n            return Result.error(new KnownErrors.PasskeyWebAuthnError(error.message, error.name));\n          } else {\n            // This should never happen\n            captureError(\"passkey-registration-failed\", error);\n            return Result.error(new KnownErrors.PasskeyRegistrationFailed(\"Failed to start passkey registration due to unknown error\"));\n          }\n        }\n\n        // Create a temporary session to complete the registration\n        // TODO instead of creating a new session, this should just call the endpoint in a way in which it doesn't require a session\n        // (currently this shows up on session history etc... not ideal)\n        const { accessToken, refreshToken } = await app._interface.createServerUserSession(crud.id, 60000 * 2, false);\n        const tempSession = new InternalSession({\n          accessToken,\n          refreshToken,\n          refreshAccessTokenCallback: async () => null,\n        });\n\n        const registrationResult = await app._interface.registerPasskey({ credential: attResp, code }, tempSession);\n\n        await app._serverUserCache.refresh([crud.id]);\n        return registrationResult;\n      },\n      ...app._createServerCustomer(crud.id, \"user\"),\n    } satisfies ServerUser;\n\n    attachUserDestructureGuard(serverUser);\n\n    return serverUser;\n  }\n\n  protected _serverTeamUserFromCrud(crud: TeamMemberProfilesCrud[\"Server\"][\"Read\"]): ServerTeamUser {\n    const teamUser = {\n      ...this._serverUserFromCrud(crud.user),\n      teamProfile: {\n        displayName: crud.display_name,\n        profileImageUrl: crud.profile_image_url,\n      },\n    } satisfies ServerTeamUser;\n\n    attachUserDestructureGuard(teamUser);\n    return teamUser;\n  }\n\n  protected _serverTeamInvitationFromCrud(crud: TeamInvitationCrud['Server']['Read']): TeamInvitation {\n    return {\n      id: crud.id,\n      recipientEmail: crud.recipient_email,\n      expiresAt: new Date(crud.expires_at_millis),\n      revoke: async () => {\n        await this._interface.revokeServerTeamInvitation(crud.id, crud.team_id);\n        await this._serverTeamInvitationsCache.refresh([crud.team_id]);\n      },\n    };\n  }\n\n  protected override _currentUserFromCrud(crud: UsersCrud['Server']['Read'], session: InternalSession): ProjectCurrentServerUser<ProjectId> {\n    const currentUser = {\n      ...this._serverUserFromCrud(crud),\n      ...this._createAuth(session),\n      ...this._isInternalProject() ? this._createInternalUserExtra(session) : {},\n    } satisfies ServerUser;\n\n    attachUserDestructureGuard(currentUser);\n    Object.freeze(currentUser);\n    return currentUser as ProjectCurrentServerUser<ProjectId>;\n  }\n\n  protected _serverTeamFromCrud(crud: TeamsCrud['Server']['Read']): ServerTeam {\n    const app = this;\n    return {\n      id: crud.id,\n      displayName: crud.display_name,\n      profileImageUrl: crud.profile_image_url,\n      createdAt: new Date(crud.created_at_millis),\n      clientMetadata: crud.client_metadata,\n      clientReadOnlyMetadata: crud.client_read_only_metadata,\n      serverMetadata: crud.server_metadata,\n      async update(update: Partial<ServerTeamUpdateOptions>) {\n        await app._interface.updateServerTeam(crud.id, serverTeamUpdateOptionsToCrud(update));\n        await app._serverTeamsCache.refresh([undefined]);\n      },\n      async delete() {\n        await app._interface.deleteServerTeam(crud.id);\n        await app._serverTeamsCache.refresh([undefined]);\n      },\n      async listUsers() {\n        const result = Result.orThrow(await app._serverTeamMemberProfilesCache.getOrWait([crud.id], \"write-only\"));\n        return result.map(u => app._serverTeamUserFromCrud(u));\n      },\n      useUsers() {\n        const result = useAsyncCache(app._serverTeamMemberProfilesCache, [crud.id] as const, \"team.useUsers()\");\n        return useMemo(() => result.map(u => app._serverTeamUserFromCrud(u)), [result]);\n      },\n      async addUser(userId) {\n        await app._interface.addServerUserToTeam({\n          teamId: crud.id,\n          userId,\n        });\n        await app._serverTeamMemberProfilesCache.refresh([crud.id]);\n      },\n      async removeUser(userId) {\n        await app._interface.removeServerUserFromTeam({\n          teamId: crud.id,\n          userId,\n        });\n        await app._serverTeamMemberProfilesCache.refresh([crud.id]);\n      },\n      async inviteUser(options: { email: string, callbackUrl?: string }) {\n        await app._interface.sendServerTeamInvitation({\n          teamId: crud.id,\n          email: options.email,\n          callbackUrl: options.callbackUrl ?? constructRedirectUrl(app.urls.teamInvitation, \"callbackUrl\"),\n        });\n        await app._serverTeamInvitationsCache.refresh([crud.id]);\n      },\n      async listInvitations() {\n        const result = Result.orThrow(await app._serverTeamInvitationsCache.getOrWait([crud.id], \"write-only\"));\n        return result.map((crud) => app._serverTeamInvitationFromCrud(crud));\n      },\n      useInvitations() {\n        const result = useAsyncCache(app._serverTeamInvitationsCache, [crud.id] as const, \"team.useInvitations()\");\n        return useMemo(() => result.map((crud) => app._serverTeamInvitationFromCrud(crud)), [result]);\n      },\n      useApiKeys() {\n        const result = useAsyncCache(app._serverTeamApiKeysCache, [crud.id] as const, \"team.useApiKeys()\");\n        return result.map((apiKey) => app._serverApiKeyFromCrud(apiKey));\n      },\n      async listApiKeys() {\n        const result = Result.orThrow(await app._serverTeamApiKeysCache.getOrWait([crud.id], \"write-only\"));\n        return result.map((apiKey) => app._serverApiKeyFromCrud(apiKey));\n      },\n      async createApiKey(options: ApiKeyCreationOptions<\"team\">) {\n        const result = await app._interface.createProjectApiKey(\n          await apiKeyCreationOptionsToCrud(\"team\", crud.id, options),\n          null,\n          \"server\",\n        );\n        await app._serverTeamApiKeysCache.refresh([crud.id]);\n        return app._serverApiKeyFromCrud(result);\n      },\n      ...app._createServerCustomer(crud.id, \"team\"),\n    };\n  }\n\n  protected _serverItemFromCrud(customer: { type: \"user\" | \"team\" | \"custom\", id: string }, crud: ItemCrud['Client']['Read']): ServerItem {\n    const app = this;\n    return {\n      displayName: crud.display_name,\n      quantity: crud.quantity,\n      nonNegativeQuantity: Math.max(0, crud.quantity),\n      increaseQuantity: async (delta: number) => {\n        const updateOptions = customer.type === \"user\"\n          ? { itemId: crud.id, userId: customer.id }\n          : customer.type === \"team\"\n            ? { itemId: crud.id, teamId: customer.id }\n            : { itemId: crud.id, customCustomerId: customer.id };\n        await app._interface.updateItemQuantity(updateOptions, { delta });\n        if (customer.type === \"user\") await app._serverUserItemsCache.refresh([customer.id, crud.id]);\n        else if (customer.type === \"team\") await app._serverTeamItemsCache.refresh([customer.id, crud.id]);\n        else await app._serverCustomItemsCache.refresh([customer.id, crud.id]);\n      },\n      decreaseQuantity: async (delta: number) => {\n        const updateOptions = customer.type === \"user\"\n          ? { itemId: crud.id, userId: customer.id }\n          : customer.type === \"team\"\n            ? { itemId: crud.id, teamId: customer.id }\n            : { itemId: crud.id, customCustomerId: customer.id };\n        await app._interface.updateItemQuantity(updateOptions, { delta: -delta, allow_negative: true });\n        if (customer.type === \"user\") await app._serverUserItemsCache.refresh([customer.id, crud.id]);\n        else if (customer.type === \"team\") await app._serverTeamItemsCache.refresh([customer.id, crud.id]);\n        else await app._serverCustomItemsCache.refresh([customer.id, crud.id]);\n      },\n      tryDecreaseQuantity: async (delta: number) => {\n        try {\n          const updateOptions = customer.type === \"user\"\n            ? { itemId: crud.id, userId: customer.id }\n            : customer.type === \"team\"\n              ? { itemId: crud.id, teamId: customer.id }\n              : { itemId: crud.id, customCustomerId: customer.id };\n          await app._interface.updateItemQuantity(updateOptions, { delta: -delta });\n          if (customer.type === \"user\") await app._serverUserItemsCache.refresh([customer.id, crud.id]);\n          else if (customer.type === \"team\") await app._serverTeamItemsCache.refresh([customer.id, crud.id]);\n          else await app._serverCustomItemsCache.refresh([customer.id, crud.id]);\n          return true;\n        } catch (error) {\n          if (error instanceof KnownErrors.ItemQuantityInsufficientAmount) {\n            return false;\n          }\n          throw error;\n        }\n      },\n    };\n  }\n\n  protected async _getUserApiKey(options: { apiKey: string }): Promise<ApiKey<\"user\"> | null> {\n    const crud = Result.orThrow(await this._serverCheckApiKeyCache.getOrWait([\"user\", options.apiKey], \"write-only\")) as UserApiKeysCrud['Server']['Read'] | null;\n    return crud ? this._serverApiKeyFromCrud(crud) : null;\n  }\n\n  protected async _getTeamApiKey(options: { apiKey: string }): Promise<ApiKey<\"team\"> | null> {\n    const crud = Result.orThrow(await this._serverCheckApiKeyCache.getOrWait([\"team\", options.apiKey], \"write-only\")) as TeamApiKeysCrud['Server']['Read'] | null;\n    return crud ? this._serverApiKeyFromCrud(crud) : null;\n  }\n  protected _useUserApiKey(options: { apiKey: string }): ApiKey<\"user\"> | null {\n    const crud = useAsyncCache(this._serverCheckApiKeyCache, [\"user\", options.apiKey] as const, \"serverApp.useUserApiKey()\") as UserApiKeysCrud['Server']['Read'] | null;\n    return useMemo(() => crud ? this._serverApiKeyFromCrud(crud) : null, [crud]);\n  }\n  protected _useTeamApiKey(options: { apiKey: string }): ApiKey<\"team\"> | null {\n    const crud = useAsyncCache(this._serverCheckApiKeyCache, [\"team\", options.apiKey] as const, \"serverApp.useTeamApiKey()\") as TeamApiKeysCrud['Server']['Read'] | null;\n    return useMemo(() => crud ? this._serverApiKeyFromCrud(crud) : null, [crud]);\n  }\n  protected async _getUserByApiKey(apiKey: string): Promise<ServerUser | null> {\n    const apiKeyObject = await this._getUserApiKey({ apiKey });\n    if (apiKeyObject === null) {\n      return null;\n    }\n    return await this.getServerUserById(apiKeyObject.userId);\n  }\n\n  protected async _getUserByConvex(ctx: ConvexCtx, includeAnonymous: boolean): Promise<ServerUser | null> {\n    const identity = await ctx.auth.getUserIdentity();\n    if (identity === null) {\n      return null;\n    }\n    const user = await this.getServerUserById(identity.subject);\n    if (user?.isAnonymous && !includeAnonymous) {\n      return null;\n    }\n    return user;\n  }\n  protected _useUserByConvex(ctx: ConvexCtx, includeAnonymous: boolean): ServerUser | null {\n    const subject = useAsyncCache(this._convexIdentitySubjectCache, [ctx] as const, \"serverApp.useUserByConvex()\");\n    if (subject === null) {\n      return null;\n    }\n    const user = this.useUserById(subject);\n    if (user?.isAnonymous && !includeAnonymous) {\n      return null;\n    }\n    return user;\n  }\n  protected _useUserByApiKey(apiKey: string): ServerUser | null {\n    const apiKeyObject = this._useUserApiKey({ apiKey });\n    if (apiKeyObject === null) {\n      return null;\n    }\n    return this.useUserById(apiKeyObject.userId);\n  }\n\n  protected async _getTeamByApiKey(apiKey: string): Promise<ServerTeam | null> {\n    const apiKeyObject = await this._getTeamApiKey({ apiKey });\n    if (apiKeyObject === null) {\n      return null;\n    }\n    return await this.getTeam(apiKeyObject.teamId);\n  }\n  protected _useTeamByApiKey(apiKey: string): ServerTeam | null {\n    const apiKeyObject = this._useTeamApiKey({ apiKey });\n    if (apiKeyObject === null) {\n      return null;\n    }\n    return this.useTeam(apiKeyObject.teamId);\n  }\n\n  async createUser(options: ServerUserCreateOptions): Promise<ServerUser> {\n    const crud = await this._interface.createServerUser(serverUserCreateOptionsToCrud(options));\n    await this._refreshUsers();\n    return this._serverUserFromCrud(crud);\n  }\n\n  async getUser(options: GetCurrentUserOptions<HasTokenStore> & { or: 'redirect' }): Promise<ProjectCurrentServerUser<ProjectId>>;\n  async getUser(options: GetCurrentUserOptions<HasTokenStore> & { or: 'throw' }): Promise<ProjectCurrentServerUser<ProjectId>>;\n  async getUser(options: GetCurrentUserOptions<HasTokenStore> & { or: 'anonymous' }): Promise<ProjectCurrentServerUser<ProjectId>>;\n  async getUser(options?: GetCurrentUserOptions<HasTokenStore>): Promise<ProjectCurrentServerUser<ProjectId> | null>;\n  async getUser(id: string): Promise<ServerUser | null>;\n  async getUser(options: { apiKey: string }): Promise<ServerUser | null>;\n  async getUser(options: { from: \"convex\", ctx: ConvexCtx, or?: \"return-null\" | \"anonymous\" }): Promise<ServerUser | null>;\n  async getUser(options?: string | GetCurrentUserOptions<HasTokenStore> | { apiKey: string } | { from: \"convex\", ctx: ConvexCtx }): Promise<ProjectCurrentServerUser<ProjectId> | ServerUser | null> {\n    if (typeof options === \"string\") {\n      return await this.getServerUserById(options);\n    } else if (typeof options === \"object\" && \"apiKey\" in options) {\n      return await this._getUserByApiKey(options.apiKey);\n    } else if (typeof options === \"object\" && \"from\" in options && options.from as string === \"convex\") {\n      return await this._getUserByConvex(options.ctx, \"or\" in options && options.or === \"anonymous\");\n    } else {\n      options = options as GetCurrentUserOptions<HasTokenStore> | undefined;\n      // TODO this code is duplicated from the client app; fix that\n      this._ensurePersistentTokenStore(options?.tokenStore);\n      const session = await this._getSession(options?.tokenStore);\n      let crud = Result.orThrow(await this._currentServerUserCache.getOrWait([session], \"write-only\"));\n      if (crud?.is_anonymous && options?.or !== \"anonymous\" && options?.or !== \"anonymous-if-exists[deprecated]\") {\n        crud = null;\n      }\n\n      if (crud === null) {\n        switch (options?.or) {\n          case 'redirect': {\n            await this.redirectToSignIn({ replace: true });\n            break;\n          }\n          case 'throw': {\n            throw new Error(\"User is not signed in but getUser was called with { or: 'throw' }\");\n          }\n          case 'anonymous': {\n            const tokens = await this._signUpAnonymously();\n            return await this.getUser({ tokenStore: tokens, or: \"anonymous-if-exists[deprecated]\" }) ?? throwErr(\"Something went wrong while signing up anonymously\");\n          }\n          case undefined:\n          case \"anonymous-if-exists[deprecated]\":\n          case \"return-null\": {\n            return null;\n          }\n        }\n      }\n\n      return crud && this._currentUserFromCrud(crud, session);\n    }\n  }\n\n  async getServerUser(): Promise<ProjectCurrentServerUser<ProjectId> | null> {\n    console.warn(\"stackServerApp.getServerUser is deprecated; use stackServerApp.getUser instead\");\n    return await this.getUser();\n  }\n\n  async getServerUserById(userId: string): Promise<ServerUser | null> {\n    const crud = Result.orThrow(await this._serverUserCache.getOrWait([userId], \"write-only\"));\n    return crud && this._serverUserFromCrud(crud);\n  }\n\n  useUser(options: GetCurrentUserOptions<HasTokenStore> & { or: 'redirect' }): ProjectCurrentServerUser<ProjectId>;\n  useUser(options: GetCurrentUserOptions<HasTokenStore> & { or: 'throw' }): ProjectCurrentServerUser<ProjectId>;\n  useUser(options: GetCurrentUserOptions<HasTokenStore> & { or: 'anonymous' }): ProjectCurrentServerUser<ProjectId>;\n  useUser(options?: GetCurrentUserOptions<HasTokenStore>): ProjectCurrentServerUser<ProjectId> | null;\n  useUser(id: string): ServerUser | null;\n  useUser(options: { apiKey: string }): ServerUser | null;\n  useUser(options: { from: \"convex\", ctx: ConvexCtx, or?: \"return-null\" | \"anonymous\" }): ServerUser | null;\n  useUser(options?: GetCurrentUserOptions<HasTokenStore> | string | { apiKey: string } | { from: \"convex\", ctx: ConvexCtx }): ProjectCurrentServerUser<ProjectId> | ServerUser | null {\n    if (typeof options === \"string\") {\n      return this.useUserById(options);\n    } else if (typeof options === \"object\" && \"apiKey\" in options) {\n      return this._useUserByApiKey(options.apiKey);\n    } else if (typeof options === \"object\" && \"from\" in options && options.from as string === \"convex\") {\n      return this._useUserByConvex(options.ctx, \"or\" in options && options.or === \"anonymous\");\n    } else {\n      options = options as GetCurrentUserOptions<HasTokenStore> | undefined;\n      // TODO this code is duplicated from the client app; fix that\n      this._ensurePersistentTokenStore(options?.tokenStore);\n\n      const session = this._useSession(options?.tokenStore);\n      let crud = useAsyncCache(this._currentServerUserCache, [session] as const, \"serverApp.useUser()\");\n      if (crud?.is_anonymous && options?.or !== \"anonymous\" && options?.or !== \"anonymous-if-exists[deprecated]\") {\n        crud = null;\n      }\n\n      if (crud === null) {\n        switch (options?.or) {\n          case 'redirect': {\n            runAsynchronously(this.redirectToSignIn({ replace: true }));\n            suspend();\n            throw new StackAssertionError(\"suspend should never return\");\n          }\n          case 'throw': {\n            throw new Error(\"User is not signed in but useUser was called with { or: 'throw' }\");\n          }\n          case 'anonymous': {\n            // TODO we should think about the behavior when calling useUser (or getUser) in anonymous with a custom token store. signUpAnonymously always sets the current token store on app level, instead of the one passed to this function\n            // TODO we shouldn't reload & suspend here, instead we should use a promise that resolves to the new anonymous user\n            runAsynchronously(async () => {\n              await this._signUpAnonymously();\n              if (typeof window !== \"undefined\") {\n                window.location.reload();\n              }\n            });\n            suspend();\n            throw new StackAssertionError(\"suspend should never return\");\n          }\n          case undefined:\n          case \"anonymous-if-exists[deprecated]\":\n          case \"return-null\": {\n            // do nothing\n          }\n        }\n      }\n\n      return useMemo(() => {\n        return crud && this._currentUserFromCrud(crud, session);\n      }, [crud, session, options?.or]);\n    }\n  }\n  useUserById(userId: string): ServerUser | null {\n    const crud = useAsyncCache(this._serverUserCache, [userId], \"serverApp.useUserById()\");\n    return useMemo(() => {\n      return crud && this._serverUserFromCrud(crud);\n    }, [crud]);\n  }\n\n  async listUsers(options?: ServerListUsersOptions): Promise<ServerUser[] & { nextCursor: string | null }> {\n    const crud = Result.orThrow(await this._serverUsersCache.getOrWait([options?.cursor, options?.limit, options?.orderBy, options?.desc, options?.query, options?.includeAnonymous], \"write-only\"));\n    const result: any = crud.items.map((j) => this._serverUserFromCrud(j));\n    result.nextCursor = crud.pagination?.next_cursor ?? null;\n    return result as any;\n  }\n\n  useUsers(options?: ServerListUsersOptions): ServerUser[] & { nextCursor: string | null } {\n    const crud = useAsyncCache(this._serverUsersCache, [options?.cursor, options?.limit, options?.orderBy, options?.desc, options?.query, options?.includeAnonymous] as const, \"serverApp.useUsers()\");\n    const result: any = crud.items.map((j) => this._serverUserFromCrud(j));\n    result.nextCursor = crud.pagination?.next_cursor ?? null;\n    return result as any;\n  }\n\n  _serverPermissionFromCrud(crud: TeamPermissionsCrud['Server']['Read'] | ProjectPermissionsCrud['Server']['Read']): AdminTeamPermission {\n    return {\n      id: crud.id,\n    };\n  }\n\n  _serverTeamPermissionDefinitionFromCrud(crud: TeamPermissionDefinitionsCrud['Admin']['Read']): AdminTeamPermissionDefinition {\n    return {\n      id: crud.id,\n      description: crud.description,\n      containedPermissionIds: crud.contained_permission_ids,\n    };\n  }\n\n  _serverProjectPermissionDefinitionFromCrud(crud: ProjectPermissionDefinitionsCrud['Admin']['Read']): AdminProjectPermissionDefinition {\n    return {\n      id: crud.id,\n      description: crud.description,\n      containedPermissionIds: crud.contained_permission_ids,\n    };\n  }\n\n  async listTeams(): Promise<ServerTeam[]> {\n    const teams = Result.orThrow(await this._serverTeamsCache.getOrWait([undefined], \"write-only\"));\n    return teams.map((t) => this._serverTeamFromCrud(t));\n  }\n\n  async getItem(options: { itemId: string, userId: string } | { itemId: string, teamId: string } | { itemId: string, customCustomerId: string }): Promise<ServerItem> {\n    if (\"userId\" in options) {\n      const result = Result.orThrow(await this._serverUserItemsCache.getOrWait([options.userId, options.itemId], \"write-only\"));\n      return this._serverItemFromCrud({ type: \"user\", id: options.userId }, result);\n    } else if (\"teamId\" in options) {\n      const result = Result.orThrow(await this._serverTeamItemsCache.getOrWait([options.teamId, options.itemId], \"write-only\"));\n      return this._serverItemFromCrud({ type: \"team\", id: options.teamId }, result);\n    } else {\n      const result = Result.orThrow(await this._serverCustomItemsCache.getOrWait([options.customCustomerId, options.itemId], \"write-only\"));\n      return this._serverItemFromCrud({ type: \"custom\", id: options.customCustomerId }, result);\n    }\n  }\n\n  useItem(options: { itemId: string, userId: string } | { itemId: string, teamId: string } | { itemId: string, customCustomerId: string }): ServerItem {\n    let type: \"user\" | \"team\" | \"custom\";\n    let id: string;\n    let cache: AsyncCache<[string, string], Result<ItemCrud['Client']['Read']>>;\n    if (\"userId\" in options) {\n      type = \"user\";\n      id = options.userId;\n      cache = this._serverUserItemsCache;\n    } else if (\"teamId\" in options) {\n      type = \"team\";\n      id = options.teamId;\n      cache = this._serverTeamItemsCache;\n    } else {\n      type = \"custom\";\n      id = options.customCustomerId;\n      cache = this._serverCustomItemsCache;\n    }\n\n    const cacheKey = [id, options.itemId] as [string, string];\n    const debugLabel = \"serverApp.useItem()\";\n    const result = useAsyncCache(cache, cacheKey, debugLabel);\n    return useMemo(() => this._serverItemFromCrud({ type, id }, result), [result]);\n  }\n  async grantProduct(options: (\n    ({ userId: string } | { teamId: string } | { customCustomerId: string }) &\n    ({ productId: string } | { product: InlineProduct }) &\n    { quantity?: number }\n  )): Promise<void> {\n    let customerType: \"user\" | \"team\" | \"custom\";\n    let customerId: string;\n    if (\"userId\" in options) {\n      customerType = \"user\";\n      customerId = options.userId;\n    } else if (\"teamId\" in options) {\n      customerType = \"team\";\n      customerId = options.teamId;\n    } else {\n      customerType = \"custom\";\n      customerId = options.customCustomerId;\n    }\n\n    await this._interface.grantProduct({\n      customerType,\n      customerId,\n      productId: \"productId\" in options ? options.productId : undefined,\n      product: \"product\" in options ? options.product : undefined,\n      quantity: options.quantity,\n    });\n\n    const cache = customerType === \"user\"\n      ? this._serverUserProductsCache\n      : customerType === \"team\"\n        ? this._serverTeamProductsCache\n        : this._serverCustomProductsCache;\n    await cache.refresh([customerId, null, null]);\n  }\n\n  async createTeam(data: ServerTeamCreateOptions): Promise<ServerTeam> {\n    const team = await this._interface.createServerTeam(serverTeamCreateOptionsToCrud(data));\n    await this._serverTeamsCache.refresh([undefined]);\n    return this._serverTeamFromCrud(team);\n  }\n\n  useTeams(): ServerTeam[] {\n    const teams = useAsyncCache(this._serverTeamsCache, [undefined], \"serverApp.useTeams()\");\n    return useMemo(() => {\n      return teams.map((t) => this._serverTeamFromCrud(t));\n    }, [teams]);\n  }\n\n  async getTeam(options: { apiKey: string }): Promise<ServerTeam | null>;\n  async getTeam(teamId: string): Promise<ServerTeam | null>;\n  async getTeam(options?: { apiKey: string } | string): Promise<ServerTeam | null> {\n    if (typeof options === \"object\" && \"apiKey\" in options) {\n      return await this._getTeamByApiKey(options.apiKey);\n    } else {\n      const teamId = options;\n      const teams = await this.listTeams();\n      return teams.find((t) => t.id === teamId) ?? null;\n    }\n  }\n\n  useTeam(options: { apiKey: string }): ServerTeam | null;\n  useTeam(teamId: string): ServerTeam | null;\n  useTeam(options?: { apiKey: string } | string): ServerTeam | null {\n    if (typeof options === \"object\" && \"apiKey\" in options) {\n      return this._useTeamByApiKey(options.apiKey);\n    } else {\n      const teamId = options;\n      const teams = this.useTeams();\n      return useMemo(() => {\n        return teams.find((t) => t.id === teamId) ?? null;\n      }, [teams, teamId]);\n    }\n  }\n\n  protected _createServerDataVaultStore(id: string): DataVaultStore {\n    const validateOptions = (options: { secret: string }) => {\n      if (typeof options.secret !== \"string\") throw new Error(\"secret must be a string, got \" + typeof options.secret);\n    };\n    return {\n      id,\n      setValue: async (key, value, options) => {\n        validateOptions(options);\n        await this._interface.setDataVaultStoreValue(options.secret, id, key, value);\n      },\n      getValue: async (key, options) => {\n        validateOptions(options);\n        return Result.orThrow(await this._serverDataVaultStoreValueCache.getOrWait([id, key, options.secret], \"write-only\"));\n      },\n      useValue: (key, options) => {\n        validateOptions(options);\n        return useAsyncCache(this._serverDataVaultStoreValueCache, [id, key, options.secret] as const, \"store.useValue()\");\n      },\n    };\n  }\n\n  async getDataVaultStore(id: string): Promise<DataVaultStore> {\n    return this._createServerDataVaultStore(id);\n  }\n\n  useDataVaultStore(id: string): DataVaultStore {\n    return useMemo(() => this._createServerDataVaultStore(id), [id]);\n  }\n\n  async sendEmail(options: SendEmailOptions): Promise<void> {\n    await this._interface.sendEmail(options);\n  }\n\n  protected override async _refreshSession(session: InternalSession) {\n    await Promise.all([\n      super._refreshUser(session),\n      this._currentServerUserCache.refresh([session]),\n    ]);\n  }\n\n  protected override async _refreshUsers() {\n    await Promise.all([\n      super._refreshUsers(),\n      this._serverUserCache.refreshWhere(() => true),\n      this._serverUsersCache.refreshWhere(() => true),\n      this._serverContactChannelsCache.refreshWhere(() => true),\n      this._serverOAuthProvidersCache.refreshWhere(() => true),\n    ]);\n  }\n\n  async createOAuthProvider(options: {\n    userId: string,\n    providerConfigId: string,\n    accountId: string,\n    email: string,\n    allowSignIn: boolean,\n    allowConnectedAccounts: boolean,\n  }): Promise<Result<ServerOAuthProvider, InstanceType<typeof KnownErrors.OAuthProviderAccountIdAlreadyUsedForSignIn>>> {\n    try {\n      const crud = await this._interface.createServerOAuthProvider({\n        user_id: options.userId,\n        provider_config_id: options.providerConfigId,\n        account_id: options.accountId,\n        email: options.email,\n        allow_sign_in: options.allowSignIn,\n        allow_connected_accounts: options.allowConnectedAccounts,\n      });\n\n      await this._serverOAuthProvidersCache.refresh([options.userId]);\n      return Result.ok(this._serverOAuthProviderFromCrud(crud));\n    } catch (error) {\n      if (KnownErrors.OAuthProviderAccountIdAlreadyUsedForSignIn.isInstance(error)) {\n        return Result.error(error);\n      }\n      throw error;\n    }\n  }\n}\n"],"names":["crud"],"mappings":"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"}},
    {"offset": {"line": 5042, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack/src/lib/stack-app/apps/implementations/admin-app-impl.ts"],"sourcesContent":["\n//===========================================\n// THIS FILE IS AUTO-GENERATED FROM TEMPLATE. DO NOT EDIT IT DIRECTLY\n//===========================================\nimport { StackAdminInterface } from \"@stackframe/stack-shared\";\nimport { getProductionModeErrors } from \"@stackframe/stack-shared/dist/helpers/production-mode\";\nimport { InternalApiKeyCreateCrudResponse } from \"@stackframe/stack-shared/dist/interface/admin-interface\";\nimport { EmailTemplateCrud } from \"@stackframe/stack-shared/dist/interface/crud/email-templates\";\nimport { InternalApiKeysCrud } from \"@stackframe/stack-shared/dist/interface/crud/internal-api-keys\";\nimport { ProjectsCrud } from \"@stackframe/stack-shared/dist/interface/crud/projects\";\nimport type { Transaction, TransactionType } from \"@stackframe/stack-shared/dist/interface/crud/transactions\";\nimport { StackAssertionError, throwErr } from \"@stackframe/stack-shared/dist/utils/errors\";\nimport { pick } from \"@stackframe/stack-shared/dist/utils/objects\";\nimport { Result } from \"@stackframe/stack-shared/dist/utils/results\";\nimport { useMemo } from \"react\"; // THIS_LINE_PLATFORM react-like\nimport { AdminSentEmail } from \"../..\";\nimport { EmailConfig, stackAppInternalsSymbol } from \"../../common\";\nimport { AdminEmailTemplate } from \"../../email-templates\";\nimport { InternalApiKey, InternalApiKeyBase, InternalApiKeyBaseCrudRead, InternalApiKeyCreateOptions, InternalApiKeyFirstView, internalApiKeyCreateOptionsToCrud } from \"../../internal-api-keys\";\nimport { AdminProjectPermission, AdminProjectPermissionDefinition, AdminProjectPermissionDefinitionCreateOptions, AdminProjectPermissionDefinitionUpdateOptions, AdminTeamPermission, AdminTeamPermissionDefinition, AdminTeamPermissionDefinitionCreateOptions, AdminTeamPermissionDefinitionUpdateOptions, adminProjectPermissionDefinitionCreateOptionsToCrud, adminProjectPermissionDefinitionUpdateOptionsToCrud, adminTeamPermissionDefinitionCreateOptionsToCrud, adminTeamPermissionDefinitionUpdateOptionsToCrud } from \"../../permissions\";\nimport { AdminOwnedProject, AdminProject, AdminProjectUpdateOptions, adminProjectUpdateOptionsToCrud } from \"../../projects\";\nimport { StackAdminApp, StackAdminAppConstructorOptions } from \"../interfaces/admin-app\";\nimport { clientVersion, createCache, getBaseUrl, getDefaultExtraRequestHeaders, getDefaultProjectId, getDefaultPublishableClientKey, getDefaultSecretServerKey, getDefaultSuperSecretAdminKey, resolveConstructorOptions } from \"./common\";\nimport { _StackServerAppImplIncomplete } from \"./server-app-impl\";\n\nimport { CompleteConfig, EnvironmentConfigOverrideOverride } from \"@stackframe/stack-shared/dist/config/schema\";\nimport { ChatContent } from \"@stackframe/stack-shared/dist/interface/admin-interface\";\nimport { ConfigCrud } from \"@stackframe/stack-shared/dist/interface/crud/config\";\nimport { useAsyncCache } from \"./common\"; // THIS_LINE_PLATFORM react-like\n\nexport class _StackAdminAppImplIncomplete<HasTokenStore extends boolean, ProjectId extends string> extends _StackServerAppImplIncomplete<HasTokenStore, ProjectId> implements StackAdminApp<HasTokenStore, ProjectId> {\n  declare protected _interface: StackAdminInterface;\n\n  private readonly _adminProjectCache = createCache(async () => {\n    return await this._interface.getProject();\n  });\n  private readonly _internalApiKeysCache = createCache(async () => {\n    const res = await this._interface.listInternalApiKeys();\n    return res;\n  });\n  private readonly _adminEmailThemeCache = createCache(async ([id]: [string]) => {\n    return await this._interface.getEmailTheme(id);\n  });\n  private readonly _adminEmailThemesCache = createCache(async () => {\n    return await this._interface.listEmailThemes();\n  });\n  private readonly _adminEmailTemplatesCache = createCache(async () => {\n    return await this._interface.listInternalEmailTemplates();\n  });\n  private readonly _adminEmailDraftsCache = createCache(async () => {\n    return await this._interface.listInternalEmailDrafts();\n  });\n  private readonly _adminTeamPermissionDefinitionsCache = createCache(async () => {\n    return await this._interface.listTeamPermissionDefinitions();\n  });\n  private readonly _adminProjectPermissionDefinitionsCache = createCache(async () => {\n    return await this._interface.listProjectPermissionDefinitions();\n  });\n  private readonly _svixTokenCache = createCache(async () => {\n    return await this._interface.getSvixToken();\n  });\n  private readonly _metricsCache = createCache(async ([includeAnonymous]: [boolean]) => {\n    return await this._interface.getMetrics(includeAnonymous);\n  });\n  private readonly _emailPreviewCache = createCache(async ([themeId, themeTsxSource, templateId, templateTsxSource]: [string | null | false | undefined, string | undefined, string | undefined, string | undefined]) => {\n    return await this._interface.renderEmailPreview({ themeId, themeTsxSource, templateId, templateTsxSource });\n  });\n  private readonly _configOverridesCache = createCache(async () => {\n    return await this._interface.getConfig();\n  });\n  private readonly _stripeAccountInfoCache = createCache(async () => {\n    try {\n      return await this._interface.getStripeAccountInfo();\n    } catch (error: any) {\n      if (error?.status === 404) {\n        return null;\n      }\n      throw error;\n    }\n  });\n  private readonly _transactionsCache = createCache(async ([cursor, limit, type, customerType]: [string | undefined, number | undefined, TransactionType | undefined, 'user' | 'team' | 'custom' | undefined]) => {\n    return await this._interface.listTransactions({ cursor, limit, type, customerType });\n  });\n\n  constructor(options: StackAdminAppConstructorOptions<HasTokenStore, ProjectId>, extraOptions?: { uniqueIdentifier?: string, checkString?: string, interface?: StackAdminInterface }) {\n    const resolvedOptions = resolveConstructorOptions(options);\n\n    super(resolvedOptions, {\n      ...extraOptions,\n      interface: extraOptions?.interface ?? new StackAdminInterface({\n        getBaseUrl: () => getBaseUrl(resolvedOptions.baseUrl),\n        projectId: resolvedOptions.projectId ?? getDefaultProjectId(),\n        extraRequestHeaders: resolvedOptions.extraRequestHeaders ?? getDefaultExtraRequestHeaders(),\n        clientVersion,\n        ...resolvedOptions.projectOwnerSession ? {\n          projectOwnerSession: resolvedOptions.projectOwnerSession,\n        } : {\n          publishableClientKey: resolvedOptions.publishableClientKey ?? getDefaultPublishableClientKey(),\n          secretServerKey: resolvedOptions.secretServerKey ?? getDefaultSecretServerKey(),\n          superSecretAdminKey: resolvedOptions.superSecretAdminKey ?? getDefaultSuperSecretAdminKey(),\n        },\n      }),\n    });\n  }\n\n  _adminConfigFromCrud(data: ConfigCrud['Admin']['Read']): CompleteConfig {\n    return JSON.parse(data.config_string);\n  }\n\n  _adminOwnedProjectFromCrud(data: ProjectsCrud['Admin']['Read'], onRefresh: () => Promise<void>): AdminOwnedProject {\n    if (this._tokenStoreInit !== null) {\n      throw new StackAssertionError(\"Owned apps must always have tokenStore === null  did you not create this project with app._createOwnedApp()?\");\n    }\n    return {\n      ...this._adminProjectFromCrud(data, onRefresh),\n      app: this as StackAdminApp<false>,\n    };\n  }\n\n  _adminProjectFromCrud(data: ProjectsCrud['Admin']['Read'], onRefresh: () => Promise<void>): AdminProject {\n    if (data.id !== this.projectId) {\n      throw new StackAssertionError(`The project ID of the provided project JSON (${data.id}) does not match the project ID of the app (${this.projectId})!`);\n    }\n\n    const app = this;\n    return {\n      id: data.id,\n      displayName: data.display_name,\n      description: data.description,\n      createdAt: new Date(data.created_at_millis),\n      isProductionMode: data.is_production_mode,\n      ownerTeamId: data.owner_team_id,\n      logoUrl: data.logo_url,\n      logoFullUrl: data.logo_full_url,\n      logoDarkModeUrl: data.logo_dark_mode_url,\n      logoFullDarkModeUrl: data.logo_full_dark_mode_url,\n      config: {\n        signUpEnabled: data.config.sign_up_enabled,\n        credentialEnabled: data.config.credential_enabled,\n        magicLinkEnabled: data.config.magic_link_enabled,\n        passkeyEnabled: data.config.passkey_enabled,\n        clientTeamCreationEnabled: data.config.client_team_creation_enabled,\n        clientUserDeletionEnabled: data.config.client_user_deletion_enabled,\n        allowLocalhost: data.config.allow_localhost,\n        oauthAccountMergeStrategy: data.config.oauth_account_merge_strategy,\n        allowUserApiKeys: data.config.allow_user_api_keys,\n        allowTeamApiKeys: data.config.allow_team_api_keys,\n        oauthProviders: data.config.oauth_providers.map((p) => ((p.type === 'shared' ? {\n          id: p.id,\n          type: 'shared',\n        } as const : {\n          id: p.id,\n          type: 'standard',\n          clientId: p.client_id ?? throwErr(\"Client ID is missing\"),\n          clientSecret: p.client_secret ?? throwErr(\"Client secret is missing\"),\n          facebookConfigId: p.facebook_config_id,\n          microsoftTenantId: p.microsoft_tenant_id,\n        } as const))),\n        emailConfig: data.config.email_config.type === 'shared' ? {\n          type: 'shared'\n        } : {\n          type: 'standard',\n          host: data.config.email_config.host ?? throwErr(\"Email host is missing\"),\n          port: data.config.email_config.port ?? throwErr(\"Email port is missing\"),\n          username: data.config.email_config.username ?? throwErr(\"Email username is missing\"),\n          password: data.config.email_config.password ?? throwErr(\"Email password is missing\"),\n          senderName: data.config.email_config.sender_name ?? throwErr(\"Email sender name is missing\"),\n          senderEmail: data.config.email_config.sender_email ?? throwErr(\"Email sender email is missing\"),\n        },\n        emailTheme: data.config.email_theme,\n        domains: data.config.domains.map((d) => ({\n          domain: d.domain,\n          handlerPath: d.handler_path,\n        })),\n        createTeamOnSignUp: data.config.create_team_on_sign_up,\n        teamCreatorDefaultPermissions: data.config.team_creator_default_permissions,\n        teamMemberDefaultPermissions: data.config.team_member_default_permissions,\n        userDefaultPermissions: data.config.user_default_permissions,\n      },\n      async getConfig() {\n        return app._adminConfigFromCrud(await app._interface.getConfig());\n      },\n      useConfig() {\n        const config = useAsyncCache(app._configOverridesCache, [], \"project.useConfig()\");\n        return useMemo(() => app._adminConfigFromCrud(config), [config]);\n      },\n      async updateConfig(configOverride: EnvironmentConfigOverrideOverride) {\n        await app._interface.updateConfig({ configOverride });\n        await app._configOverridesCache.refresh([]);\n      },\n      async update(update: AdminProjectUpdateOptions) {\n        const updateOptions = adminProjectUpdateOptionsToCrud(update);\n        await app._interface.updateProject(updateOptions);\n        await onRefresh();\n      },\n      async delete() {\n        await app._interface.deleteProject();\n      },\n      async getProductionModeErrors() {\n        return getProductionModeErrors(data);\n      },\n      useProductionModeErrors() {\n        return getProductionModeErrors(data);\n      },\n    };\n  }\n\n  _adminEmailTemplateFromCrud(data: EmailTemplateCrud['Admin']['Read']): AdminEmailTemplate {\n    return {\n      type: data.type,\n      subject: data.subject,\n      content: data.content,\n      isDefault: data.is_default,\n    };\n  }\n\n  override async getProject(): Promise<AdminProject> {\n    return this._adminProjectFromCrud(\n      Result.orThrow(await this._adminProjectCache.getOrWait([], \"write-only\")),\n      () => this._refreshProject()\n    );\n  }\n\n  override useProject(): AdminProject {\n    const crud = useAsyncCache(this._adminProjectCache, [], \"adminApp.useProject()\");\n    return useMemo(() => this._adminProjectFromCrud(\n      crud,\n      () => this._refreshProject()\n    ), [crud]);\n  }\n\n  protected _createInternalApiKeyBaseFromCrud(data: InternalApiKeyBaseCrudRead): InternalApiKeyBase {\n    const app = this;\n    return {\n      id: data.id,\n      description: data.description,\n      expiresAt: new Date(data.expires_at_millis),\n      manuallyRevokedAt: data.manually_revoked_at_millis ? new Date(data.manually_revoked_at_millis) : null,\n      createdAt: new Date(data.created_at_millis),\n      isValid() {\n        return this.whyInvalid() === null;\n      },\n      whyInvalid() {\n        if (this.expiresAt.getTime() < Date.now()) return \"expired\";\n        if (this.manuallyRevokedAt) return \"manually-revoked\";\n        return null;\n      },\n      async revoke() {\n        const res = await app._interface.revokeInternalApiKeyById(data.id);\n        await app._refreshInternalApiKeys();\n        return res;\n      }\n    };\n  }\n\n  protected _createInternalApiKeyFromCrud(data: InternalApiKeysCrud[\"Admin\"][\"Read\"]): InternalApiKey {\n    return {\n      ...this._createInternalApiKeyBaseFromCrud(data),\n      publishableClientKey: data.publishable_client_key ? { lastFour: data.publishable_client_key.last_four } : null,\n      secretServerKey: data.secret_server_key ? { lastFour: data.secret_server_key.last_four } : null,\n      superSecretAdminKey: data.super_secret_admin_key ? { lastFour: data.super_secret_admin_key.last_four } : null,\n    };\n  }\n\n  protected _createInternalApiKeyFirstViewFromCrud(data: InternalApiKeyCreateCrudResponse): InternalApiKeyFirstView {\n    return {\n      ...this._createInternalApiKeyBaseFromCrud(data),\n      publishableClientKey: data.publishable_client_key,\n      secretServerKey: data.secret_server_key,\n      superSecretAdminKey: data.super_secret_admin_key,\n    };\n  }\n\n  async listInternalApiKeys(): Promise<InternalApiKey[]> {\n    const crud = Result.orThrow(await this._internalApiKeysCache.getOrWait([], \"write-only\"));\n    return crud.map((j) => this._createInternalApiKeyFromCrud(j));\n  }\n\n  useInternalApiKeys(): InternalApiKey[] {\n    const crud = useAsyncCache(this._internalApiKeysCache, [], \"adminApp.useInternalApiKeys()\");\n    return useMemo(() => {\n      return crud.map((j) => this._createInternalApiKeyFromCrud(j));\n    }, [crud]);\n  }\n\n  async createInternalApiKey(options: InternalApiKeyCreateOptions): Promise<InternalApiKeyFirstView> {\n    const crud = await this._interface.createInternalApiKey(internalApiKeyCreateOptionsToCrud(options));\n    await this._refreshInternalApiKeys();\n    return this._createInternalApiKeyFirstViewFromCrud(crud);\n  }\n\n\n  useEmailThemes(): { id: string, displayName: string }[] {\n    const crud = useAsyncCache(this._adminEmailThemesCache, [], \"adminApp.useEmailThemes()\");\n    return useMemo(() => {\n      return crud.map((theme) => ({\n        id: theme.id,\n        displayName: theme.display_name,\n      }));\n    }, [crud]);\n  }\n  useEmailTemplates(): { id: string, displayName: string, themeId?: string, tsxSource: string }[] {\n    const crud = useAsyncCache(this._adminEmailTemplatesCache, [], \"adminApp.useEmailTemplates()\");\n    return useMemo(() => {\n      return crud.map((template) => ({\n        id: template.id,\n        displayName: template.display_name,\n        themeId: template.theme_id,\n        tsxSource: template.tsx_source,\n      }));\n    }, [crud]);\n  }\n  useEmailDrafts(): { id: string, displayName: string, themeId: string | undefined | false, tsxSource: string, sentAt: Date | null }[] {\n    const crud = useAsyncCache(this._adminEmailDraftsCache, [], \"adminApp.useEmailDrafts()\");\n    return useMemo(() => {\n      return crud.map((draft) => ({\n        id: draft.id,\n        displayName: draft.display_name,\n        themeId: draft.theme_id,\n        tsxSource: draft.tsx_source,\n        sentAt: draft.sent_at_millis ? new Date(draft.sent_at_millis) : null,\n      }));\n    }, [crud]);\n  }\n  async listEmailThemes(): Promise<{ id: string, displayName: string }[]> {\n    const crud = Result.orThrow(await this._adminEmailThemesCache.getOrWait([], \"write-only\"));\n    return crud.map((theme) => ({\n      id: theme.id,\n      displayName: theme.display_name,\n    }));\n  }\n\n  async listEmailTemplates(): Promise<{ id: string, displayName: string, themeId?: string, tsxSource: string }[]> {\n    const crud = Result.orThrow(await this._adminEmailTemplatesCache.getOrWait([], \"write-only\"));\n    return crud.map((template) => ({\n      id: template.id,\n      displayName: template.display_name,\n      themeId: template.theme_id,\n      tsxSource: template.tsx_source,\n    }));\n  }\n\n  async listEmailDrafts(): Promise<{ id: string, displayName: string, themeId: string | undefined | false, tsxSource: string, sentAt: Date | null }[]> {\n    const crud = Result.orThrow(await this._adminEmailDraftsCache.getOrWait([], \"write-only\"));\n    return crud.map((draft) => ({\n      id: draft.id,\n      displayName: draft.display_name,\n      themeId: draft.theme_id,\n      tsxSource: draft.tsx_source,\n      sentAt: draft.sent_at_millis ? new Date(draft.sent_at_millis) : null,\n    }));\n  }\n\n\n  async createTeamPermissionDefinition(data: AdminTeamPermissionDefinitionCreateOptions): Promise<AdminTeamPermission> {\n    const crud = await this._interface.createTeamPermissionDefinition(adminTeamPermissionDefinitionCreateOptionsToCrud(data));\n    await this._adminTeamPermissionDefinitionsCache.refresh([]);\n    return this._serverTeamPermissionDefinitionFromCrud(crud);\n  }\n\n  async updateTeamPermissionDefinition(permissionId: string, data: AdminTeamPermissionDefinitionUpdateOptions) {\n    await this._interface.updateTeamPermissionDefinition(permissionId, adminTeamPermissionDefinitionUpdateOptionsToCrud(data));\n    await this._adminTeamPermissionDefinitionsCache.refresh([]);\n  }\n\n  async deleteTeamPermissionDefinition(permissionId: string): Promise<void> {\n    await this._interface.deleteTeamPermissionDefinition(permissionId);\n    await this._adminTeamPermissionDefinitionsCache.refresh([]);\n  }\n\n  async listTeamPermissionDefinitions(): Promise<AdminTeamPermissionDefinition[]> {\n    const crud = Result.orThrow(await this._adminTeamPermissionDefinitionsCache.getOrWait([], \"write-only\"));\n    return crud.map((p) => this._serverTeamPermissionDefinitionFromCrud(p));\n  }\n\n  useTeamPermissionDefinitions(): AdminTeamPermissionDefinition[] {\n    const crud = useAsyncCache(this._adminTeamPermissionDefinitionsCache, [], \"adminApp.useTeamPermissionDefinitions()\");\n    return useMemo(() => {\n      return crud.map((p) => this._serverTeamPermissionDefinitionFromCrud(p));\n    }, [crud]);\n  }\n\n  async createProjectPermissionDefinition(data: AdminProjectPermissionDefinitionCreateOptions): Promise<AdminProjectPermission> {\n    const crud = await this._interface.createProjectPermissionDefinition(adminProjectPermissionDefinitionCreateOptionsToCrud(data));\n    await this._adminProjectPermissionDefinitionsCache.refresh([]);\n    return this._serverProjectPermissionDefinitionFromCrud(crud);\n  }\n\n  async updateProjectPermissionDefinition(permissionId: string, data: AdminProjectPermissionDefinitionUpdateOptions) {\n    await this._interface.updateProjectPermissionDefinition(permissionId, adminProjectPermissionDefinitionUpdateOptionsToCrud(data));\n    await this._adminProjectPermissionDefinitionsCache.refresh([]);\n  }\n\n  async deleteProjectPermissionDefinition(permissionId: string): Promise<void> {\n    await this._interface.deleteProjectPermissionDefinition(permissionId);\n    await this._adminProjectPermissionDefinitionsCache.refresh([]);\n  }\n\n  async listProjectPermissionDefinitions(): Promise<AdminProjectPermissionDefinition[]> {\n    const crud = Result.orThrow(await this._adminProjectPermissionDefinitionsCache.getOrWait([], \"write-only\"));\n    return crud.map((p) => this._serverProjectPermissionDefinitionFromCrud(p));\n  }\n\n  useProjectPermissionDefinitions(): AdminProjectPermissionDefinition[] {\n    const crud = useAsyncCache(this._adminProjectPermissionDefinitionsCache, [], \"adminApp.useProjectPermissionDefinitions()\");\n    return useMemo(() => {\n      return crud.map((p) => this._serverProjectPermissionDefinitionFromCrud(p));\n    }, [crud]);\n  }\n  useSvixToken(): { token: string, url: string | undefined } {\n    const crud = useAsyncCache(this._svixTokenCache, [], \"adminApp.useSvixToken()\");\n    return { token: crud.token, url: crud.url };\n  }\n\n  protected override async _refreshProject() {\n    await Promise.all([\n      super._refreshProject(),\n      this._adminProjectCache.refresh([]),\n    ]);\n  }\n\n  protected async _refreshInternalApiKeys() {\n    await this._internalApiKeysCache.refresh([]);\n  }\n\n  protected override async _refreshUsers() {\n    await Promise.all([\n      super._refreshUsers(),\n      this._metricsCache.refresh([false]),\n      this._metricsCache.refresh([true]),\n    ]);\n  }\n\n  get [stackAppInternalsSymbol]() {\n    return {\n      ...super[stackAppInternalsSymbol],\n      useMetrics: (includeAnonymous: boolean = false): any => {\n        return useAsyncCache(this._metricsCache, [includeAnonymous] as const, \"adminApp.useMetrics()\");\n      }\n    };\n  }\n\n  async sendTestEmail(options: {\n    recipientEmail: string,\n    emailConfig: EmailConfig,\n  }): Promise<Result<undefined, { errorMessage: string }>> {\n    const response = await this._interface.sendTestEmail({\n      recipient_email: options.recipientEmail,\n      email_config: {\n        ...(pick(options.emailConfig, ['host', 'port', 'username', 'password'])),\n        sender_email: options.emailConfig.senderEmail,\n        sender_name: options.emailConfig.senderName,\n      },\n    });\n\n    if (response.success) {\n      return Result.ok(undefined);\n    } else {\n      return Result.error({ errorMessage: response.error_message ?? throwErr(\"Email test error not specified\") });\n    }\n  }\n\n  async sendTestWebhook(options: { endpointId: string }): Promise<Result<undefined, { errorMessage: string }>> {\n    const response = await this._interface.sendTestWebhook({\n      endpoint_id: options.endpointId,\n    });\n\n    if (response.success) {\n      return Result.ok(undefined);\n    } else {\n      return Result.error({ errorMessage: response.error_message ?? throwErr(\"Webhook test error not specified\") });\n    }\n  }\n\n  async listSentEmails(): Promise<AdminSentEmail[]> {\n    const response = await this._interface.listSentEmails();\n    return response.items.map((email) => ({\n      id: email.id,\n      to: email.to ?? [],\n      subject: email.subject,\n      recipient: email.to?.[0] ?? \"\",\n      sentAt: new Date(email.sent_at_millis),\n      error: email.error,\n    }));\n  }\n\n  async sendSignInInvitationEmail(email: string, callbackUrl: string): Promise<void> {\n    await this._interface.sendSignInInvitationEmail(email, callbackUrl);\n  }\n\n  async createEmailTemplate(displayName: string): Promise<{ id: string }> {\n    const result = await this._interface.createEmailTemplate(displayName);\n    await this._adminEmailTemplatesCache.refresh([]);\n    return result;\n  }\n\n  async createEmailDraft(options: { displayName: string, themeId?: string | false, tsxSource?: string }): Promise<{ id: string }> {\n    const result = await this._interface.createEmailDraft({\n      display_name: options.displayName,\n      theme_id: options.themeId,\n      tsx_source: options.tsxSource,\n    });\n    await this._adminEmailDraftsCache.refresh([]);\n    return result;\n  }\n\n  async updateEmailDraft(id: string, data: { displayName?: string, themeId?: string | undefined | false, tsxSource?: string }): Promise<void> {\n    await this._interface.updateEmailDraft(id, {\n      display_name: data.displayName,\n      theme_id: data.themeId,\n      tsx_source: data.tsxSource,\n    });\n    await this._adminEmailDraftsCache.refresh([]);\n  }\n\n  async sendChatMessage(\n    threadId: string,\n    contextType: \"email-theme\" | \"email-template\" | \"email-draft\",\n    messages: Array<{ role: string, content: any }>,\n    abortSignal?: AbortSignal,\n  ): Promise<{ content: ChatContent }> {\n    return await this._interface.sendChatMessage(threadId, contextType, messages, abortSignal);\n  }\n\n  async saveChatMessage(threadId: string, message: any): Promise<void> {\n    await this._interface.saveChatMessage(threadId, message);\n  }\n\n  async listChatMessages(threadId: string): Promise<{ messages: Array<any> }> {\n    return await this._interface.listChatMessages(threadId);\n  }\n\n  async createEmailTheme(displayName: string): Promise<{ id: string }> {\n    const result = await this._interface.createEmailTheme(displayName);\n    await this._adminEmailThemesCache.refresh([]);\n    return result;\n  }\n\n  async getEmailPreview(options: { themeId?: string | null | false, themeTsxSource?: string, templateId?: string, templateTsxSource?: string }): Promise<string> {\n    return (await this._interface.renderEmailPreview(options)).html;\n  }\n  useEmailPreview(options: { themeId?: string | null | false, themeTsxSource?: string, templateId?: string, templateTsxSource?: string }): string {\n    const crud = useAsyncCache(this._emailPreviewCache, [options.themeId, options.themeTsxSource, options.templateId, options.templateTsxSource] as const, \"adminApp.useEmailPreview()\");\n    return crud.html;\n  }\n  useEmailTheme(id: string): { displayName: string, tsxSource: string } {\n    const crud = useAsyncCache(this._adminEmailThemeCache, [id] as const, \"adminApp.useEmailTheme()\");\n    return {\n      displayName: crud.display_name,\n      tsxSource: crud.tsx_source,\n    };\n  }\n  async updateEmailTheme(id: string, tsxSource: string): Promise<void> {\n    await this._interface.updateEmailTheme(id, tsxSource);\n  }\n  async updateEmailTemplate(id: string, tsxSource: string, themeId: string | null | false): Promise<{ renderedHtml: string }> {\n    const result = await this._interface.updateEmailTemplate(id, tsxSource, themeId);\n    await this._adminEmailTemplatesCache.refresh([]);\n    return { renderedHtml: result.rendered_html };\n  }\n\n  async setupPayments(): Promise<{ url: string }> {\n    return await this._interface.setupPayments();\n  }\n\n  async createStripeWidgetAccountSession(): Promise<{ client_secret: string }> {\n    return await this._interface.createStripeWidgetAccountSession();\n  }\n\n  async createItemQuantityChange(options: (\n    { userId: string, itemId: string, quantity: number, expiresAt?: string, description?: string } |\n    { teamId: string, itemId: string, quantity: number, expiresAt?: string, description?: string } |\n    { customCustomerId: string, itemId: string, quantity: number, expiresAt?: string, description?: string }\n  )): Promise<void> {\n    await this._interface.updateItemQuantity(\n      { itemId: options.itemId, ...(\"userId\" in options ? { userId: options.userId } : (\"teamId\" in options ? { teamId: options.teamId } : { customCustomerId: options.customCustomerId })) },\n      {\n        delta: options.quantity,\n        expires_at: options.expiresAt,\n        description: options.description,\n        allow_negative: true,\n      }\n    );\n  }\n\n  async refundTransaction(options: { type: \"subscription\" | \"one-time-purchase\", id: string }): Promise<void> {\n    await this._interface.refundTransaction({ type: options.type, id: options.id });\n    await this._transactionsCache.invalidateWhere(() => true);\n  }\n\n  async listTransactions(params: { cursor?: string, limit?: number, type?: TransactionType, customerType?: 'user' | 'team' | 'custom' }): Promise<{ transactions: Transaction[], nextCursor: string | null }> {\n    const crud = Result.orThrow(await this._transactionsCache.getOrWait([params.cursor, params.limit, params.type, params.customerType] as const, \"write-only\"));\n    return crud;\n  }\n\n  useTransactions(params: { cursor?: string, limit?: number, type?: TransactionType, customerType?: 'user' | 'team' | 'custom' }): { transactions: Transaction[], nextCursor: string | null } {\n    const data = useAsyncCache(this._transactionsCache, [params.cursor, params.limit, params.type, params.customerType] as const, \"adminApp.useTransactions()\");\n    return data;\n  }\n\n  async getStripeAccountInfo(): Promise<null | { account_id: string, charges_enabled: boolean, details_submitted: boolean, payouts_enabled: boolean }> {\n    return await this._interface.getStripeAccountInfo();\n  }\n\n  useStripeAccountInfo(): { account_id: string, charges_enabled: boolean, details_submitted: boolean, payouts_enabled: boolean } | null {\n    const data = useAsyncCache(this._stripeAccountInfoCache, [], \"adminApp.useStripeAccountInfo()\");\n    return data;\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5662, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack/src/lib/stack-app/apps/implementations/index.ts"],"sourcesContent":["\n//===========================================\n// THIS FILE IS AUTO-GENERATED FROM TEMPLATE. DO NOT EDIT IT DIRECTLY\n//===========================================\n\nimport { scrambleDuringCompileTime } from \"@stackframe/stack-shared/dist/utils/compile-time\";\nimport { _StackAdminAppImplIncomplete } from \"./admin-app-impl\";\nimport { _StackClientAppImplIncomplete } from \"./client-app-impl\";\nimport { _StackServerAppImplIncomplete } from \"./server-app-impl\";\n\n\n/**\n * Prevents a circular dependency between the client and admin apps. For more information, see the documentation comment\n * of `_StackClientAppImplIncomplete.LazyStackAdminAppImpl`.\n *\n * Note: This is an explicitly defined function that returns the new values (and not a barrel file with top-level side\n * effects) because we have `sideEffects: false` in the package.json, and so it would be tree-shaken away if we just\n * exported the values directly.\n */\nfunction complete() {\n  _StackClientAppImplIncomplete.LazyStackAdminAppImpl.value = _StackAdminAppImplIncomplete;\n\n  return {\n    _StackAdminAppImpl: scrambleDuringCompileTime(_StackAdminAppImplIncomplete),\n    _StackClientAppImpl: scrambleDuringCompileTime(_StackClientAppImplIncomplete),\n    _StackServerAppImpl: scrambleDuringCompileTime(_StackServerAppImplIncomplete),\n  };\n}\n\nexport const {\n  _StackAdminAppImpl,\n  _StackClientAppImpl,\n  _StackServerAppImpl\n} = complete();\n\n"],"names":[],"mappings":";;;;;;;;;AAKA,SAAS,iCAAiC;AAC1C,SAAS,oCAAoC;AAC7C,SAAS,qCAAqC;AAC9C,SAAS,qCAAqC;;;;;AAW9C,SAAS,WAAW;IAClB,uSAAA,CAA8B,qBAAA,CAAsB,KAAA,GAAQ,qSAAA;IAE5D,OAAO;QACL,wBAAoB,8PAAA,EAA0B,qSAA4B;QAC1E,yBAAqB,8PAAA,EAA0B,uSAA6B;QAC5E,yBAAqB,8PAAA,EAA0B,uSAA6B;IAC9E;AACF;AAEO,IAAM,EACX,kBAAA,EACA,mBAAA,EACA,mBAAA,EACF,GAAI,SAAS"}},
    {"offset": {"line": 5694, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack/src/lib/stack-app/apps/interfaces/client-app.ts"],"sourcesContent":["\n//===========================================\n// THIS FILE IS AUTO-GENERATED FROM TEMPLATE. DO NOT EDIT IT DIRECTLY\n//===========================================\nimport { KnownErrors } from \"@stackframe/stack-shared\";\nimport { CurrentUserCrud } from \"@stackframe/stack-shared/dist/interface/crud/current-user\";\nimport { Result } from \"@stackframe/stack-shared/dist/utils/results\";\nimport { AsyncStoreProperty, AuthLike, GetCurrentPartialUserOptions, GetCurrentUserOptions, HandlerUrls, OAuthScopesOnSignIn, RedirectMethod, RedirectToOptions, TokenStoreInit, stackAppInternalsSymbol } from \"../../common\";\nimport { CustomerProductsList, CustomerProductsRequestOptions, Item } from \"../../customers\";\nimport { Project } from \"../../projects\";\nimport { ProjectCurrentUser, SyncedPartialUser, TokenPartialUser } from \"../../users\";\nimport { _StackClientAppImpl } from \"../implementations\";\n\nexport type StackClientAppConstructorOptions<HasTokenStore extends boolean, ProjectId extends string> = {\n  baseUrl?: string | { browser: string, server: string },\n  extraRequestHeaders?: Record<string, string>,\n  projectId?: ProjectId,\n  publishableClientKey?: string,\n  urls?: Partial<HandlerUrls>,\n  oauthScopesOnSignIn?: Partial<OAuthScopesOnSignIn>,\n  tokenStore?: TokenStoreInit<HasTokenStore>,\n  redirectMethod?: RedirectMethod,\n  inheritsFrom?: StackClientApp<any, any>,\n\n  /**\n   * By default, the Stack app will automatically prefetch some data from Stack's server when this app is first\n   * constructed. This improves the performance of your app, but will create network requests that are unnecessary if\n   * the app is never used or disposed of immediately. To disable this behavior, set this option to true.\n   */\n  noAutomaticPrefetch?: boolean,\n} & (\n  { tokenStore: TokenStoreInit<HasTokenStore> } | { tokenStore?: undefined, inheritsFrom: StackClientApp<HasTokenStore, any> }\n) & (\n  string extends ProjectId ? unknown : ({ projectId: ProjectId } | { inheritsFrom: StackClientApp<any, ProjectId> })\n);\n\n\nexport type StackClientAppJson<HasTokenStore extends boolean, ProjectId extends string> = StackClientAppConstructorOptions<HasTokenStore, ProjectId> & { inheritsFrom?: undefined } & {\n  uniqueIdentifier: string,\n  // note: if you add more fields here, make sure to ensure the checkString in the constructor has/doesn't have them\n};\n\nexport type StackClientApp<HasTokenStore extends boolean = boolean, ProjectId extends string = string> = (\n  & {\n    readonly projectId: ProjectId,\n\n    readonly urls: Readonly<HandlerUrls>,\n\n    signInWithOAuth(provider: string, options?: { returnTo?: string }): Promise<void>,\n    signInWithCredential(options: { email: string, password: string, noRedirect?: boolean }): Promise<Result<undefined, KnownErrors[\"EmailPasswordMismatch\"] | KnownErrors[\"InvalidTotpCode\"]>>,\n    signUpWithCredential(options: { email: string, password: string, noRedirect?: boolean } & ({ noVerificationCallback: true } | { noVerificationCallback?: false, verificationCallbackUrl?: string })): Promise<Result<undefined, KnownErrors[\"UserWithEmailAlreadyExists\"] | KnownErrors[\"PasswordRequirementsNotMet\"]>>,\n    signInWithPasskey(): Promise<Result<undefined, KnownErrors[\"PasskeyAuthenticationFailed\"] | KnownErrors[\"InvalidTotpCode\"] | KnownErrors[\"PasskeyWebAuthnError\"]>>,\n    callOAuthCallback(): Promise<boolean>,\n    promptCliLogin(options: { appUrl: string, expiresInMillis?: number }): Promise<Result<string, KnownErrors[\"CliAuthError\"] | KnownErrors[\"CliAuthExpiredError\"] | KnownErrors[\"CliAuthUsedError\"]>>,\n    sendForgotPasswordEmail(email: string, options?: { callbackUrl?: string }): Promise<Result<undefined, KnownErrors[\"UserNotFound\"]>>,\n    sendMagicLinkEmail(email: string, options?: { callbackUrl?: string }): Promise<Result<{ nonce: string }, KnownErrors[\"RedirectUrlNotWhitelisted\"]>>,\n    resetPassword(options: { code: string, password: string }): Promise<Result<undefined, KnownErrors[\"VerificationCodeError\"]>>,\n    verifyPasswordResetCode(code: string): Promise<Result<undefined, KnownErrors[\"VerificationCodeError\"]>>,\n    verifyTeamInvitationCode(code: string): Promise<Result<undefined, KnownErrors[\"VerificationCodeError\"]>>,\n    acceptTeamInvitation(code: string): Promise<Result<undefined, KnownErrors[\"VerificationCodeError\"]>>,\n    getTeamInvitationDetails(code: string): Promise<Result<{ teamDisplayName: string }, KnownErrors[\"VerificationCodeError\"]>>,\n    verifyEmail(code: string): Promise<Result<undefined, KnownErrors[\"VerificationCodeError\"]>>,\n    signInWithMagicLink(code: string, options?: { noRedirect?: boolean }): Promise<Result<undefined, KnownErrors[\"VerificationCodeError\"] | KnownErrors[\"InvalidTotpCode\"]>>,\n    signInWithMfa(otp: string, code: string, options?: { noRedirect?: boolean }): Promise<Result<undefined, KnownErrors[\"VerificationCodeError\"] | KnownErrors[\"InvalidTotpCode\"]>>,\n\n    redirectToOAuthCallback(): Promise<void>,\n\n    getConvexClientAuth(options: HasTokenStore extends false ? { tokenStore: TokenStoreInit } : { tokenStore?: TokenStoreInit }): (args: { forceRefreshToken: boolean }) => Promise<string | null>,\n    getConvexHttpClientAuth(options: { tokenStore: TokenStoreInit }): Promise<string>,\n\n    useUser(options: GetCurrentUserOptions<HasTokenStore> & { or: 'redirect' }): ProjectCurrentUser<ProjectId>,\n    useUser(options: GetCurrentUserOptions<HasTokenStore> & { or: 'throw' }): ProjectCurrentUser<ProjectId>,\n    useUser(options: GetCurrentUserOptions<HasTokenStore> & { or: 'anonymous' }): ProjectCurrentUser<ProjectId>,\n    useUser(options?: GetCurrentUserOptions<HasTokenStore>): ProjectCurrentUser<ProjectId> | null,\n\n    getUser(options: GetCurrentUserOptions<HasTokenStore> & { or: 'redirect' }): Promise<ProjectCurrentUser<ProjectId>>,\n    getUser(options: GetCurrentUserOptions<HasTokenStore> & { or: 'throw' }): Promise<ProjectCurrentUser<ProjectId>>,\n    getUser(options: GetCurrentUserOptions<HasTokenStore> & { or: 'anonymous' }): Promise<ProjectCurrentUser<ProjectId>>,\n    getUser(options?: GetCurrentUserOptions<HasTokenStore>): Promise<ProjectCurrentUser<ProjectId> | null>,\n\n    // note: we don't special-case 'anonymous' here to return non-null, see GetPartialUserOptions for more details\n    getPartialUser(options: GetCurrentPartialUserOptions<HasTokenStore> & { from: 'token' }): Promise<TokenPartialUser | null>,\n    getPartialUser(options: GetCurrentPartialUserOptions<HasTokenStore> & { from: 'convex' }): Promise<TokenPartialUser | null>,\n    getPartialUser(options: GetCurrentPartialUserOptions<HasTokenStore>): Promise<SyncedPartialUser | TokenPartialUser | null>,\n    usePartialUser(options: GetCurrentPartialUserOptions<HasTokenStore> & { from: 'token' }): TokenPartialUser | null,\n    usePartialUser(options: GetCurrentPartialUserOptions<HasTokenStore> & { from: 'convex' }): TokenPartialUser | null,\n    usePartialUser(options: GetCurrentPartialUserOptions<HasTokenStore>): SyncedPartialUser | TokenPartialUser | null,\n    useNavigate(): (to: string) => void, // THIS_LINE_PLATFORM react-like\n\n    [stackAppInternalsSymbol]: {\n      toClientJson(): StackClientAppJson<HasTokenStore, ProjectId>,\n      setCurrentUser(userJsonPromise: Promise<CurrentUserCrud['Client']['Read'] | null>): void,\n      getConstructorOptions(): StackClientAppConstructorOptions<HasTokenStore, ProjectId> & { inheritsFrom?: undefined },\n    },\n  }\n  & AsyncStoreProperty<\"project\", [], Project, false>\n  & AsyncStoreProperty<\n    \"item\",\n    [{ itemId: string, userId: string } | { itemId: string, teamId: string } | { itemId: string, customCustomerId: string }],\n    Item,\n    false\n  >\n  & AsyncStoreProperty<\n    \"products\",\n    [options: CustomerProductsRequestOptions],\n    CustomerProductsList,\n    true\n  >\n  & { [K in `redirectTo${Capitalize<keyof Omit<HandlerUrls, 'handler' | 'oauthCallback'>>}`]: (options?: RedirectToOptions) => Promise<void> }\n  & AuthLike<HasTokenStore extends false ? { tokenStore: TokenStoreInit } : { tokenStore?: TokenStoreInit }>\n);\nexport type StackClientAppConstructor = {\n  new <\n    TokenStoreType extends string,\n    HasTokenStore extends (TokenStoreType extends {} ? true : boolean),\n    ProjectId extends string\n  >(options: StackClientAppConstructorOptions<HasTokenStore, ProjectId>): StackClientApp<HasTokenStore, ProjectId>,\n  new(options: StackClientAppConstructorOptions<boolean, string>): StackClientApp<boolean, string>,\n\n  [stackAppInternalsSymbol]: {\n    fromClientJson<HasTokenStore extends boolean, ProjectId extends string>(\n      json: StackClientAppJson<HasTokenStore, ProjectId>\n    ): StackClientApp<HasTokenStore, ProjectId>,\n  },\n};\nexport const StackClientApp: StackClientAppConstructor = _StackClientAppImpl;\n"],"names":[],"mappings":";;;;;AAWA,SAAS,2BAA2B;;AAkH7B,IAAM,iBAA4C,6QAAA"}},
    {"offset": {"line": 5708, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ES/Desktop/2025/EstateIQIndia/node_modules/%40stackframe/stack/src/lib/translations.tsx"],"sourcesContent":["\n//===========================================\n// THIS FILE IS AUTO-GENERATED FROM TEMPLATE. DO NOT EDIT IT DIRECTLY\n//===========================================\nimport React from \"react\";\nimport { TranslationContext } from \"../providers/translation-provider-client\";\n\nexport function useTranslation() {\n  const translationContext = React.useContext(TranslationContext);\n  if (!translationContext) {\n    throw new Error(\"Translation context not found; did you forget to wrap your app in a <StackProvider />?\");\n  }\n  return {\n    t: (str: string, templateVars?: Record<string, string>) => {\n      const { quetzalKeys, quetzalLocale } = translationContext;\n      let translation = quetzalLocale.get(quetzalKeys.get(str) ?? (undefined as never)) ?? str;\n      for (const [key, value] of Object.entries(templateVars || {})) {\n        translation = translation.replace(`{${key}}`, value);\n      }\n      return translation;\n    },\n  };\n}\n"],"names":[],"mappings":";;;;;AAIA,OAAO,WAAW;AAClB,SAAS,0BAA0B;;;AAE5B,SAAS,iBAAiB;IAC/B,MAAM,qBAAqB,4MAAA,CAAM,UAAA,CAAW,mQAAkB;IAC9D,IAAI,CAAC,oBAAoB;QACvB,MAAM,IAAI,MAAM,wFAAwF;IAC1G;IACA,OAAO;QACL,GAAG,CAAC,KAAa,iBAA0C;YACzD,MAAM,EAAE,WAAA,EAAa,aAAA,CAAc,CAAA,GAAI;YACvC,IAAI,cAAc,cAAc,GAAA,CAAI,YAAY,GAAA,CAAI,GAAG,KAAM,KAAA,CAAmB,KAAK;YACrF,KAAA,MAAW,CAAC,KAAK,KAAK,CAAA,IAAK,OAAO,OAAA,CAAQ,gBAAgB,CAAC,CAAC,EAAG;gBAC7D,cAAc,YAAY,OAAA,CAAQ,CAAA,CAAA,EAAI,GAAG,CAAA,CAAA,CAAA,EAAK,KAAK;YACrD;YACA,OAAO;QACT;IACF;AACF"}}]
}